<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-08-18 Tue 14:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Capa de Transporte, UDP y Entrega confiable</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<p>
It has the critical role of providing communication services directly to the
application processes running on different hosts.
</p>

<p>
extending the network layer’s delivery service between two end systems to a
delivery service between two application-layer processes running on the end
systems.
</p>

<div id="outline-container-org5635d0d" class="outline-2">
<h2 id="org5635d0d">Introduccion y Servicios de Capa de Transporte</h2>
<div class="outline-text-2" id="text-org5635d0d">
<p>
A transport-layer protocol provides for <code>logical communication</code> between
application processes running on different hosts. By logical communication, we
mean that from an application’s perspective, it is as if the hosts running the
processes were directly connected
</p>


<p>
Application processes use the logical communication provided by the transport
layer to send messages to each other, free from the worry of the details of the
physical infrastructure used to carry these messages.
</p>

<p>
imagen 3.1
</p>

<p>
As shown in Figure 3.1, transport-layer protocols are implemented in the end
systems but not in network routers. On the sending side, the transport layer
converts the application-layer messages it receives from a sending application
process into transport-layer packets, known as transport-layer <code>segments</code>
</p>
</div>

<div id="outline-container-org32a4ba6" class="outline-3">
<h3 id="org32a4ba6">Relacion entre las capas de transporte y red</h3>
<div class="outline-text-3" id="text-org32a4ba6">
<p>
network-layer protocol provides logical-communication between hosts. This
distinction is subtle but important.
</p>
</div>
</div>

<div id="outline-container-orgf512d8a" class="outline-3">
<h3 id="orgf512d8a">Overview of the Transport Layer in the Internet</h3>
<div class="outline-text-3" id="text-orgf512d8a">
<p>
Recall that the Internet makes two distinct transport-layer protocols available
to the application layer.
</p>

<p>
One of these protocols is <code>UDP</code> (User Datagram Protocol), which provides an
unreliable, connectionless service to the invoking application.
</p>

<p>
The second of these protocols is <code>TCP</code> (Transmission Control Protocol), which
provides a reliable, connection-oriented service to the invoking application.
When
</p>


<p>
The most fundamental responsibility of UDP and TCP is to extend
IP’s delivery service between two end systems to a delivery service between two
processes running on the end systems. Extending host-to-host delivery to
process-to-process delivery is called <code>transport-layer multiplexing</code> and
<code>demultiplexing</code>.
</p>

<p>
UDP and TCP also provide integrity checking by including error-detection fields
in their segments’ headers. These two minimal transport-layer
services—process-to-process data delivery and error checking—are the only two
services that UDP provides! In particular, like IP, UDP is an unreliable
service—it does not guarantee that data sent by one process will arrive intact
(or at all!) to the destination process.
</p>

<p>
TCP, offers several additional services to applications. First and foremost, it
provides <code>reliable data transfer</code>. Using flow control, sequence numbers,
acknowledgments, and timers, TCP ensures that data is delivered from sending
process to receiving process, correctly and in order. TCP thus converts IP’s
unreliable service between end systems into a reliable data transport service
between processes.
</p>

<p>
TCP also provides <code>congestion control</code>. <code>Congestion control</code> is not so much a
service provided to the invoking application as it is a service for the Internet
as a whole, a service for the general good. Loosely speaking, TCP congestion
control prevents any one TCP connection from swamping the links and routers
between communicating hosts with an excessive amount of traffic. TCP strives to
give each connection traversing a congested link an equal share of the link
bandwidth. This is done by regulating the rate at which the sending sides of TCP
connections can send traffic into the network. UDP traffic, on the other hand,
is unregulated. An application using UDP transport can send at any rate it
pleases, for as long as it pleases.
</p>
</div>
</div>
</div>

<div id="outline-container-org417158b" class="outline-2">
<h2 id="org417158b">Multiplexing and Demultiplexing</h2>
<div class="outline-text-2" id="text-org417158b">
<p>
In this section, we discuss transport-layer multiplexing and demultiplexing,
that is, extending the host-to- host delivery service provided by the network
layer to a process-to-process delivery service for applications running on the
hosts.
</p>

<p>
imagen 3.2
</p>

<p>
Recall that application processes communite to the network through sockets.
</p>

<p>
a receiving host directs an incoming transport-layer segment to the appropriate
socket. Each transport-layer segment has a set of fields in the segment for this
purpose. At the receiving end, the transport layer examines these fields to
identify the receiving socket and then directs the segment to that socket. This
job of delivering the data in a transport-layer segment to the correct socket is
called <code>demultiplexing</code>.
</p>

<p>
The job of gathering data chunks at the source host from different sockets,
encapsulating each data chunk with header information (that will later be used
in demultiplexing) to create segments, and passing the segments to the network
layer is called <code>multiplexing</code>.
</p>

<p>
we know that transport-layer multiplexing requires (1) that sockets have unique
identifiers, and (2) that each segment have special fields that indicate the
socket to which the segment is to be delivered. These special fields, are the
<code>source port number field</code> and the <code>destination port number field</code>.
</p>

<p>
imagen 3.3
</p>

<p>
Each port number is a 16-bit number, ranging from 0 to 65535.
</p>

<p>
The port numbers ranging from 0 to 1023 are called well-known port numbers and
are restricted, which means that they are reserved for use by well-known
application protocols such as HTTP (which uses port number 80) and FTP (which
uses port number 21).
</p>

<p>
RFC 1700
</p>
</div>

<div id="outline-container-org770e932" class="outline-4">
<h4 id="org770e932">Connectionless Multiplexing and Demultiplexing</h4>
<div class="outline-text-4" id="text-org770e932">
<p>
Typically, the client side of the application lets the transport layer
automatically (and transparently) assign the port number, whereas the server
side of the application assigns a specific port number.
</p>

<p>
With port numbers assigned to UDP sockets, we can now precisely describe UDP
multiplexing/demultiplexing. Suppose a process in Host A, with UDP port 19157, wants to send a chunk
of application data to a process with UDP port 46428 in Host B. The transport layer in Host A creates a
transport-layer segment that includes the application data, the source port number (19157), the
destination port number (46428), and two other values (which will be discussed later, but are
unimportant for the current discussion). The transport layer then passes the resulting segment to the
network layer. The network layer encapsulates the segment in an IP datagram and makes a best-effort
attempt to deliver the segment to the receiving host. If the segment arrives at the receiving Host B, the
transport layer at the receiving host examines the destination port number in the segment (46428) and
delivers the segment to its socket identified by port 46428. Note that Host B could be running multiple
processes, each with its own UDP socket and associated port number. As UDP segments arrive from
the network, Host B directs (demultiplexes) each segment to the appropriate socket by examining the
segment’s destination port number.
</p>

<p>
It is important to note that a UDP socket is fully identified by a two-tuple consisting of a destination IP
address and a destination port number. As a consequence, if two UDP segments have different source
IP addresses and/or source port numbers, but have the same destination IP address and destination
port number, then the two segments will be directed to the same destination process via the same
destination socket.
</p>

<p>
You may be wondering now, what is the purpose of the source port number? As shown in Figure 3.4, in
the A-to-B segment the source port number serves as part of a “return address”—when B wants to send
a segment back to A, the destination port in the B-to-A segment will take its value from the source port
value of the A-to-B segment. (The complete return address is A’s IP address and the source port
number.)
</p>

<p>
imagen 3.4
</p>
</div>
</div>

<div id="outline-container-orge168b26" class="outline-4">
<h4 id="orge168b26">Connection-Oriented Multiplexing and Demultiplexing</h4>
<div class="outline-text-4" id="text-orge168b26">
<p>
In order to understand TCP demultiplexing, we have to take a close look at TCP
sockets and TCP connection establishment. One subtle difference between a TCP
socket and a UDP socket is that a TCP socket is identified by a four-tuple:
(source IP address, source port number, destination IP address, destination port
number). Thus, when a TCP segment arrives from the network to a host, the host
uses all four values to direct (demultiplex) the segment to the appropriate
socket.
</p>

<p>
In particular, and in contrast with UDP, two arriving TCP segments with
different source IP addresses or source port numbers will (with the exception of
a TCP segment carrying the original connection- establishment request) be
directed to two different sockets. To gain further insight, let’s reconsider the
TCP client-server programming example in Section 2.7.2:
</p>

<ul class="org-ul">
<li>The TCP server application has a “welcoming socket,” that waits for
connection-establishment requests from TCP clients on port number 12000.</li>
<li>The TCP client creates a socket and sends a connection establishment request
segment.</li>
<li>A connection-establishment request is nothing more than a TCP segment with
destination port number 12000 and a special connection-establishment bit set
in the TCP header. The segment also includes a source port number that was
chosen by the client.</li>
<li>When the host operating system of the computer running the server process
receives the incoming connection-request segment with destination port 12000,
it locates the server process that is waiting to accept a connection on port
number 12000.</li>
<li><p>
Also, the transport layer at the server notes the following four values in the
connection-request segment: (1) the source port number in the segment, (2) the
IP address of the source host, (3) the destination port number in the segment,
and (4) its own IP address. The newly created connection socket is identified
by these four values; all subsequently arriving segments whose source port,
source IP address, destination port, and destination IP address match these
four values will be demultiplexed to this socket. With the TCP connection now
in place, the client and server can now send data to each other.
</p>

<p>
imagen 3.5
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgaf875e8" class="outline-2">
<h2 id="orgaf875e8">Transporte sin conexion: UDP</h2>
<div class="outline-text-2" id="text-orgaf875e8">
<p>
suppose you were interested in designing a no-frills, bare-bones
transport protocol. How might you go about doing this?
</p>

<p>
At the very least, the transport layer has to provide a multiplexing/demultiplexing service in order to pass
data between the network layer and the correct application-level process.
</p>

<p>
UDP, defined in [RFC 768], does just about as little as a transport protocol can
do. Aside from the multiplexing/demultiplexing function and some light error
checking, it adds nothing to IP. In fact, if the application developer chooses
UDP instead of TCP, then the application is almost directly talking with IP. UDP
takes messages from the application process, attaches source and destination
port number fields for the multiplexing/demultiplexing service, adds two other
small fields, and passes the resulting segment to the network layer. The network
layer encapsulates the transport-layer segment into an IP datagram and then
makes a best-effort attempt to deliver the segment to the receiving host. If the
segment arrives at the receiving host, UDP uses the destination port number to
deliver the segment’s data to the correct application process. Note that with
UDP there is no handshaking between sending and receiving transport-layer
entities before sending a segment. For this reason, UDP is said to be
<code>connectionless</code>.
</p>

<p>
DNS is an example of an application-layer protocol that typically uses UDP.
</p>

<p>
some applications are better suited for UDP for the following reasons:
</p>

<dl class="org-dl">
<dt>Finer application-level control over what data is sent, and when</dt><dd>Under UDP,
as soon as an application process passes data to UDP, UDP will package the
data inside a UDP segment and immediately pass the segment to the network
layer. TCP, on the other hand, has a congestion- control mechanism that
throttles the transport-layer TCP sender when one or more links between the
source and destination hosts become excessively congested. TCP will also
continue to resend a segment until the receipt of the segment has been
acknowledged by the destination, regardless of how long reliable delivery
takes. Since real-time applications often require a minimum sending rate, do
not want to overly delay segment transmission, and can tolerate some data
loss, TCP’s service model is not particularly well matched to these
applications’ needs. As discussed below, these applications can use UDP and
implement, as part of the application, any additional functionality that is
needed beyond UDP’s no-frills segment-delivery service.</dd>
<dt>No connection establishment</dt><dd>As we’ll discuss later, TCP uses a three-way
handshake before it starts to transfer data. UDP just blasts away without any
formal preliminaries. Thus UDP does not introduce any delay to establish a
connection. This is probably the principal reason why DNS runs over UDP rather
than TCP—DNS would be much slower if it ran over TCP. HTTP uses TCP rather
than UDP, since reliability is critical for Web pages with text. But, as we
briefly discussed in Section 2.2, the TCP connection-establishment delay in
HTTP is an important contributor to the delays associated with downloading Web
documents. Indeed, the QUIC protocol (Quick UDP Internet Connection, [Iyengar
2015]), used in Google’s Chrome browser, uses UDP as its underlying transport
protocol and implements reliability in an application-layer protocol on top of
UDP.</dd>
<dt>No connection state</dt><dd>TCP maintains connection state in the end systems. This
connection state includes receive and send buffers, congestion-control
parameters, and sequence and acknowledgment number parameters. We will see in
Section 3.5 that this state information is needed to implement TCP’s reliable
data transfer service and to provide congestion control. UDP, on the other
hand, does not maintain connection state and does not track any of these
parameters. For this reason, a server devoted to a particular application can
typically support many more active clients when the application runs over UDP
rather than TCP.</dd>
<dt>Small packet header overhead</dt><dd><p>
The TCP segment has 20 bytes of header
overhead in every segment, whereas UDP has only 8 bytes of overhead.
</p>

<p>
imagen 3.6
</p></dd>
</dl>
</div>

<div id="outline-container-org42ad295" class="outline-3">
<h3 id="org42ad295">UDP Segment Structure</h3>
<div class="outline-text-3" id="text-org42ad295">
<p>
imagen 3.7
</p>

<p>
The UDP segment structure, shown in Figure 3.7, is defined in RFC 768. The
application data occupies the data field of the UDP segment.
</p>

<p>
For example, for DNS, the data field contains either a query message or a
response message. For a streaming audio application, audio samples fill the data
field. The UDP header has only four fields, each consisting of two bytes.
</p>

<p>
The length field specifies the number of bytes in the UDP segment (header plus
data). An explicit length value is needed since the size of the data field may
differ from one UDP segment to the next.
</p>

<p>
The checksum is used by the receiving host to check whether errors have been
introduced into the segment. In truth, the checksum is also calculated over a
few of the fields in the IP header in addition to the UDP segment.
</p>

<p>
The length field specifies the length of the UDP segment, including the header,
in bytes.
</p>
</div>
</div>

<div id="outline-container-orgdf40332" class="outline-3">
<h3 id="orgdf40332">UDP Checksum</h3>
<div class="outline-text-3" id="text-orgdf40332">
<p>
The UDP checksum provides for error detection. That is, the checksum is used to
determine whether bits within the UDP segment have been altered (for example, by
noise in the links or while stored in a router) as it moved from source to destination.
</p>

<p>
UDP at the sender side performs the 1s complement of the sum of all the 16-bit
words in the segment, with any overflow encountered during the sum being wrapped
around. This result is put in the checksum field of the UDP segment.
</p>

<p>
You may wonder why UDP provides a checksum in the first place, as many
link-layer protocols (including the popular Ethernet protocol) also provide
error checking. The reason is that there is no guarantee that all the links
between source and destination provide error checking; that is, one of the links
may use a link-layer protocol that does not provide error checking. Furthermore,
even if segments are correctly transferred across a link, it’s possible that bit
errors could be introduced when a segment is stored in a router’s memory. Given
that neither link-by-link reliability nor in-memory error detection is
guaranteed, UDP must provide error detection at the transport layer, on an
end-end basis, if the end- end data transfer service is to provide error
detection.
</p>

<p>
Because IP is supposed to run over just about any layer-2 protocol, it is useful
for the transport layer to provide error checking as a safety measure. Although
UDP provides error checking, it does not do anything to recover from an error.
</p>
</div>
</div>
</div>

<div id="outline-container-org016b3de" class="outline-2">
<h2 id="org016b3de">Principles of Reliable Data Transfer</h2>
<div class="outline-text-2" id="text-org016b3de">
<p>
With a reliable channel, no transferred data bits are corrupted (flipped from 0
to 1, or vice versa) or lost, and all are delivered in the order in which they
were sent. This is precisely the service model offered by TCP to the Internet
applications that invoke it.
</p>

<p>
It is the responsibility of a <code>reliable data transfer protocol</code> to implement
this service abstraction. This task is made difficult by the fact that the layer
below the reliable data transfer protocol may be unreliable.
</p>

<p>
imagen 3.8
</p>

<p>
rdt : reliable data transfer
</p>

<p>
In this section we consider only the case of unidirectional data transfer, that
is, data transfer from the sending to the receiving side. The case of reliable
bidirectional (that is, full-duplex) data transfer is conceptually no more
difficult but considerably more tedious to explain.
</p>

<p>
In addition to exchanging packets containing the data to be transferred, the
sending and receiving sides of rdt will also need to exchange control packets
back and forth. Both the send and receive sides of rdt send packets to the other
side by a call to udt<sub>send</sub>() (where udt stands for unerliable data transfer).
</p>
</div>

<div id="outline-container-orge3916a4" class="outline-3">
<h3 id="orge3916a4">Building a Reliable Data Transfer Protocol</h3>
<div class="outline-text-3" id="text-orge3916a4">
</div>
<div id="outline-container-org1dc9762" class="outline-4">
<h4 id="org1dc9762">Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0</h4>
<div class="outline-text-4" id="text-org1dc9762">
<p>
We first consider the simplest case, in which the underlying channel is completely reliable.
</p>

<p>
Two <code>finite-state machines (FSM)</code> define the operations of an rdt1.0 sender and an rdt1.0 receiver.
</p>

<p>
imagen 3.9
</p>

<p>
Each FSM has one state
</p>

<p>
The sending side of rdt simply accepts data from the upper layer via the
<code>rdt_send(data)</code> event, creates a packet containing the data (via the action
<code>make_pkt(data)</code>) and sends the packet into the channel. In practice, the
<code>rdt_send(data)</code> event would result from a procedure call (for example, to
<code>rdt_send()</code>) by the upper-layer application.
</p>

<p>
On the receiving side, rdt receives a packet from the underlying channel via the
<code>rdt_rcv(packet)</code> event, removes the data from the packet (via the action
<code>extract (packet, data)</code> ) and passes the data up to the upper layer (via the
action <code>deliver_data(data)</code> ). In practice, the <code>rdt_rcv(packet)</code> event would
result from a procedure call (for example, to <code>rdt_rcv()</code>) from the lower-layer
protocol.
</p>

<p>
In this simple protocol, there is no difference between a unit of data and a
packet. Also, all packet flow is from the sender to receiver; with a perfectly
reliable channel there is no need for the receiver side to provide any feedback
to the sender since nothing can go wrong! Note that we have also assumed that
the receiver is able to receive data as fast as the sender happens to send data.
Thus, there is no need for the receiver to ask the sender to slow down.
</p>
</div>
</div>

<div id="outline-container-orgaa91f1b" class="outline-4">
<h4 id="orgaa91f1b">Reliable Data Transfer over a Channel with Bit Errors: rdt2.0</h4>
<div class="outline-text-4" id="text-orgaa91f1b">
<p>
A more realistic model of the underlying channel is one in which bits in a
packet may be corrupted.
</p>

<p>
We’ll continue to assume for the moment that all transmitted packets are
received (although their bits may be corrupted) in the order in which they were
sent.
</p>
</div>

<div id="outline-container-org65a0a09" class="outline-5">
<h5 id="org65a0a09">ARQ (Automatic Repeat reQuest) protocols</h5>
<div class="outline-text-5" id="text-org65a0a09">
<p>
Reliable data transfer protocols based on retransmissions depending on the
control messages sent.
</p>

<p>
The types of control messages are
</p>
<ul class="org-ul">
<li>positive acknowledgments</li>
<li>negative acknowledgments</li>
</ul>

<p>
These control messages allow the <b>reciever</b> to let the sender know what has been
received correctly, and what has been received in error and thus requires
repeating.
</p>

<p>
three additional protocol capabilities are required in ARQ protocols to handle
the presence of bit errors:
</p>
<dl class="org-dl">
<dt>Error detection</dt><dd>a mechanism that allows the receiver to detect when bit
errors have occurred. Recall from the previous section that UDP uses the
Internet checksum field for exactly this purpose. For now, we need only know
that these techniques require that extra bits (beyond the bits of original
data to be transferred) be sent from the sender to the receiver; these bits
will be gathered into the packet checksum field of the rdt2.0 data packet.</dd>
<dt>Receiver feedback</dt><dd>the only way for the sender to know whether or not a
packet was received correctly, is for the receiver to provide explicit
feedback to the sender. The positive (<code>ACK</code>) and negative (<code>NAK</code>)
acknowledgment replies in the message-dictation scenario are examples of such
feedback. Our rdt2.0 protocol will similarly send ACK and NAK packets back
from the receiver to the sender. In principle, these packets need only be one
bit long; for example, a 0 value could indicate a NAK and a value of 1 could
indicate an ACK.</dd>
<dt>Retransmission</dt><dd>A packet that is received in error at the receiver will be
retransmitted by the sender.</dd>
</dl>

<p>
imagen 3.10
</p>

<p>
The send side of rdt2.0 has two states.
</p>

<ul class="org-ul">
<li>In the leftmost state, the send-side protocol is waiting for data to be passed
down from the upper layer. When the <code>rdt_send(data)</code> event occurs, the sender
will create a packet ( <code>sndpkt</code> ) containing the data to be sent, along with a
packet checksum and then send the packet via the <code>udt_send(sndpkt)</code> operation.</li>
<li>In the rightmost state, the sender protocol is waiting for an ACK or a NAK
packet from the receiver.
<ul class="org-ul">
<li>If an ACK packet is received the sender knows that the most recently
transmitted packet has been received correctly and thus the protocol returns
to the state of waiting for data from the upper layer.</li>
<li>If a NAK is received, the protocol retransmits the last packet and waits for
an ACK or NAK to be returned by the receiver in response to the
retransmitted data packet.</li>
</ul></li>
</ul>

<p>
when the sender is in the wait-for-ACK-or-NAK state, it cannot get more data
from the upper layer; that is, the <code>rdt_send()</code> event can not occur; that will
happen only after the sender receives an ACK and leaves this state. Thus, the
sender will not send a new piece of data until it is sure that the receiver has
correctly received the current packet. Because of this behavior, protocols such
as rdt2.0 are known as <code>stop-and-wait</code> protocols.
</p>


<p>
The receiver-side FSM for rdt2.0 still has a single state. On packet arrival,
the receiver replies with either an ACK or a NAK, depending on whether or not
the received packet is corrupted.
</p>

<p>
we haven’t accounted for the possibility that the ACK or NAK packet could be
corrupted. Minimally, we will need to add checksum bits to ACK/NAK packets in
order to detect such errors. The more difficult question is how the protocol
should recover from errors in ACK or NAK packets. The difficulty here is that if
an ACK or NAK is corrupted, the sender has no way of knowing whether or not the
receiver has correctly received the last piece of transmitted data.
</p>

<p>
Consider three possibilities for handling corrupted ACKs or NAKs:
</p>
<ul class="org-ul">
<li>For the first possibility, consider what a human might do in the
message-dictation scenario. If the speaker didn’t understand the “OK” or
“Please repeat that” reply from the receiver, the speaker would probably ask,
“What did you say?” (thus introducing a new type of sender-to-receiver packet
to our protocol). The receiver would then repeat the reply. But what if the
speaker’s “What did you say?” is corrupted? The receiver, having no idea
whether the garbled sentence was part of the dictation or a request to repeat
the last reply, would probably then respond with “What did you say?” And then,
of course, that response might be garbled. Clearly, we’re heading down a
difficult path.</li>
<li>A second alternative is to add enough checksum bits to allow the sender not
only to detect, but also to recover from, bit errors. This solves the
immediate problem for a channel that can corrupt packets but not lose them.</li>
<li>A third approach is for the sender simply to resend the current data packet
when it receives a garbled ACK or NAK packet. This approach, however,
introduces duplicate packets into the sender-to-receiver channel. The
fundamental difficulty with duplicate packets is that the receiver doesn’t
know whether the ACK or NAK it last sent was received correctly at the sender.
Thus, it cannot know a priori whether an arriving packet contains new data or
is a retransmission!</li>
</ul>

<p>
A simple solution is to add a new field to the data packet and have the sender
number its data packets by putting a <code>sequence number</code> into this field. The
receiver then need only check this sequence number to determine whether or not
the received packet is a retransmission. For this simple case of a stop-and-wait
protocol, a 1-bit sequence number will suffice, since it will allow the receiver
to know whether the sender is resending the previously transmitted packet (the
sequence number of the received packet has the same sequence number as the most
recently received packet) or a new packet.Since we are currently assuming a
channel that does not lose packets, ACK and NAK packets do not themselves need
to indicate the sequence number of the packet they are acknowledging. The sender
knows that a received ACK or NAK packet (whether garbled or not) was generated
in response to its most recently transmitted data packet.
</p>

<p>
imagen 3.11
imagen 3.12
</p>

<p>
The rdt2.1 sender and receiver FSMs each now have twice as many states as
before. This is because the protocol state must now reflect whether the packet
currently being sent (by the sender) or expected (at the receiver) should have a
sequence number of 0 or 1. Note that the actions in those states where a 0-
numbered packet is being sent or expected are mirror images of those where a
1-numbered packet is being sent or expected; the only differences have to do
with the handling of the sequence number.
</p>

<p>
Protocol rdt2.1 uses both positive and negative acknowledgments from the
receiver to the sender. When an out-of-order packet is received, the receiver
sends a positive acknowledgment for the packet it has received. When a corrupted
packet is received, the receiver sends a negative acknowledgment. We can
accomplish the same effect as a NAK if, instead of sending a NAK, we send an ACK
for the last correctly received packet.
</p>

<p>
A sender that receives two ACKs for the same packet (that is, receives duplicate
ACKs) knows that the receiver did not correctly receive the packet following the
packet that is being ACKed twice.
</p>

<p>
One subtle change between rtdt2.1 and rdt2.2 is that the receiver must now
include the sequence number of the packet being acknowledged by an ACK message
(this is done by including the ACK , 0 or ACK , 1 argument in <code>make_pkt()</code> in the
receiver FSM), and the sender must now check the sequence number of the packet
being acknowledged by a received ACK message (this is done by including the 0 or 1 argument in <code>isACK()</code> in the sender FSM).
</p>
</div>
</div>
</div>

<div id="outline-container-org779f226" class="outline-4">
<h4 id="org779f226">Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0</h4>
<div class="outline-text-4" id="text-org779f226">
<p>
Suppose now that in addition to corrupting bits, the underlying channel can lose
packets as well.
</p>

<ul class="org-ul">
<li>how to detect packet loss and</li>
<li>what to do when packet loss occurs.</li>
</ul>

<p>
The use of checksumming, sequence numbers, ACK packets, and retransmissions—the
techniques already developed in rdt2.2 —will allow us to answer the latter
concern.
</p>

<p>
Suppose that the sender transmits a data packet and either that packet, or the
receiver’s ACK of that packet, gets lost. In either case, no reply is
forthcoming at the sender from the receiver. If the sender is willing to wait
long enough so that it is certain that a packet has been lost, it can simply
retransmit the data packet.
</p>

<p>
But how long must the sender wait to be certain that something has been lost?
The sender must clearly wait at least as long as a round-trip delay between the
sender and receiver (which may include buffering at intermediate routers) plus
whatever amount of time is needed to process a packet at the receiver. In many
networks, this worst-case maximum delay is very difficult even to estimate, much
less know with certainty. Moreover, the protocol should ideally recover from
packet loss as soon as possible; waiting for a worst-case delay could mean a
long wait until error recovery is initiated.
</p>


<p>
If an ACK is not received within this time, the packet is retransmitted. Note
that if a packet experiences a particularly large delay, the sender may
retransmit the packet even though neither the data packet nor its ACK have been
lost. This introduces the possibility of <code>duplicate data packets</code> in the
sender-to-receiver channel. Happily, protocol rdt2.2 already has enough
functionality (that is, sequence numbers) to handle the case of duplicate
packets.
</p>

<p>
imagen 3.14
</p>

<p>
The sender does not know whether a data packet was lost, an ACK was lost, or if
the packet or ACK was simply overly delayed. In all cases, the action is the
same: retransmit. Implementing a time-based retransmission mechanism requires a
countdown timer that can interrupt the sender after a given amount of time has
expired. The sender will thus need to be able to (1) start the timer each time a
packet (either a first-time packet or a retransmission) is sent, (2) respond to
a timer interrupt (taking appropriate actions), and (3) stop the timer.
</p>

<p>
imagen 3.15
</p>

<p>
note that a receive time for a packet is necessarily later than the send time
for a packet as a result of transmission and propagation delays.
</p>

<p>
the send-side brackets indicate the times at which a timer is set and later
times out. Several of the more subtle aspects of this protocol are explored in
the exercises at the end of this chapter.
</p>

<p>
imagen 3.16
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
Last update: 2020-08-18 14:23
</div>
</body>
</html>
