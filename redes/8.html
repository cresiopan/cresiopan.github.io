<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-09-16 Wed 13:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Data Plane - Arquitectura de routers, IP y framentación</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
<link rel="stylesheet" type="text/css" href="../res/org.css"/>

<script type="text/javascript" src="https://code.orgmode.org/bzg/worg/raw/master/code/org-info-js/org-info.js">
/**
 *
 * @source: https://code.orgmode.org/bzg/worg/raw/master/code/org-info-js/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in https://code.orgmode.org/bzg/worg/raw/master/code/org-info-js/org-info.js.
 *
 * Copyright (C) 2012-2020 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in https://code.orgmode.org/bzg/worg/raw/master/code/org-info-js/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "6");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "1");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5b548a4">1. Overview of the Network Layer</a>
<ul>
<li><a href="#orgf0b353d">1.1. Forwarding and Routing: The Data and Control Planes</a>
<ul>
<li><a href="#org395b00f">1.1.1. Forwarding</a></li>
<li><a href="#org60c37ec">1.1.2. Routing</a></li>
<li><a href="#org21a8125">1.1.3. Control Plane: The Traditional Approach</a></li>
<li><a href="#org5ecbc6a">1.1.4. Control Plane: The SDN Approach</a></li>
</ul>
</li>
<li><a href="#orgdadddc7">1.2. Network Service Model</a></li>
</ul>
</li>
<li><a href="#org88a5640">2. Qué hay adentro de un router?</a>
<ul>
<li><a href="#org5ec66ea">2.1. Input Port Processing and Destination-Based Forwarding</a></li>
<li><a href="#org68f8e36">2.2. Switching</a></li>
<li><a href="#org32c3f65">2.3. Output Port Processing</a></li>
<li><a href="#orgd9bebed">2.4. Where Does Queuing Occur?</a>
<ul>
<li><a href="#org4588585">2.4.1. input queueing</a></li>
<li><a href="#org85db012">2.4.2. output queueing</a></li>
</ul>
</li>
<li><a href="#org18a60c3">2.5. Packet Scheduling</a>
<ul>
<li><a href="#orgda89301">2.5.1. FIFO</a></li>
<li><a href="#org06e5ae3">2.5.2. Priority Queuing</a></li>
<li><a href="#orgd4a1bb2">2.5.3. Round Robin and Weighted Fair Queuing (WFQ)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgae9fcaf">3. IP</a>
<ul>
<li><a href="#orgff39ad1">3.1. IPv4 [RFC 791]</a>
<ul>
<li><a href="#org1619da7">3.1.1. Datagram format</a></li>
<li><a href="#orgff9d0d5">3.1.2. Datagram Fragmentation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
the network layer can be decomposed into two interacting parts, the <code>data plane</code>
and the <code>control plane</code>.
</p>

<p>
the data plane functions of the network layer—the per-router functions in the
network layer that determine how a datagram (that is, a network-layer packet)
arriving on one of a router’s input links is forwarded to one of that router’s
output links.
</p>

<p>
the control plane functions of the network layer—the network-wide logic that
controls how a datagram is routed among routers along an end-to-end path from
the source host to the destination host.
</p>

<p>
Traditionally, these control-plane routing protocols and data-plane forwarding
functions have been implemented together, monolithically, within a router.
</p>

<p>
As we will see later, Software-defined networking (SDN) explicitly separates the
data plane and control plane by implementing these control plane functions as a
separate service, typically in a remote “controller”.
</p>

<p>
This distinction between data-plane and control-plane functions in the network
layer is an important concept to keep in mind as you learn about the network
layer —it will help structure your thinking about the network layer and reflects
a modern view of the network layer’s role in computer networking.
</p>

<div id="outline-container-org5b548a4" class="outline-2">
<h2 id="org5b548a4"><span class="section-number-2">1</span> Overview of the Network Layer</h2>
<div class="outline-text-2" id="text-1">
<p>
Figure 4.1 shows a simple network with two hosts, H1 and H2, and several routers
on the path between H1 and H2. Let’s suppose that H1 is sending information to
H2, and consider the role of the network layer in these hosts and in the
intervening routers. The network layer in H1 takes segments from the transport
layer in H1, encapsulates each segment into a datagram, and then sends the
datagrams to its nearby router, R1. At the receiving host, H2, the network layer
receives the datagrams from its nearby router R2, extracts the transport-layer
segments, and delivers the segments up to the transport layer at H2.
</p>

<p>
The primary data-plane role of each router is to forward datagrams from its
input links to its output links; the primary role of the control plane is to
coordinate these local, per-router forwarding actions so that datagrams are
ultimately transferred end-to-end, along paths of routers between source and
destination hosts.
</p>

<p>
Note that the routers in Figure 4.1 are shown with a truncated protocol stack,
that is, with no upper layers above the network layer, because routers do not
run application- and transport-layer protocols
</p>

<p>
imagen 4.1
</p>
</div>

<div id="outline-container-orgf0b353d" class="outline-3">
<h3 id="orgf0b353d"><span class="section-number-3">1.1</span> Forwarding and Routing: The Data and Control Planes</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The primary role of the network layer is deceptively simple—to move packets from
a sending host to a receiving host.
</p>
</div>

<div id="outline-container-org395b00f" class="outline-4">
<h4 id="org395b00f"><span class="section-number-4">1.1.1</span> Forwarding</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
When a packet arrives at a router’s input link, the router must move the packet
to the appropriate output link. For example, a packet arriving from Host H1 to
Router R1 in Figure 4.1 must be forwarded to the next router on a path to H2. As
we will see, forwarding is but one function implemented in the data plane. In
the more general case, a packet might also be blocked from exiting a router
(e.g., if the packet originated at a known malicious sending host, or if the
packet were destined to a forbidden destination host), or might be duplicated
and sent over multiple outgoing links.
</p>

<p>
Forwarding refers to the router-local action of transferring a packet from an
input link interface to the appropriate output link interface. Forwarding takes
place at very short timescales (typically a few nanoseconds), and thus is
typically implemented in hardware.
</p>

<p>
A key element in every network router is its <code>forwarding table</code>. A router
forwards a packet by examining the value of one or more fields in the arriving
packet’s header, and then using these header values to index into its forwarding
table. The value stored in the forwarding table entry for those values indicates
the outgoing link interface at that router to which that packet is to be
forwarded.
</p>
</div>
</div>

<div id="outline-container-org60c37ec" class="outline-4">
<h4 id="org60c37ec"><span class="section-number-4">1.1.2</span> Routing</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
The network layer must determine the route or path taken by packets as they flow
from a sender to a receiver. The algorithms that calculate these paths are
referred to as routing algorithms. A routing algorithm would determine, for
example, the path along which packets flow from H1 to H2 in Figure 4.1. Routing
is implemented in the control plane of the network layer.
</p>

<p>
Routing refers to the network-wide process that determines the end-to-end paths
that packets take from source to destination. Routing takes place on much longer
timescales (typically seconds), and as we will see is often implemented in
software.
</p>

<p>
imagen 4.2
</p>
</div>
</div>

<div id="outline-container-org21a8125" class="outline-4">
<h4 id="org21a8125"><span class="section-number-4">1.1.3</span> Control Plane: The Traditional Approach</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
how a router’s forwarding tables are configured in the first place?
</p>

<p>
the routing algorithm determines the contents of the routers’ forwarding tables.
</p>

<p>
a routing algorithm runs in each and every router, and both forwarding and
routing functions are contained within a router.
</p>

<p>
the routing algorithm function in one router communicates with the routing
algorithm function in other routers to compute the values for its forwarding
table. How is this communication performed? By exchanging routing messages
containing routing information according to a routing protocol.
</p>
</div>
</div>

<div id="outline-container-org5ecbc6a" class="outline-4">
<h4 id="org5ecbc6a"><span class="section-number-4">1.1.4</span> Control Plane: The SDN Approach</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
Figure 4.3 shows an alternate approach in which a physically separate (from the
routers), remote controller computes and distributes the forwarding tables to be
used by each and every router.
</p>

<p>
imagen 4.3
</p>

<p>
control-plane routing functionality is separated from the physical router. the
routing device performs forwarding only, while the remote controller computes
and distributes forwarding tables. The remote controller might be implemented in
a remote data center with high reliability and redundancy, and might be managed
by the ISP or some third party. How might the routers and the remote controller
communicate? By exchanging messages containing forwarding tables and other
pieces of routing information.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdadddc7" class="outline-3">
<h3 id="orgdadddc7"><span class="section-number-3">1.2</span> Network Service Model</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The <code>network service model</code> defines the characteristics of end-to-end delivery
of packets between sending and receiving hosts.
</p>

<p>
Let’s now consider some possible services that the network layer could provide.
</p>

<dl class="org-dl">
<dt>Guaranteed delivery</dt><dd>This service guarantees that a packet sent by a source
host will eventually arrive at the destination host.</dd>
<dt>Guaranteed delivery with bounded delay</dt><dd>This service not only guarantees
delivery of the packet, but delivery within a specified host-to-host delay
bound (for example, within 100 msec).</dd>
<dt>In-order packet delivery</dt><dd>This service guarantees that packets arrive at the
destination in the order that they were sent.</dd>
<dt>Guaranteed minimal bandwidth</dt><dd>This network-layer service emulates the
behavior of a transmission link of a specified bit rate (for example, 1 Mbps)
between sending and receiving hosts. As long as the sending host transmits
bits (as part of packets) at a rate below the specified bit rate, then all
packets are eventually delivered to the destination host.</dd>
<dt>Security</dt><dd>The network layer could encrypt all datagrams at the source and
decrypt them at the destination, thereby providing confidentiality to all
transport-layer segments.</dd>
</dl>

<p>
The Internet’s network layer provides a single service, known as <code>best-effort
service</code>. With best-effort service, packets are neither guaranteed to be
received in the order in which they were sent, nor is their eventual delivery
even guaranteed. There is no guarantee on the end-to-end delay nor is there a
minimal bandwidth guarantee.
</p>
</div>
</div>
</div>

<div id="outline-container-org88a5640" class="outline-2">
<h2 id="org88a5640"><span class="section-number-2">2</span> Qué hay adentro de un router?</h2>
<div class="outline-text-2" id="text-2">
<p>
imagen 4.4
</p>

<p>
A high-level view of a generic router architecture is shown in Figure 4.4. Four router components can be identified:
</p>

<dl class="org-dl">
<dt>Input ports</dt><dd>An input port performs several key functions. It performs the
physical layer function of terminating an incoming physical link at a router;
this is shown in the leftmost box of an input port and the rightmost box of an
output port in Figure 4.4. An input port also performs link-layer functions
needed to interoperate with the link layer at the other side of the incoming
link; this is represented by the middle boxes in the input and output ports.
Perhaps most crucially, a lookup function is also performed at the input port;
this will occur in the rightmost box of the input port. It is here that the
forwarding table is consulted to determine the router output port to which an
arriving packet will be forwarded via the switching fabric. Control packets
(for example, packets carrying routing protocol information) are forwarded
from an input port to the routing processor.</dd>
<dt>Switching fabric</dt><dd>The switching fabric connects the router’s input ports to
its output ports. This switching fabric is completely contained within the
router—a network inside of a network router!</dd>
<dt>Output ports</dt><dd>An output port stores packets received from the switching
fabric and transmits these packets on the outgoing link by performing the
necessary link-layer and physical-layer functions. When a link is
bidirectional (that is, carries traffic in both directions), an output port
will typically be paired with the input port for that link on the same line
card.</dd>
<dt>Routing processor</dt><dd>The routing processor performs control-plane functions.
In traditional routers, it executes the routing protocols, maintains routing
tables and attached link state information, and computes the forwarding table
for the router. In SDN routers, the routing processor is responsible for
communicating with the remote controller in order to (among other activities)
receive forwarding table entries computed by the remote controller, and
install these entries in the router’s input ports. The routing processor also
performs the network management functions.</dd>
</dl>

<p>
A router’s input ports, output ports, and switching fabric are almost always
implemented in hardware because its faster than a software implementation.
</p>
</div>

<div id="outline-container-org5ec66ea" class="outline-3">
<h3 id="org5ec66ea"><span class="section-number-3">2.1</span> Input Port Processing and Destination-Based Forwarding</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A more detailed view of input processing is shown in Figure 4.5.
</p>

<p>
imagen 4.5
</p>

<p>
The lookup performed in the input port is central to the router’s operation—it
is here that the router uses the forwarding table to look up the output port to
which an arriving packet will be forwarded via the switching fabric.
</p>

<p>
The forwarding table is copied from the routing processor to the line cards over
a separate bus. With such a shadow copy at each line card, forwarding decisions
can be made locally, at each input port, without invoking the centralized
routing processor on a per-packet basis and thus avoiding a centralized
processing bottleneck.
</p>

<p>
Consider the case that the output port to which an incoming packet is to be
switched is based on the packet’s destination address. As an example of how this
issue of scale can be handled, let’s suppose that our router has four links,
numbered 0 through 3, and that packets are to be forwarded to the link
interfaces as follows:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Destination Address Range</th>
<th scope="col" class="org-right">Link Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">11001000 00010111 00010000 00000000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">through</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">11001000 00010111 00010111 11111111</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">11001000 00010111 00011000 00000000</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">through</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">11001000 00010111 00011000 11111111</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">11001000 00010111 00011001 00000000</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">through</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">11001000 00010111 00011111 11111111</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Otherwise</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>

<p>
with just 4 entries
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Prefix</th>
<th scope="col" class="org-right">Link Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">11001000 00010111 00010</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">11001000 00010111 00011000</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">11001000 00010111 00011</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Otherwise</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>

<p>
With this style of forwarding table, the router matches a <code>prefix</code> of the
packet’s destination address with the entries in the table; if there’s a match,
the router forwards the packet to a link associated with the match.
</p>

<p>
When there are multiple matches, the router uses the <code>longest prefix matching
rule</code>; that is, it finds the longest matching entry in the table and forwards
the packet to the link interface associated with the longest prefix match.
</p>

<p>
Once a packet’s output port has been determined via the lookup, the packet can
be sent into the switching fabric. In some designs, a packet may be temporarily
blocked from entering the switching fabric if packets from other input ports are
currently using the fabric. A blocked packet will be queued at the input port
and then scheduled to cross the fabric at a later point in time.
</p>

<p>
other actions must be taken at the input port processing stage:
</p>
<ol class="org-ol">
<li>physical- and link-layer processing must occur, as discussed previously</li>
<li>the packet’s version number, checksum and time-to-live field must be checked
and the latter two fields rewritten</li>
<li>counters used for network management (such as the number of IP datagrams
received) must be updated</li>
</ol>
</div>
</div>

<div id="outline-container-org68f8e36" class="outline-3">
<h3 id="org68f8e36"><span class="section-number-3">2.2</span> Switching</h3>
<div class="outline-text-3" id="text-2-2">
<p>
it is through the switching fabric that the packets are actually switched
(forwarded) from an input port to an output port.
</p>

<dl class="org-dl">
<dt>Switching via memory</dt><dd>The earliest routers were traditional computers, with
switching between input and output ports being done under direct control of
the CPU. Input and output ports functioned as traditional I/O devices in an
operating system. An input port with an arriving packet first signaled the CPU
via an interrupt. The packet was then copied from the input port into memory.
The CPU then extracted the destination address from the header, looked up the
appropriate output port in the forwarding table, and copied the packet to the
output port’s buffers. In this scenario, if the memory bandwidth is such that
a maximum of B packets per second can be written into, or read from, memory,
then the overall forwarding throughput (the total rate at which packets are
transfered from input ports to output ports) must be less than B/2. Note that
two packets cannot be forwarded at the same time, even if they have different
destination ports, since only one memory read/write can be done at a time over
the shared system bus.</dd>
<dt>Switching via a bus</dt><dd>an input port transfers a packet directly to the output
port over a shared bus, without intervention by the CPU. This is typically
done by having the input port pre-pend a switch-internal label (header) to the
packet indicating the local output port to which this packet is being
transferred and transmitting the packet onto the bus. All output ports receive
the packet, but only the port that matches the label will keep the packet. The
label is then removed at the output port. If multiple packets arrive to the
router at the same time, each at a different input port, all but one must wait
since only one packet can cross the bus at a time. the switching speed of the
router is limited to the bus speed. Nonetheless, switching via a bus is often
sufficient for routers that operate in small local area and enterprise
networks.</dd>
<dt>Switching via an interconnection network</dt><dd>One way to overcome the bandwidth
limitation of a single, shared bus is to use a more sophisticated
interconnection network. A crossbar switch is an interconnection network
consisting of 2N buses that connect N input ports to N output ports. Each
vertical bus intersects each horizontal bus at a crosspoint, which can be
opened or closed at any time by the switch fabric controller (whose logic is
part of the switching fabric itself). When a packet arrives from port A and
needs to be forwarded to port Y, the switch controller closes the crosspoint
at the intersection of busses A and Y, and port A then sends the packet onto
its bus, which is picked up (only) by bus Y. Note that a packet from port B
can be forwarded to port X at the same time, since the A-to-Y and B-to-X
packets use different input and output busses. Thus, unlike the previous two
switching approaches, crossbar switches are capable of forwarding multiple
packets in parallel. A crossbar switch is non-blocking—a packet being
forwarded to an output port will not be blocked from reaching that output port
as long as no other packet is currently being forwarded to that output port.
However, if two packets from two different input ports are destined to that
same output port, then one will have to wait at the input,</dd>
</dl>
<p>
since only one packet can be sent over any given bus at a time.
</p>

<p>
imagen 4.6
</p>

<p>
More sophisticated interconnection networks use multiple stages of switching
elements to allow packets from different input ports to proceed towards the same
output port at the same time through the multi-stage switching fabric. A
router’s switching capacity can also be scaled by running multiple switching
fabrics in parallel. In this approach, where input ports and output ports are
connected to N switching fabrics that operate in parallel.
</p>
</div>
</div>

<div id="outline-container-org32c3f65" class="outline-3">
<h3 id="org32c3f65"><span class="section-number-3">2.3</span> Output Port Processing</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Output port processing, takes packets that have been stored in the output port’s
memory and transmits them over the output link. This includes selecting and
de-queueing packets for transmission, and performing the needed link-layer and
physical-layer transmission functions.
</p>

<p>
imagen 4.7
</p>
</div>
</div>

<div id="outline-container-orgd9bebed" class="outline-3">
<h3 id="orgd9bebed"><span class="section-number-3">2.4</span> Where Does Queuing Occur?</h3>
<div class="outline-text-3" id="text-2-4">
<p>
packet queues may form at both the input ports and the output ports. The
location and extent of queueing (either at the input port queues or the output
port queues) will depend on the traffic load, the relative speed of the
switching fabric, and the line speed.
</p>

<p>
since these queues grow large, the router’s memory can eventually be exhausted
and packet loss will occur when no memory is available to store arriving
packets.
</p>
</div>

<div id="outline-container-org4588585" class="outline-4">
<h4 id="org4588585"><span class="section-number-4">2.4.1</span> input queueing</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
If the switching rate is faster than the transmission rate, then queueing will
be negligible.
</p>

<p>
<code>head-of-the-line (HOL) blocking</code> in an input-queued switch—a queued packet in
an input queue must wait for transfer through the fabric (even though its output
port is free) because it is blocked by another packet at the head of the line.
</p>

<p>
imagen 4.8
</p>

<p>
When there is not enough memory to buffer an incoming packet, a decision must be
made to either drop the arriving packet (a policy known as <code>drop-tail</code>) or
remove one or more already-queued packets to make room for the newly arrived
packet. In some cases, it may be advantageous to drop (or mark the header of) a
packet before the buffer is full in order to provide a congestion signal to the
sender. A number of proactive packet dropping-and-marking policies (collectively
known as <code>active queue management (AQM)</code> algorithms) have been proposed and
analyzed.
</p>
</div>
</div>

<div id="outline-container-org85db012" class="outline-4">
<h4 id="org85db012"><span class="section-number-4">2.4.2</span> output queueing</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
packet queues can form at the output ports when the switching fabric is faster
than the port line speeds. Eventually, the number of queued packets can grow
large enough to exhaust available memory at the output port.
</p>

<p>
imagen 4.9
</p>

<p>
how much buffering is required? [RFC 3439] states that the amount of buffering
(B) should be equal to an average round-trip time (RTT) times the link capacity
(C).
</p>

<p>
\[ B = RTT * C\]
</p>
</div>
</div>
</div>

<div id="outline-container-org18a60c3" class="outline-3">
<h3 id="org18a60c3"><span class="section-number-3">2.5</span> Packet Scheduling</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Decide que input port atender.
</p>
</div>

<div id="outline-container-orgda89301" class="outline-4">
<h4 id="orgda89301"><span class="section-number-4">2.5.1</span> FIFO</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
The FIFO scheduling discipline selects packets for link transmission in the same
order in which they arrived at the output link queue.
</p>

<p>
imagen 4.10
</p>

<p>
imagen 4.11
</p>
</div>
</div>

<div id="outline-container-org06e5ae3" class="outline-4">
<h4 id="org06e5ae3"><span class="section-number-4">2.5.2</span> Priority Queuing</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
packets arriving at the output link are classified into priority classes upon
arrival at the queue. In practice, a network operator may configure a queue so
that packets carrying network management information (e.g., as indicated by the
source or destination TCP/UDP port number) receive priority over user traffic.
</p>

<p>
imagen 4.12
</p>

<p>
Each priority class typically has its own queue. When choosing a packet to
transmit, the priority queuing discipline will transmit a packet from the
highest priority class that has a nonempty queue (that is, has packets waiting
for transmission). The choice among packets in the same priority class is
typically done in a FIFO manner.
</p>

<p>
imagen 4.13
</p>
</div>
</div>

<div id="outline-container-orgd4a1bb2" class="outline-4">
<h4 id="orgd4a1bb2"><span class="section-number-4">2.5.3</span> Round Robin and Weighted Fair Queuing (WFQ)</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
In Round Robin discipline, packets are sorted into classes as with priority
queuing. However, rather than there being a strict service priority among
classes, a round robin scheduler alternates service among the classes.
</p>

<p>
A <code>work-conserving queuing</code> discipline will never allow the link to remain idle
whenever there are packets (of any class) queued for transmission. A
work-conserving round robin discipline that looks for a packet of a given class
but finds none will immediately check the next class in the round robin
sequence.
</p>

<p>
imagen 4.14
</p>

<p>
In another RR discpline called <code>weighted fair queuing (WFQ)</code>, arriving packets
are classified and queued in the appropriate per-class waiting area. As in round
robin scheduling, a WFQ scheduler will serve classes in a circular manner— first
serving class 1, then serving class 2, then serving class 3, and then (assuming
there are three classes) repeating the service pattern. WFQ is also a
work-conserving discpline and thus will immediately move on to the next class in
the service sequence when it finds an empty class queue.
</p>

<p>
WFQ differs from round robin in that each class may receive a differential
amount of service in any interval of time. Specifically, each class, i, is
assigned a weight, \(w_{i}\). Under WFQ, during any interval of time during which
there are class i packets to send, class i will then be guaranteed to receive a
fraction of service equal to (\(w_{i}/\sum_{j}w_{j}\)) where the sum in the
denominator is taken over all classes that also have packets queued for
transmission. In the worst case, even if all classes have queued packets, class
i will still be guaranteed to receive a fraction of the bandwidth, where in this
worst case the sum in the denominator is over all classes. For a link with
transmission rate R, class i will always achieve a throughput of at least
\(R*w_{i}/\sum_{j}w_{j}\).
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgae9fcaf" class="outline-2">
<h2 id="orgae9fcaf"><span class="section-number-2">3</span> IP</h2>
<div class="outline-text-2" id="text-3">
<p>
There are two versions of IP in use today.
</p>
</div>

<div id="outline-container-orgff39ad1" class="outline-3">
<h3 id="orgff39ad1"><span class="section-number-3">3.1</span> IPv4 [RFC 791]</h3>
<div class="outline-text-3" id="text-3-1">
<p>
imagen 4.16
</p>
</div>

<div id="outline-container-org1619da7" class="outline-4">
<h4 id="org1619da7"><span class="section-number-4">3.1.1</span> Datagram format</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
campos clave del datagrama IPv4:
</p>

<dl class="org-dl">
<dt>Version number</dt><dd>4 bits that specify protocol version of the datagram. the router can use it to determine how to interpret the remainder of the IP datagram.</dd>
<dt>Header length</dt><dd>an IPv4 datagram can contain a variable number of options. 4 bits  determine where in the IP datagram the payload actually begins. Most IP datagrams do not contain options, so the typical IP datagram has a 20-byte header.</dd>
<dt>Type of service</dt><dd>The <code>TOS</code> bits were included in the IPv4 header to allow different types of IP datagrams to be distinguished from each other. For example, real-time datagrams, non-real-time traffic. The TOS is determined and configured by the network administrator for that router.</dd>
<dt>Datagram length</dt><dd>total length of the IP datagram (header plus data) in bytes. its 16 bits long, so the theoretical maximum size of the datagram is 65,535 bytes. However, datagrams are rarely larger than 1,500 bytes.</dd>
<dt>Identifier, flags, fragmentation offset</dt><dd>These three fields have to do with so-called IP fragmentation.</dd>
<dt>Time-to-live</dt><dd>The <code>TTL</code> field is included to ensure that datagrams do not circulate forever in the network. This field is decremented by one each time the datagram is processed by a router. If the TTL field reaches 0, a router must drop that datagram.</dd>
<dt>Protocol</dt><dd>typically used only when the datagram reaches its final destination. The value of this field indicates the specific transport-layer protocol to which the data portion of this IP datagram should be passed. see [IANA Protocol Numbers 2016]. The protocol number is the glue that binds the network and transport layers, like the port number is the glue that binds the transport and application layers.</dd>
<dt>Header checksum</dt><dd>aids a router in detecting bit errors in a received IP datagram. if the checksum in the  header does not equal the computed checksum, routers typically discard the datagram. the checksum must be recomputed and stored again at each router, since the TTL field, and possibly the options field as well, will change.</dd>
<dt>Source and destination IP addresses</dt><dd>When a source creates a datagram, it inserts its IP address into the source IP address field and inserts the address of the ultimate destination into the destination IP address field.</dd>
<dt>Options</dt><dd>allows an IP header to be extended.</dd>
<dt>Data (payload)</dt><dd>the data field of the IP datagram contains the transport-layer segment (TCP or UDP) to be delivered to the destination. the data field can carry other types of data, such as ICMP messages.</dd>
</dl>

<p>
an IP datagram has a total of 20 bytes of header (assuming no options).
</p>

<p>
If it carries a TCP segment, then each datagram carries a total of 40 bytes of header (20 of the IP header and 20 of the TCP header) along with the application-layer message.
</p>
</div>
</div>

<div id="outline-container-orgff9d0d5" class="outline-4">
<h4 id="orgff9d0d5"><span class="section-number-4">3.1.2</span> Datagram Fragmentation</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The maximum amount of data that a link-layer frame can carry is called the <code>maximum transmission unit (MTU)</code>. Because each IP datagram is encapsulated within the link-layer frame for transport from one router to the next router, the MTU of the link-layer protocol places a hard limit on the length of an IP datagram. Having a hard limit on the size of an IP datagram is not much of a problem. What is a problem is that each of the links along the route between sender and destination can use different link-layer protocols, and each of these protocols can have different MTUs.
</p>

<p>
To understand the forwarding issue better, imagine that you are a router that interconnects several links, each running different link-layer protocols with different MTUs. Suppose you receive an IP datagram from one link. You check your forwarding table to determine the outgoing link, and this outgoing link has an MTU that is smaller than the length of the IP datagram. Time to panic—how are you going to squeeze this oversized IP datagram into the payload field of the link-layer frame?
</p>

<p>
The solution is to fragment the payload in the IP datagram into two or more smaller IP datagrams, encapsulate each of these smaller IP datagrams in a separate link-layer frame; and send these frames over the outgoing link. Each of these smaller datagrams is referred to as a <code>fragment</code>.
</p>

<p>
Fragments need to be reassembled before they reach the transport layer at the destination. Indeed, both TCP and UDP are expecting to receive complete, unfragmented segments from the network layer. The job of datagram reassembly is in the end systems rather than in network routers.
</p>

<p>
To allow the destination host to perform these reassembly tasks, the designers of IP (version 4) put identification, flag, and fragmentation offset fields in the IP datagram header. When a datagram is created, the sending host stamps the datagram with an identification number as well as source and destination addresses.
</p>

<p>
Typically, the sending host increments the identification number for each datagram it sends. When a router needs to fragment a datagram, each resulting datagram (that is, fragment) is stamped with the source address, destination address, and identification number of the original datagram. When the destination receives a series of datagrams from the same sending host, it can examine the identification numbers of the datagrams to determine which of the datagrams are actually fragments of the same larger datagram.
</p>

<p>
for the destination host to be absolutely sure it has received the last fragment of the original datagram, the last fragment has a flag bit set to 0, whereas all the other fragments have this flag bit set to 1. Also, in order for the destination host to determine whether a fragment is missing (and also to be able to reassemble the fragments in their proper order), the offset field is used to specify where the fragment fits within the original IP datagram.
</p>

<p>
imagen 4.17
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
Last update: 2020-09-16 13:05
</div>
</body>
</html>
