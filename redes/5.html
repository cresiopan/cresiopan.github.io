<?xml version="1.0" encoding="utf-8"?>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-06-18 Thu 16:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ventana deslizante y TCP</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
<link rel="stylesheet" type="text/css" href="/home/mk/Documents/blogs/org.css"/>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">

<div id="outline-container-org66ee406" class="outline-2">
<h2 id="org66ee406">Pipelined reliable Data Transfer Protocols</h2>
<div class="outline-text-2" id="text-org66ee406">
<p>
Protocol rdt3.0 is a functionally correct protocol, but its performance problem
is the fact that it is a stop-and-wait protocol.
</p>

<p>
imagen 3.16
</p>

<p>
This stop-and-wait protocol limits the sender <code>utilization</code> of the channel (the
amount of time the sender actually sends bits into the channel).
</p>

<p>
image 3.17
</p>


<p>
The solution to this particular performance problem is simple: Rather than operate in a stop-and-wait
manner, the sender is allowed to send multiple packets without waiting for acknowledgments.
</p>

<p>
illustrated in Figure 3.17(b). Figure 3.18(b) shows that if the sender is allowed to transmit three packets
before having to wait for acknowledgments, the utilization of the sender is essentially tripled.
</p>

<p>
this technique is known as <code>pipelining</code>. Pipelining has the following consequences
for reliable data transfer protocols:
</p>

<ul class="org-ul">
<li>The range of sequence numbers must be increased, since each in-transit packet
(not counting retransmissions) must have a unique sequence number and there
may be multiple, in-transit, unacknowledged packets.</li>
<li>The sender and receiver sides of the protocols may have to buffer more than
one packet. Minimally, the sender will have to buffer packets that have been
transmitted but not yet acknowledged. Buffering of correctly received packets
may also be needed at the receiver, as discussed below.</li>
<li>The range of sequence numbers needed and the buffering requirements will
depend on the manner in which a data transfer protocol responds to lost,
corrupted, and overly delayed packets. Two basic approaches toward pipelined
error recovery can be identified: <code>Go-Back-N</code> and <code>selective repeat</code>.</li>
</ul>

<p>
imagen 3.18
</p>
</div>

<div id="outline-container-org357ea8c" class="outline-3">
<h3 id="org357ea8c">Go-Back-N (GBN)</h3>
<div class="outline-text-3" id="text-org357ea8c">
<p>
In a Go-Back-N (GBN) protocol, the sender is allowed to transmit multiple packets (when available)
without waiting for an acknowledgment, but is constrained to have no more than some maximum
allowable number, N, of unacknowledged packets in the pipeline.
</p>

<p>
imagen 3.19
</p>

<p>
Figure 3.19 shows the sender’s view of the range of sequence numbers in a GBN
protocol. If we define <code>base</code> to be the sequence number of the oldest
unacknowledged packet and <code>nextseqnum</code> to be the smallest unused sequence number
(that is, the sequence number of the next packet to be sent), then four
intervals in the range of sequence numbers can be identified.
</p>

<p>
Sequence numbers in the interval
</p>
<ul class="org-ul">
<li><code>[ 0, base-1 ]</code> correspond to packets that have already been transmitted and
acknowledged.</li>
<li><code>[base, nextseqnum-1]</code> corresponds to packets that have been sent but not yet
acknowledged. Sequence numbers in the interval</li>
<li><code>[nextseqnum, base+N-1]</code> can be used for packets that can be sent immediately,
should data arrive from the upper layer.</li>
<li><code>[base+N, ...]</code> cannot be used until an unacknowledged packet currently in the
pipeline (specifically, the packet with sequence number <code>base</code> ) has been
acknowledged.</li>
</ul>

<p>
the range of permissible sequence numbers for transmitted but not yet
acknowledged packets can be viewed as a window of size <code>N</code> over the range of
sequence numbers.
</p>

<p>
As the protocol operates, this window slides forward over the sequence number
space. For this reason, <code>N</code> is often referred to as the <code>window size</code> and the
GBN protocol itself as a <code>sliding-window protocol</code>.
</p>



<p>
You might be wondering <b>why we would even limit the number of outstanding,
unacknowledged packets to a value of N?*</b>. <b>Why not allow an
unlimited number of such packets?</b>
</p>

<p>
flow control is one reason to impose a limit on the sender. We’ll examine
another reason to do so when we study TCP congestion control.
</p>


<p>
In practice, a packet’s sequence number is carried in a fixed-length field in the packet header. If k is the
number of bits in the packet sequence number field, the range of sequence numbers is thus
</p>

<p>
Figures 3.20 and 3.21 give an extended FSM description of the sender and receiver sides of an ACK-based, NAK-free, GBN protocol.
</p>

<p>
imagen 3.20
</p>

<p>
imagen 3.21
</p>

<p>
we have added variables (similar to programming-language variables) for base and
nextseqnum , and added operations on these variables and conditional actions
involving these variables.
</p>

<p>
The GBN sender must respond to three types of events:
</p>
<dl class="org-dl">
<dt>Invocation from above</dt><dd><p>
When rdt<sub>send</sub>() is called from above, the sender
first checks to see if the window is full, that is, whether there are N
outstanding, unacknowledged packets.
</p>
<ul class="org-ul">
<li>If the window is not full, a packet is created and sent, and variables are
appropriately updated.</li>
<li>If the window is full, the sender simply returns the data back to the upper
layer, an implicit indication that the window is full.</li>
</ul>
<p>
The upper layer would presumably then have to try again later. In a real
implementation, the sender would more likely have either buffered (but not
immediately sent) this data, or would have a synchronization mechanism (for
example, a semaphore or a flag) that would allow the upper layer to call
rdt<sub>send</sub>() only when the window is not full.
</p></dd>
<dt>Receipt of an ACK</dt><dd>In our GBN protocol, an acknowledgment for a packet with
sequence number n will be taken to be a <code>cumulative acknowledgment</code>,
indicating that all packets with a sequence number up to and including n have
been correctly received at the receiver.</dd>
<dt>A timeout event</dt><dd>The protocol’s name, “Go-Back-N,” is derived from the
sender’s behavior in the presence of lost or overly delayed packets. As in the
stop-and-wait protocol, a timer will again be used to recover from lost data
or acknowledgment packets. If a timeout occurs, the sender resends all packets
that have been previously sent but that have not yet been acknowledged. Our
sender in Figure 3.20 uses only a single timer, which can be thought of as a
timer for the oldest transmitted but not yet acknowledged packet. If an ACK is
received but there are still additional transmitted but not yet acknowledged
packets, the timer is restarted. If there are no outstanding, unacknowledged
packets, the timer is stopped.</dd>
</dl>


<p>
The receiver’s actions in GBN are :
</p>
<ul class="org-ul">
<li>If a packet with sequence number n is received correctly and is in order (that
is, the data last delivered to the upper layer came from a packet with
sequence number ), the receiver sends an ACK for packet n and delivers the
data portion of the packet to the upper layer.</li>
<li>In all other cases, the receiver discards the packet and resends an ACK for
the most recently received in-order packet. Note that since packets are
delivered one at a time to the upper layer, if packet k has been received and
delivered, then all packets with a sequence number lower than k have also been
delivered. Thus, the use of <code>cumulative acknowledgments</code> is a natural choice for GBN.</li>
</ul>


<p>
<b>In our GBN protocol, the receiver discards out-of-order packets.</b>
</p>

<p>
Recall that the receiver must deliver data in order to the upper layer. Suppose
now that packet n is expected, but packet n+1 arrives. Because data must be
delivered in order, the receiver could buffer packet n+1 and then deliver
this packet to the upper layer after it had later received and delivered packet
n. However, if packet n is lost, both it and packet n+1 will eventually be
retransmitted as a result of the GBN retransmission rule at the sender.
</p>

<p>
Thus, the receiver can simply discard packet.
</p>

<p>
The advantage is the simplicity of receiver buffering—the receiver need not
buffer any out-of-order packets. Thus, while the sender must maintain the upper
and lower bounds of its window and the position of <code>nextseqnum</code> within this
window, the only piece of information the receiver need maintain is the sequence
number of the next in-order packet held in the variable <code>expectedseqnum</code>.
</p>

<p>
the disadvantage of throwing away a correctly received packet is that the
subsequent retransmission of that packet might be lost or garbled and thus even
more retransmissions would be required.
</p>

<p>
imagen 3.22
</p>

<p>
Figure 3.22 shows the operation of the GBN protocol for the case of a window
size of four packets. Because of this window size limitation, the sender sends
packets 0 through 3 but then must wait for one or more of these packets to be
acknowledged before proceeding. As each successive ACK (for example, ACK0 and
ACK1 ) is received, the window slides forward and the sender can transmit one
new packet (pkt4 and pkt5, respectively). On the receiver side, packet 2 is lost
and thus packets 3, 4, and 5 are found to be out of order and are discarded.
</p>
</div>
</div>

<div id="outline-container-org12c12ee" class="outline-3">
<h3 id="org12c12ee">Selective Repeat (SR)</h3>
<div class="outline-text-3" id="text-org12c12ee">
<p>
There are scenarios in which GBN itself suffers from performance problems. In
particular, when the window size and bandwidth-delay product are both large,
many packets can be in the pipeline. A single packet error can thus cause GBN to
retransmit a large number of packets.
</p>

<p>
As the name suggests, selective-repeat protocols avoid unnecessary
retransmissions by having the sender retransmit only those packets that it
suspects were received in error (that is, were lost or corrupted) at the
receiver. This individual, as-needed, retransmission will require that the
receiver individually acknowledge correctly received packets.
</p>

<p>
A window size of N will again be used to limit the number of outstanding,
unacknowledged packets in the pipeline. However, unlike GBN, the sender will
have already received ACKs for some of the packets in the window.
</p>

<p>
The SR receiver will acknowledge a correctly received packet whether or not it
is in order. Out-of-order packets are buffered until any missing packets (that
is, packets with lower sequence numbers) are received, at which point a batch of
packets can be delivered in order to the upper layer.
</p>

<p>
imagen 3.23
</p>

<p>
imagen 3.24
</p>

<p>
imagen 3.25
</p>

<p>
It is important to note that in Step 2 in Figure 3.25, the receiver reacknowledges (rather than ignores)
already received packets with certain sequence numbers below the current window base.
</p>

<p>
imagen 3.26
</p>

<p>
Given the sender and receiver sequence number spaces in Figure 3.23, for
example, if there is no ACK for packet send<sub>base</sub> propagating from the receiver
to the sender, the sender will eventually retransmit packet send<sub>base</sub> , even
though it is clear (to us, not the sender!) that the receiver has already
received that packet. If the receiver were not to acknowledge this packet, the
sender’s window would never move forward! This example illustrates an important
aspect of SR protocols (and many other protocols as well). The sender and
receiver will not always have an identical view of what has been received
correctly and what has not. For SR protocols, this means that the sender and
receiver windows will not always coincide.
</p>


<p>
The lack of synchronization between sender and receiver windows has important
consequences when we are faced with the reality of a finite range of sequence
numbers.
</p>

<pre class="example">
Consider what could happen, for example, with a finite range of four packet
sequence numbers, 0, 1, 2, 3, and a window size of three.

Suppose packets 0 through 2 are transmitted and correctly received and
acknowledged at the receiver. At this point, the receiver’s window is over the
fourth, fifth, and sixth packets, which have sequence numbers 3, 0, and 1,
respectively. Now consider two scenarios.

In the first scenario, shown in Figure 3.27(a), the ACKs for the first three
packets are lost and the sender retransmits these packets. The receiver thus
next receives a packet with sequence number 0—a copy of the first packet sent.

In the second scenario, shown in Figure 3.27(b), the ACKs for the first three
packets are all delivered correctly. The sender thus moves its window forward
and sends the fourth, fifth, and sixth packets, with sequence numbers 3, 0, and
1, respectively. The packet with sequence number 3 is lost, but the packet with
sequence number 0 arrives—a packet containing new data.

Now consider the receiver’s viewpoint in Figure 3.27, which has a figurative
curtain between the sender and the receiver, since the receiver cannot “see” the
actions taken by the sender. All the receiver observes is the sequence of
messages it receives from the channel and sends into the channel. As far as it
is concerned, the two scenarios in Figure 3.27 are identical. There is no way of
distinguishing the retransmission of the first packet from an original
transmission of the fifth packet. Clearly, a window size that is 1 less than the
size of the sequence number space won’t work. But how small must the window size
be? A problem at the end of the chapter asks you to show that the window size
must be less than or equal to half the size of the sequence number space for SR
protocols.
</pre>

<p>
imagen 3.27
</p>

<p>
Table 3.1 Summary of reliable data transfer mechanisms and their use
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Mechanism</td>
<td class="org-left">Use, Comments</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Checksum</td>
<td class="org-left">Used to detect bit errors in a transmitted packet.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Timer</td>
<td class="org-left">Used to timeout/retransmit a packet, possibly because the packet (or its ACK) was lost within the channel. Because timeouts can occur when a packet is delayed but not lost (premature timeout), or when a packet has been received by the receiver but the receiver-to-sender ACK has been lost, duplicate copies of a packet may be received by a receiver</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Sequence number</td>
<td class="org-left">Used for sequential numbering of packets of data flowing from sender to receiver. Gaps in the sequence numbers of received packets allow the receiver to detect a lost packet. Packets with duplicate sequence numbers allow the receiver to detect duplicate copies of a packet.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Acknowledgment</td>
<td class="org-left">Used by the receiver to tell the sender that a packet or set of packets has been received correctly. Acknowledgments will typically carry the sequence number of the packet or packets being acknowledged. Acknowledgments may be individual or cumulative, depending on the protocol.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Negative acknowledgment</td>
<td class="org-left">Used by the receiver to tell the sender that a packet has not been received correctly. Negative acknowledgments will typically carry the sequence number of the packet that was not received correctly.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Window, pipelining</td>
<td class="org-left">The sender may be restricted to sending only packets with sequence numbers that fall within a given range. By allowing multiple packets to be transmitted but not yet acknowledged, sender utilization can be increased over a stop-and-wait mode of operation. We’ll see shortly that the window size may be set on the basis of the receiver’s ability to receive and buffer messages, or the level of congestion in the network, or both.</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org47a3350" class="outline-2">
<h2 id="org47a3350">Connection-Oriented Transport: TCP</h2>
</div>
</div>
<div id="postamble" class="status">
Last update: 2020-06-18 16:12
</div>
</body>
</html>
