<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-01 Fri 11:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Algebra Calculo Relacional</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
<link rel="stylesheet" type="text/css" href="/home/mk/Documents/blogs/org.css"/>
</head>
<body>
<div id="content">
<div id="outline-container-orgebe0c48" class="outline-2">
<h2 id="orgebe0c48">Introducción</h2>
<div class="outline-text-2" id="text-orgebe0c48">
</div>
<div id="outline-container-org82127a3" class="outline-4">
<h4 id="org82127a3">Lenguajes de manipulación de datos (DML)</h4>
<div class="outline-text-4" id="text-org82127a3">
<p>
Para interactuar con un modelo es necesario utilizar un lenguaje.
</p>

<p>
Los lenguajes que permiten extraer información de un modelo de datos se
denominan lenguajes de manipulación de datos, o DML (Data Manipulation
Languages).
</p>

<div class="org-src-container">
<pre class="src src-language">
</pre>
</div>

<p>
Los lenguajes procedurales indican un procedimiento a seguir, utilizando
operaciones que indican cómo manipular las datos.
</p>

<p>
Los lenguajes declarativos indican qué resultado se quiere obtener, sin
especificar cómo hacerlo.
</p>

<p>
Los lenguajes procedurales se consideran de más bajo nivel.
</p>
</div>
</div>

<div id="outline-container-orgcd02b13" class="outline-4">
<h4 id="orgcd02b13">Lenguajes del modelo relacional</h4>
<div class="outline-text-4" id="text-orgcd02b13">
<p>
En el modelo relacional existen distintos DML's, algunos de ellos formales y
algunos prácticos.
</p>

<p>
El lenguage práctico más conocido es SQL (Structured Query Language), y es
declarativo.
</p>

<p>
Los lenguajes formales del modelo relacional son:
</p>
<ul class="org-ul">
<li>El álgebra relacional (procedural).</li>
<li>El cálculo relacional (declarativo).</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org324839a" class="outline-2">
<h2 id="org324839a">Álgebra Relacional</h2>
<div class="outline-text-2" id="text-org324839a">
</div>
<div id="outline-container-org5a008ea" class="outline-4">
<h4 id="org5a008ea">Características</h4>
<div class="outline-text-4" id="text-org5a008ea">
<p>
Es un lenguaje procedural.
</p>

<p>
Propuesto por E. Codd en 1970, se lo considera parte integral del modelo
relacional.
</p>

<p>
Su utilidad radica en que:
</p>
<ul class="org-ul">
<li>Provee un marco formal de operaciones para el modelo relacional.</li>
<li>Se emplea como base para optimizar la ejecución de consultas.</li>
</ul>

<p>
El álgebra relacional especifica los procedimientos de consulta de datos a
partir de un conjunto de operaciones.
</p>

<p>
Una operación -en el contexto del modelo relacional- es una función cuyos
operandos son una o más relaciones, y cuyo resultado es también una relación.
</p>

<p>
O : R_1× R_2 × &#x2026; × R_n → S
</p>

<p>
La aridad es la cantidad de operandos que toma una operación.
</p>

<p>
Las operaciones del álgebra relacional pueden combinarse entre ellas para formar
una expresión.
</p>
</div>
</div>

<div id="outline-container-orge97bcec" class="outline-4">
<h4 id="orge97bcec">Recursos utilizados</h4>
<div class="outline-text-4" id="text-orge97bcec">
<p>
2010 World Cup Dataset
<a href="https://github.com/chinovieza/worldcup2010">https://github.com/chinovieza/worldcup2010</a>
</p>

<p>
RelaX - Relational algebra calculator
<a href="http://dbis-uibk.github.io/relax/">http://dbis-uibk.github.io/relax/</a>
</p>
</div>
</div>

<div id="outline-container-orgf9746dc" class="outline-4">
<h4 id="orgf9746dc">Recursos utilizados: 2010 World Cup Dataset</h4>
<div class="outline-text-4" id="text-orgf9746dc">
<p>
Modelo ER simplificado (sin atributos):
</p>

<p>
Esquema de base de datos relacional:
</p>

<ul class="org-ul">
<li>Continent(id, name)
<ul class="org-ul">
<li>(1, ’Africa’)</li>
</ul></li>
<li>NationalTeam(id, name, group, short_name, continent)
<ul class="org-ul">
<li>(1, ’South Africa’, ’A’, ’RSA’, 0)</li>
</ul></li>
<li>Match(id, home, away, match_datetime_gmt, stage)
<ul class="org-ul">
<li>(1, 1, 2, ’2010-06-11 14:00:00’, 1)</li>
</ul></li>
<li>Player(id, name, birth_date, height, playing_position, local_club,
national_team, national_team_tshirt)
<ul class="org-ul">
<li>(53, ’Edinson Cavani’, ’1987-02-14’, 188, ’FW’, ’Palermo [ITA]’, 3, 7)</li>
</ul></li>
<li>Score(id, match_id, team_id, player_id, minute, score_type)
<ul class="org-ul">
<li>(1, 1, 1, 8, ’55’, 1) (Corresponde a la entidad Goal).</li>
</ul></li>
<li>Stage(id, name)
<ul class="org-ul">
<li>(3, ’Quarter-finals’)</li>
</ul></li>
</ul>

<p>
Asumiremos que “name” es siempre clave candidata.
</p>

<p>
Los tipos de score son: 1-normal; 2-penal; 3-tiempo adic.; 4-tiempo supl.; 5-gol
en contra (se asigna al equipo contrario); 6-gol en serie de penales; 7-gol
errado en serie de penales (no cuenta como gol).
</p>
</div>
</div>

<div id="outline-container-org8c95ca9" class="outline-3">
<h3 id="org8c95ca9">Operaciones básicas</h3>
<div class="outline-text-3" id="text-org8c95ca9">
</div>
<div id="outline-container-orgfce11a5" class="outline-4">
<h4 id="orgfce11a5">Selección [ELM16 8.1.1]</h4>
<div class="outline-text-4" id="text-orgfce11a5">
<p>
El operador de selección (σ) es un operador unario.
</p>

<p>
σ<sub>cond</sub>:R → S
</p>

<p>
Dada una relación R(A_1,A_2, &#x2026;,A_n) y una condición que se aplica a cada tupla
de R, σ<sub>cond</sub>(R) selecciona aquellas tuplas de R para las cuales la condición
es verdadera.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-right">año</td>
<td class="org-left">nombre_director</td>
<td class="org-right">cant_oscars</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-right">2003</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-right">2012</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-right">2005</td>
<td class="org-left">George Lucas</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-right">2017</td>
<td class="org-left">Lee Unkrich</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<p>
σ<sub>cant_oscars ≥ 1</sub>(Películas)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-right">año</td>
<td class="org-left">nombre_director</td>
<td class="org-right">cant_oscars</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-right">2012</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-right">2017</td>
<td class="org-left">Lee Unkrich</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org9c0d965" class="outline-5">
<h5 id="org9c0d965">Condiciones</h5>
<div class="outline-text-5" id="text-org9c0d965">
<p>
Utilizaremos condiciones atómicas de la forma:
</p>
<ul class="org-ul">
<li>A_i A_j</li>
<li>A i c, con c ∈ dom(A_i)</li>
</ul>

<p>
En donde debe ser un operador de comparación:
</p>
<ul class="org-ul">
<li>=, &ne;</li>
<li>&gt;, ≥, &lt;, ≤ (sólo para atributos cuyos dominios están ordenados)</li>
</ul>

<p>
Una condición se construye combinando condiciones atómicas con los operadores
lógicos and (∧), or (∨) y not (¬).
</p>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Seleccionar aquellos jugadores del mundial que pertenecen al club
“Barcelona [ESP]” y nacieron antes de 1990.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
σ_{(local_club=“Barcelona [ESP]”)∧(birth_date&lt;“1990−01−01”)} (Player)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6b3b092" class="outline-4">
<h4 id="org6b3b092">Proyección [ELM16 8.1.2]</h4>
<div class="outline-text-4" id="text-org6b3b092">
<p>
El operador de proyección (π) es también un operador unario.
</p>

<p>
π<sub>L</sub>:R → S
</p>

<p>
Dada una relación R(A_1,A_2, &#x2026;,A_n) y una lista de atributos L = (L_1,L_2,
&#x2026;, L_k), con L_i ∈ (A_1,A_2, &#x2026;,A_n), π_L(R) devuelve una atributos de L en
R.
</p>

<p>
Podemos pensar que lo que hace es proyectar cada tupla de R a un espacio de
menor dimensión en que sólo se conservan los atributos que están en L.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-right">año</td>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-right">2003</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-right">2012</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-right">2005</td>
<td class="org-left">George Lucas</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-right">2017</td>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>

<p>
π<sub>nombre_director</sub>(Películas)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">George Lucas</td>
</tr>

<tr>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>

<p>
El orden de los atributos en la relación resultado es el mismo orden en que
figuran en L.
</p>

<p>
El operador de proyección siempre remueve tuplas duplicadas, ya que su resultado
debe ser también una relación válida.
</p>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste las posiciones de juego de los jugadores.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
π playing_position (Player )
</pre>
</div>
</div>
</div>

<div id="outline-container-orgff7a5d9" class="outline-4">
<h4 id="orgff7a5d9">Secuencias de operaciones. Asignación (←) [ELM16 8.1.3]</h4>
<div class="outline-text-4" id="text-orgff7a5d9">
<p>
Supongamos que queremos listar los nombres de los directores
que han ganado algún Oscar.
</p>

<p>
PELÍCULAS
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-right">año</td>
<td class="org-left">nombre_director</td>
<td class="org-right">cant_oscars</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-right">2003</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-right">2012</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-right">2005</td>
<td class="org-left">George Lucas</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-right">2017</td>
<td class="org-left">Lee Unkrich</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Temp ← σ<sub>cant_oscars&gt;0</sub> (Películas)
</p>

<p>
Directores_Oscar ← π nombre_director (Temp)
</p>

<p>
Podemos también hacerlo en un único paso:
Directores_Oscar ← π nombre_director (σ<sub>cant_oscars&gt;0</sub> (Películas))
</p>

<p>
DIRECTORES_OSCAR
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf7a8f8b" class="outline-4">
<h4 id="orgf7a8f8b">Redenominación [ELM16 8.1.3]</h4>
<div class="outline-text-4" id="text-orgf7a8f8b">
<p>
El operador de redenominación (ρ) permite modificar los nombres de los atributos
de una relación y/o el nombre de la relación misma.
</p>

<p>
Nos permite preparar el resultado para la realización de una operación
posterior.
</p>

<p>
Dada una relación R(A 1 , A 2 , &#x2026;, A n ), un nuevo nombre de relación S y una
lista de n nombres de atributo (B 1 , B 2 , &#x2026;, B n ), ρ S(B 1 ,B 2 ,&#x2026;,B n )
(R) produce una relación de nombre S y atributos (B 1 , B 2 , &#x2026;, B n ) cuyas
tuplas coinciden con las tuplas de R.
</p>

<p>
ρ S (R) sólo cambia el nombre de la relación R por S.
</p>

<p>
PELÍCULAS
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-right">cant_oscars</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<p>
ρ<sub>Films(film_name,n_oscars)</sub>(Películas)
</p>

<p>
FILMS
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">film_name</td>
<td class="org-right">n_oscars</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc85f9a2" class="outline-4">
<h4 id="orgc85f9a2">Operaciones de conjuntos</h4>
<div class="outline-text-4" id="text-orgc85f9a2">
</div>
<div id="outline-container-orgb23fe3b" class="outline-5">
<h5 id="orgb23fe3b">Unión [ELM16 8.2.1]</h5>
<div class="outline-text-5" id="text-orgb23fe3b">
<p>
Dadas dos relaciones R(A 1 , A 2 , &#x2026;, A n ) y S(B 1 , B 2 , &#x2026;, B n ), la
unión R ∪ S es una relación que contiene a todas las tuplas de R y de S.
</p>

<p>
Es necesario que R y S tengan el mismo grado.
</p>

<p>
Además, para calcular R ∪ S las relaciones R y S deben coincidir en sus
atributos en lo que respecta al dominio. Es decir, dom(A i ) = dom(B i ). Esta
condición se denomina compatibilidad de unión o compatibilidad de tipo.
</p>

<p>
Por convención, en la relación resultado el listado de atributos coincide con el
de R: (A 1 , A 2 , &#x2026;, A n ).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id1</td>
<td class="org-left">nombre1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Juan</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>

<tr>
<td class="org-right">18</td>
<td class="org-left">Marta</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id2</td>
<td class="org-left">nombre2</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">Marta</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>
</tbody>
</table>

<p>
Usuarios1 ∪ Usuarios2
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id1</td>
<td class="org-left">nombre1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Juan</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>

<tr>
<td class="org-right">18</td>
<td class="org-left">Marta</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">Marta</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org748a916" class="outline-5">
<h5 id="org748a916">Intersección [ELM16 8.2.1]</h5>
<div class="outline-text-5" id="text-org748a916">
<p>
Dadas dos relaciones R(A 1 , A 2 , &#x2026;, A n ) y S(B 1 , B 2 , &#x2026;, B n ), la
intersección R ∩ S conserva las tuplas que se encuentran presentes tanto en R
como en S.
</p>

<p>
R y S deben tener el mismo grado.
</p>

<p>
Al igual que la unión, la intersección requiere compatibilidad de tipo.
</p>

<p>
El listado de atributos de la relación resultado será (A 1 , A 2 , &#x2026;, A n ).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id1</td>
<td class="org-left">nombre1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Juan</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>

<tr>
<td class="org-right">18</td>
<td class="org-left">Marta</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id2</td>
<td class="org-left">nombre2</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">Marta</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>
</tbody>
</table>

<p>
Usuarios1 ∩ Usuarios2
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id1</td>
<td class="org-left">nombre1</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org5857364" class="outline-5">
<h5 id="org5857364">Diferencia [ELM16 8.2.1]</h5>
<div class="outline-text-5" id="text-org5857364">
<p>
Dadas dos relaciones R(A 1 , A 2 , &#x2026;, A n ) y S(A 1 , A 2 , &#x2026;, A n ), la
diferencia R − S conserva sólo aquellas tuplas de R que no pertenecen a S.
</p>

<p>
R y S deben tener el mismo grado.
</p>

<p>
También requiere compatibilidad de tipo.
</p>

<p>
El listado de atributos de la relación resultado será (A 1 , A 2 , &#x2026;, A n ).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id1</td>
<td class="org-left">nombre1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Juan</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>

<tr>
<td class="org-right">18</td>
<td class="org-left">Marta</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id2</td>
<td class="org-left">nombre2</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">Marta</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Martín</td>
</tr>
</tbody>
</table>

<p>
Usuarios1 − Usuarios2
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">id1</td>
<td class="org-left">nombre1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Juan</td>
</tr>

<tr>
<td class="org-right">18</td>
<td class="org-left">Marta</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org3eb1acd" class="outline-4">
<h4 id="org3eb1acd">Producto cartesiano [ELM16 8.2.2]</h4>
<div class="outline-text-4" id="text-org3eb1acd">
<p>
Dadas dos relaciones R(A 1 , A 2 , &#x2026;, A n ) y S(B 1 , B 2 , &#x2026;, B m ), el
producto cartesiano R × S produce una nueva relación T cuyas tuplas son todas
aquellas de la forma (t 1 , t 2 , &#x2026;, t n , t n+1 , t n+2 , &#x2026;, t n+m ), con
(t 1 , t 2 , &#x2026;, t n ) ∈ R y (t n+1 , t n+2 , &#x2026;, t n+m ) ∈ S.
</p>

<p>
El esquema de la relación resultante T es (A 1 , A 2 , &#x2026;, A n , B 1 , B 2 ,
&#x2026;, B m ). Salvo&#x2026;
</p>

<p>
&#x2026; si algún atributo A i tiene el mismo nombre que un atributo B j. En ese
caso, la convención será que en el resultado los atributos se llamarán “R.A i ”
y “S.B j ”. En el caso de estar calculando R × R, llamaremos a los atributos
R1.A i y R2.A i .
</p>

<p>
Es la primera operación hasta ahora que nos permite combinar
información proveniente de distintas relaciones.
</p>

<p>
Aunque generalmente debe ser acompañada de alguna selección
para reducir las combinaciones del resultado.
</p>

<p>
El producto cartesiano no requiere compatibilidad de tipos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<p>
Películas × Actuaciones
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Películas.nombre_película</td>
<td class="org-left">nombre_director</td>
<td class="org-left">Actuaciones.nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-left">Lee Unkrich</td>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-left">Lee Unkrich</td>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>


<p>
¿Cómo hacemos, dadas las relaciones
</p>
<ul class="org-ul">
<li>Películas(nombre_película, nombre_director)</li>
<li>Actuaciones(nombre_película, nombre_actor)</li>
</ul>
<p>
para obtener las tuplas (nombre_película, nombre_director, nombre_actor) que
representan la coparticipación de actores y directores en películas?
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<p>
σ<sub>Peliculas.nombre_pelicula = Actuaciones.nombre_pelicula</sub>(Películas ×
Actuaciones)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Películas.nombre_película</td>
<td class="org-left">nombre_director</td>
<td class="org-left">Actuaciones.nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste los países con los que jugó la Selección Argentina.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
LOCAL ← π_{away} (σ_{(home=NT .id)∧(name=“Argentina”)} (Match × ρ_{NT} (NationalTeam)))
AWAY ← π_{home} (σ__{(away =NT .id)∧(name=“Argentina”)} (Match × ρ_{NT} (NationalTeam)))
π_{name} (σ_{away =id} (NationalTeam × (LOCAL ∪ AWAY )))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f7cdd4" class="outline-4">
<h4 id="org8f7cdd4">Árboles de consulta [ELM16 8.3.5]</h4>
<div class="outline-text-4" id="text-org8f7cdd4">
<p>
Para cada expresión del álgebra relacional se puede construir un árbol de
consulta que representa el orden de ejecución.
</p>

<p>
Para el ejemplo anterior sobre el producto cartesiano:
</p>

<p>
image
</p>
</div>
</div>

<div id="outline-container-org052be02" class="outline-4">
<h4 id="org052be02">Junta [ELM16 8.3.1]</h4>
<div class="outline-text-4" id="text-org052be02">
<p>
La operación de junta combina un producto cartesiano con una selección. Dadas
dos relaciones R(A 1 , A 2 , &#x2026;, A n ) y S(B 1 , B 2 , &#x2026;, B m ) y una
condición, la junta R ./ cond S selecciona del producto cartesiano R × S las
tuplas que cumplen la condición.
</p>

<p>
No se admite cualquier tipo de condición de selección, sino sólo
la conjunción de operaciones atómicas que incluyen columnas de
ambas relaciones, es decir, de la forma:
</p>
<ul class="org-ul">
<li>A_i B_j</li>
</ul>

<p>
En donde debe ser un operador de comparación:
</p>
<ul class="org-ul">
<li>=, &ne;</li>
<li>&gt;, ≥, &lt;, ≤ (sólo para atributos cuyos dominios están ordenados)</li>
</ul>

<p>
Una condición se construye entonces combinando operaciones atómicas con el
operador lógico and (∧).
</p>

<p>
Ahora la combinación de Películas y Actuaciones se hace mucho más sencilla:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<p>
(Películas _{nombre_pelicula=nombre_pelicula}Actuaciones)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Películas.nombre_película</td>
<td class="org-left">nombre_director</td>
<td class="org-left">Actuaciones.nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Obtenga el listado de los nombres de los jugadores de la Selección Argentina.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
PLAYER_TEAM ← NationalTeam ./ _{id=team_id} Player
π_{Player.name} (σ__{NationalTeam.name=“Argentina”} (PLAYER_TEAM))
</pre>
</div>
</div>

<div id="outline-container-org6448284" class="outline-5">
<h5 id="org6448284">Tipos particulares de junta [ELM16 8.3.2]</h5>
<div class="outline-text-5" id="text-org6448284">
<p>
El caso más general de operación de junta también se denomina junta theta (theta
join).
</p>

<p>
Cuando la junta sólo utiliza comparaciones de igualdad en sus condiciones
atómicas, se denomina junta por igual (equijoin).
</p>

<p>
En la junta por igual, el resultado dispondrá de pares de atributos distintos
que poseerán información redundante. Para librarse de uno de ellos, se define la
junta natural.
</p>
</div>
</div>

<div id="outline-container-orgb4996d6" class="outline-5">
<h5 id="orgb4996d6">Junta Natural</h5>
<div class="outline-text-5" id="text-orgb4996d6">
<p>
Para realizar una junta natural entre dos relaciones en reemplazo de una junta
por igual, las mismas deben estar preparadas de manera que los pares de
atributos (A i , B j ) de cada condición atómica tengan el mismo nombre en una y
otra relación. El resultado dispondrá de uno sólo de los atributos, conservando
su nombre.
</p>

<p>
La junta natural entre dos relaciones R y S se simboliza R ∗ S.
</p>

<p>
¡Atención! En la junta natural no se especifican las condiciones, por lo tanto
todo par de atributos de igual nombre en una y otra relación será comparado por
igual en la condición de selección implícita.
</p>

<p>
Los atributos comparados en una junta se denominan atributos de junta.
</p>

<p>
Volviendo al caso de las Películas y Actuaciones:
</p>
<ul class="org-ul">
<li>Películas(nombre_película, nombre_director)</li>
<li>Actuaciones(nombre_película, nombre_actor)</li>
</ul>

<p>
Las relaciones ya están preparadas para una junta natural.
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<p>
(Películas * Actuaciones)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_director</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-language">Ejemplo: RENAPER
Personas(DNI, nombre, género, fecha_nacimiento)
HijoDe(DNI_padre, DNI_hijo)
CasadaCon(DNI1, DNI2, fecha_matrimonio)

Liste a todos los hijos de “Abraham Simpson” (suponga que no hay dos
personas con ese nombre).
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
PADRE ← ρ DNI_padre (π DNI (σ nombre=“Abraham Simpson” (Personas)))
HIJOS ← ρ DNI_hijo,nombre (π DNI,nombre (Personas))
π DNI_hijo,nombre (PADRE * HijoDe * HIJOS)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgab7082f" class="outline-4">
<h4 id="orgab7082f">División [ELM16 8.3.4]</h4>
<div class="outline-text-4" id="text-orgab7082f">
<p>
Esta vez, primero el ejemplo&#x2026;
</p>

<p>
Nos interesa saber qué alumnos aprobaron los 3 TPs.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">alumno</td>
<td class="org-right">TP</td>
<td class="org-right">nota</td>
</tr>

<tr>
<td class="org-left">Pedro</td>
<td class="org-right">1</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-left">Pedro</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Juan</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">Juan</td>
<td class="org-right">2</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">Juan</td>
<td class="org-right">3</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-left">Walter</td>
<td class="org-right">1</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">Walter</td>
<td class="org-right">2</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-left">Walter</td>
<td class="org-right">3</td>
<td class="org-right">8</td>
</tr>
</tbody>
</table>

<p>
→
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">alumno</td>
<td class="org-right">TP</td>
</tr>

<tr>
<td class="org-left">Pedro</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Juan</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Juan</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">Walter</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Walter</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Walter</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>

<p>
REQUISITOS
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">TP</td>
</tr>

<tr>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
</tr>
</tbody>
</table>

<p>
(Aprobados ÷ Requisitos)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">alumno</td>
</tr>

<tr>
<td class="org-left">Walter</td>
</tr>
</tbody>
</table>


<p>
Es una operación inversa al producto cartesiano.
</p>

<p>
Partimos de una relación R(A 1 , A 2 , &#x2026;, A n ) y una relación S(B 1 , B 2 ,
&#x2026;, B m ) cuyos atributos están incluídos en los de R.
</p>

<p>
Llamaremos A = {A 1 , A 2 , &#x2026;, A n } y B = {B 1 , B 2 , &#x2026;, B m }. Entonces B
⊂ A.
</p>

<p>
Llamaremos Y = A − B.
</p>

<p>
Se define entonces la división R ÷ S como la relación T (Y ) cuyas tuplas t
cumplen que:
</p>
<ol class="org-ol">
<li>t pertenece a π Y (R).</li>
<li>Para cada tupla t S ∈ S existe una tupla t R ∈ R tal que t R [Y ] = t y t R
[B] = t S .</li>
</ol>

<p>
Propiedad: T es la relación de mayor cardinalidad posible contenida en π Y (R) y
que cumple que T ∗ S ⊂ R.
</p>


<div class="org-src-container">
<pre class="src src-language">Ejemplo: Tenistas
Tenistas(nombre_tenista, país, altura, diestro)
(‘Novak Djokovic’, ‘Serbia’, 1.88, True)
Torneos(nombre_torneo, tipo_torneo)
(‘Abierto de Australia’, ‘Grand Slam’)
Campeones(nombre_tenista, nombre_torneo, modalidad, año)
(‘Juan Martín del Potro’, ‘Torneo de Estocolmo’, ‘Single’, 2016)
Liste a aquellos tenistas que hayan ganado todos los torneos de tipo “Grand
Slam” existentes al menos una vez.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
TORNEOS_GRAND_SLAM ← π nombre_torneo (σ tipo_torneo=“Grand Slam” (Torneos))
π nombre_tenista,nombre_torneo (Campeones)÷TORNEOS_GRAND_SLAM
</pre>
</div>
</div>
</div>

<div id="outline-container-orga579ed5" class="outline-4">
<h4 id="orga579ed5">Conjuntos completos de operadores [ELM16 8.3.3]</h4>
<div class="outline-text-4" id="text-orga579ed5">
<p>
Hemos definido una serie de operadores básicos del álgebra relacional: σ, π, ρ,
∪, ∩, −, ×, ./, ∗, ÷.
</p>

<p>
Sin embargo, existen subconjuntos de ellos que tienen la misma capacidad de
expresión que todo el conjunto.
</p>

<p>
A dichos subconjuntos se los denomina conjuntos completos de operadores.
</p>

<p>
{σ, π, ρ, ∪, −, ×} forman un conjunto completo de operadores.
</p>

<div class="org-src-container">
<pre class="src src-language">¿Cómo se demuestra?
Mostrando que cada uno de los operadores restantes puede
construirse a partir de estos seis.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb505d23" class="outline-3">
<h3 id="orgb505d23">Operaciones adicionales: Junta externa</h3>
<div class="outline-text-3" id="text-orgb505d23">
</div>
<div id="outline-container-org64722ea" class="outline-4">
<h4 id="org64722ea">Operaciones adicionales [ELM16 8.4]</h4>
<div class="outline-text-4" id="text-org64722ea">
<p>
Existen operaciones frecuentes de bases de datos que no pueden
ser expresadas en el álgebra relacional básica.
</p>

<p>
Se han propuesto numerosos operadores para extender el
álgebra relacional, entre ellos:
</p>
<ul class="org-ul">
<li>La proyección generalizada.</li>
<li>La agregación.</li>
<li>La junta externa.</li>
</ul>

<p>
Sólo presentaremos aquí la junta externa.
</p>
</div>
</div>

<div id="outline-container-orgfc8299b" class="outline-4">
<h4 id="orgfc8299b">Junta externa</h4>
<div class="outline-text-4" id="text-orgfc8299b">
<p>
Volvamos al ejemplo de las películas y los actores.
</p>

<p>
PELÍCULAS
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_director</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Django Unchained</td>
<td class="org-left">Quentin Tarantino</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
</tr>

<tr>
<td class="org-left">Coco</td>
<td class="org-left">Lee Unkrich</td>
</tr>
</tbody>
</table>

<p>
ACTUACIONES
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<p>
(Películas ./ _{nombre_pelicula=nombre_pelicula} Actuaciones)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Películas.nombre_película</td>
<td class="org-left">nombre_director</td>
<td class="org-left">Actuaciones.nombre_película</td>
<td class="org-left">nombre_actor</td>
</tr>

<tr>
<td class="org-left">Kill Bill</td>
<td class="org-left">Quentin Tarantino</td>
<td class="org-left">Kill Bill</td>
<td class="org-left">Uma Thurman</td>
</tr>

<tr>
<td class="org-left">Star Wars III</td>
<td class="org-left">George Lucas</td>
<td class="org-left">Star Wars III</td>
<td class="org-left">Natalie Portman</td>
</tr>
</tbody>
</table>

<p>
El resultado muestra las combinaciones de director y actor que trabajaron
juntos, pero descarta las tuplas de la relación izquierda con las cuales no se
combina ninguna tupla de la derecha.
</p>

<p>
La junta externa evita que eso suceda, asegurando que las tuplas de una o ambas
relaciones estén presentes en el resultado, aún cuando no puedan combinarse con
ninguna tupla de la otra.
</p>

<p>
Existen 3 tipos de junta externa:
</p>
<ul class="org-ul">
<li>Junta externa izquierda (R ./ S)</li>
<li>Junta externa derecha (R ./ S)</li>
<li>Junta externa completa (R ./ S)</li>
</ul>

<p>
Dadas dos relaciones R(A 1 , A 2 , &#x2026;, A n ) y S(B 1 , B 2 , &#x2026;, B m ) y una
condición, la junta externa R[ ./, ./ , ./ ] cond S selecciona del producto R ×
S las tuplas que cumplen la condición, y añade&#x2026;
</p>
<ul class="org-ul">
<li>&#x2026;una tupla (t[A 1 , t[A 2 ], &#x2026;, t[A n ], NULL, NULL, &#x2026;, NULL) de
dimensión n + m por cada tupla de t ∈ R que no se encuentra en la proyección
sobre (A 1 , A 2 , &#x2026;, A n ) (Junta externa izquierda, ./).</li>
<li>&#x2026;una tupla (NULL, NULL, &#x2026;, NULL, t[B 1 , t[B 2 ], &#x2026;, t[B m ]) de
dimensión n + m por cada tupla de t ∈ S que no se encuentra en la proyección
sobre (B 1 , B 2 , &#x2026;, B m ) (Junta externa derecha, ./ ).</li>
<li>&#x2026;ambos tipos de tuplas descriptos (Junta externa completa, ./ ).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3b4c9b2" class="outline-3">
<h3 id="org3b4c9b2">Ejercicios</h3>
<div class="outline-text-3" id="text-org3b4c9b2">
<div class="org-src-container">
<pre class="src src-language">Ejercicio 1
Liste el nombre de los continentes que no fueron representados
por ningún equipo en los cuartos de final del Mundial.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Ejercicio 2
Liste el nombre de los jugadores que marcaron al menos 3 goles
durante el Mundial.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Ejercicio 3
Liste el nombre y selección nacional de el/los jugadores más altos
del Mundial.
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbe5d883" class="outline-2">
<h2 id="orgbe5d883">Cálculo Relacional</h2>
<div class="outline-text-2" id="text-orgbe5d883">
</div>
<div id="outline-container-org077aa56" class="outline-3">
<h3 id="org077aa56">Cálculo Relacional de Tuplas</h3>
<div class="outline-text-3" id="text-org077aa56">
</div>
<div id="outline-container-orged784a0" class="outline-4">
<h4 id="orged784a0">Predicados y operaciones [ELM16 8.6; SILB10 6.2; CONN15 5.2.1]</h4>
<div class="outline-text-4" id="text-orged784a0">
<p>
En el cálculo relacional de tuplas las variables representan tuplas.
</p>

<p>
Un predicado simple es una función de una tupla o de atributos de tuplas, cuyo
resultado es un valor de verdad (V ó F). Se admiten como predicados simples:
</p>
<ul class="org-ul">
<li>R(t), en donde R es una relación</li>
<li>t 1 .A i t 2 .A j</li>
<li>t.A i c, con c ∈ dom(A i )</li>
<li>En donde debe ser un operador de comparación:
<ul class="org-ul">
<li>=, &ne;</li>
<li>&gt;, ≥, &lt;, ≤ (sólo para atributos cuyos dominios están ordenados)</li>
</ul></li>
</ul>

<p>
Las operaciones entre predicados admitidas son ∧, ∨, ¬.
</p>

<div class="org-src-container">
<pre class="src src-language">Una expresión del cálculo relacional de tuplas tiene la forma:
{t 1 .A 11 , t 1 .A 12 , ..., t 1 .A 1k 1 , ..., t n .A nk n |p(t 1 , t 2 , ..., t n , t n+1 , ..., t n+m )},
en donde p es un predicado válido. {t 1 , t 2 , ..., t n } deben ser
variables libres, y {t n+1 , t n+2 , ..., t n+m } deben ser variables ligadas.
</pre>
</div>
</div>
</div>

<div id="outline-container-org2834f4f" class="outline-4">
<h4 id="org2834f4f">Ejemplos</h4>
<div class="outline-text-4" id="text-org2834f4f">
<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste los nombres de los países que jugaron el Mundial 2010.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{n.name|NationalTeam(n)}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste los nombres de los jugadores nacidos antes de 1980.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{p.name|Player (p) ∧ p.date_birth &lt;1980-01-01}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda601b6" class="outline-4">
<h4 id="orgda601b6">Cuantificadores [ELM16 8.6.3; ELM16 8.6.6]</h4>
<div class="outline-text-4" id="text-orgda601b6">
<p>
Pero, ¿cómo hacemos si queremos listar a los jugadores que hicieron algún gol
durante el mundial?
</p>

<p>
Necesitamos de los cuantificadores.
</p>
<ul class="org-ul">
<li>Cuantificador universal: (∀t)p(t). Es verdadero si para cualquier tupla t el
predicado p(t) es verdadero.</li>
<li>Cuantificador existencial: (∃t)p(t). Es verdadero si existe al menos una tupla
t para la cual el predicado p(t) es verdadero.</li>
</ul>

<p>
El listado de los nombres de los jugadores que hicieron goles se obtiene como:
</p>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{p.name|Player (p) ∧ (∃s)(Score(s) ∧ s.player _id = p.id)}
</pre>
</div>

<p>
Atención! Una variable que fue cuantificada no puede aparecer seleccionada en el
lado izquierdo de la barra (|), y toda variable que aparece sólo en el lado
derecho debe estar cuantificada.
</p>
<ul class="org-ul">
<li>Las variables que fueron cuantificadas son variables ligadas.</li>
<li>Las variables que no fueron cuantificadas son variables libres.</li>
</ul>

<p>
Reiteramos:
</p>

<div class="org-src-container">
<pre class="src src-language">Una expresión del cálculo relacional de tuplas tiene la forma:
{t 1 .A 11 , t 1 .A 12 , ..., t 1 .A 1k 1 , ..., t n .A nk n |p(t 1 , t 2 , ..., t n , t n+1 , ..., t n+m )},
en donde p es un predicado válido. {t 1 , t 2 , ..., t n } deben ser
variables libres, y {t n+1 , t n+2 , ..., t n+m } deben ser variables ligadas.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste los nombres de los jugadores de la Selección Española.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{p.name|Player (p) ∧ (∃n)(NationalTeam(n)∧n.id = p.national_team ∧ n.name = “Spain”)}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste el nombre del jugador más anciano del Mundial.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{p.name|Player (p) ∧ (∀θ)(¬Player (θ)∨θ.birth_date ≥ p.birth_date)}
</pre>
</div>

<p>
Observemos que el cuantificador ∀θ necesita típicamente de una negación dentro
de su expresión, para restringir el universo de θ’s sobre los que requerimos que
la expresión sea verdadera. De lo contrario, el resultado estará vacío.
</p>
</div>
</div>

<div id="outline-container-org7fe3a45" class="outline-4">
<h4 id="org7fe3a45">Expresiones seguras [ELM16 8.6.8; SILB10 6.2.3]</h4>
<div class="outline-text-4" id="text-org7fe3a45">
<p>
No toda expresión válida del cálculo de tuplas es una expresión segura (safe
expression).
</p>

<p>
Por ejemplo, la expresión&#x2026;
</p>
<div class="org-src-container">
<pre class="src src-language">{p.name|¬Player (p)}
</pre>
</div>

<p>
&#x2026; no es una expresión segura. Producirá una cantidad infinita de tuplas con
valores como “safsq” o 57.
</p>

<p>
Una expresión segura es aquella que garantiza formalmente que producirá una
cantidad finita de tuplas.
</p>

<p>
Puede probarse que ésto es equivalente a garantizar que los valores de los
atributos del resultado son parte del dominio de la expresión.
</p>

<p>
Ejemplos:
</p>
<ul class="org-ul">
<li>{p 1 .nombre|(∃p 2 )(Persona(p 2 ) ∧ p 2 .edad = p 1 .edad)}
<ul class="org-ul">
<li>X Expresión no segura</li>
<li>Probablemente queríamos
<ul class="org-ul">
<li>{p 1 .nombre|Persona(p 1 ) ∧ (∃p 2 )(Persona(p 2 ) ∧ p 2 .edad = p 1 .edad)}</li>
</ul></li>
</ul></li>
<li>{p 1 .nombre|Empleado(p 1 ) ∧ (6 ∃p 2 )(Empleado(p 2 ) ∧ p 2 .sueldo &gt; p 1 .sueldo)}
<ul class="org-ul">
<li>Expresión segura</li>
</ul></li>
<li>{t.nombre|¬((Cliente(t) ∧ Proveedor (t))}
<ul class="org-ul">
<li>Expresión no segura</li>
<li>Probablemente queríamos
<ul class="org-ul">
<li>{t.nombre|(Cliente(t) ∨ Proveedor (t)) ∧ ¬(Cliente(t) ∧ Proveedor (t))}</li>
</ul></li>
</ul></li>
</ul>

<p>
Recomendación: Cuidado cuando usamos cuantificadores ó negamos predicados!
</p>
</div>
</div>

<div id="outline-container-org46391d6" class="outline-4">
<h4 id="org46391d6">Ejercicio: Tenistas</h4>
<div class="outline-text-4" id="text-org46391d6">
<div class="org-src-container">
<pre class="src src-language">Tenistas(nombre_tenista, país, altura, diestro)
(‘Novak Djokovic’, ‘Serbia’, 1.88, True)
Torneos(nombre_torneo, tipo_torneo)
(‘Abierto de Australia’, ‘Grand Slam’)
Campeones(nombre_tenista, nombre_torneo, modalidad, año)
(‘Juan Martín del Potro’, ‘Torneo de Estocolmo’, ‘Single’, 2016)

Liste los nombres de los tenistas que ganaron todos los torneos de Grand Slam.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{c.nombre_tenista|Campeones(c)∧
(∀t)(¬Torneos(t) ∨ t.tipo_torneo 6 = “Grand Slam”∨
(∃c 2 )(Campeones(c 2 )∧
c 2 .nombre_tenista = c.nombre_tenista∧
c 2 .nombre_torneo = t.nombre_torneo))}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc359d33" class="outline-3">
<h3 id="orgc359d33">Cálculo Relacional de Dominios</h3>
<div class="outline-text-3" id="text-orgc359d33">
</div>
<div id="outline-container-org9b7361f" class="outline-4">
<h4 id="org9b7361f">Predicados, operaciones y cuantificadores [ELM16 8.7]</h4>
<div class="outline-text-4" id="text-org9b7361f">
<p>
En el cálculo relacional de dominios las variables representan dominios, es
decir que hacen referencia a los atributos.
</p>

<p>
Un predicado simple es una función de un conjunto de dominios, cuyo resultado es
un valor de verdad (V ó F). Se admiten como predicados simples:
</p>
<ul class="org-ul">
<li>R(x 1 , x 2 , &#x2026;, x n ), en donde R(A 1 , A 2 , &#x2026;, A n ) es una relación</li>
<li>x i x j</li>
<li>x i c, con c ∈ dom(A i )</li>
<li>En donde debe ser un operador de comparación:
<ul class="org-ul">
<li>=, &ne;</li>
<li>&gt;, ≥, &lt;, ≤ (sólo para atributos cuyos dominios están ordenados)</li>
</ul></li>
</ul>

<p>
Las operaciones entre predicados admitidas son ∧, ∨, ¬.
</p>

<p>
Se utilizan los cuantificadores con las mismas reglas que en el
CRT.
</p>

<div class="org-src-container">
<pre class="src src-language">Una expresión del cálculo relacional de dominios tiene la forma:
{x 1 , x 2 , ..., x n |p(x 1 , x 2 , ..., x n , x n+1 , ..., x n+m )},
en donde p es un predicado válido. {x 1 , x 2 , ..., x n } deben ser
variables libres, y {x n+1 , x n+2 , ..., x n+m } deben ser variables
ligadas.
</pre>
</div>
</div>
</div>

<div id="outline-container-org612f2ee" class="outline-4">
<h4 id="org612f2ee">Ejemplos</h4>
<div class="outline-text-4" id="text-org612f2ee">
<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste los nombres de los países que jugaron el Mundial 2010.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{n|(∃i)(∃g)(∃s)(∃c)(NationalTeam(i, n, g, s, c))}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Ejemplo: World Cup 2010
Liste los nombres de los jugadores nacidos antes de 1980.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{n|(∃i)(∃b)(∃h)(∃p)(∃l)(∃t)(∃s)(Player (i, n, b, h, p, l, t, s) ∧ b
&lt;1980-01-01)}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">
Ejemplo: RENAPER
Personas(DNI, nombre, género, fecha_nacimiento)
HijoDe(DNI_padre, DNI_hijo)
CasadaCon(DNI1, DNI2, fecha_matrimonio)
Liste a todos los hijos de “Abraham Simpson” (suponga que no hay dos
personas con ese nombre).
</pre>
</div>

<div class="org-src-container">
<pre class="src src-language">Respuesta
{ h, n 1 |(∃d 1 )(∃g 1 )(∃f 1 )(∃d 2 )(∃n 2 )(∃g 2 )(∃f 2 )(∃p)
(Personas(d 1 , n 1 , g 1 , f 1 )∧ Personas(d 2 , n 2 , g 2 , f 2 )
∧HijoDe(p, h) ∧ n 2 = “Abraham Simpson” ∧ h = d 1 ∧ p = d2)}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org5d800bf" class="outline-2">
<h2 id="org5d800bf">Completitud Relacional</h2>
<div class="outline-text-2" id="text-org5d800bf">
<p>
E. Codd demostró la equivalencia entre el álgebra relacional básica y el cálculo
relacional(restringido a operaciones seguras) .
</p>

<p>
Esta equivalencia implica que ambos lenguajes tienen el mismo poder expresivo.
</p>
<ul class="org-ul">
<li>Toda consulta expresable a través del cálculo relacional es también expresable
en el álgebra relacional básica y viceversa.</li>
</ul>

<div class="org-src-container">
<pre class="src src-language">¿Cómo se demuestra esta equivalencia?
Mostrando que cada uno de los operadores del álgebra relacional
básica es expresable a través del cálculo relacional, y que una
expresión genérica segura del cálculo relacional es expresable
utilizando los operadores del álgebra relacional básica.
</pre>
</div>

<p>
A su vez, se dice que un lenguaje es relacionalmente completo
cuando tiene la misma capacidad expresiva que el cálculo
relacional.
</p>
<ul class="org-ul">
<li>El álgebra relacional básica es relacionalmente completa.</li>
</ul>
</div>
</div>

<div id="outline-container-org81e8273" class="outline-2">
<h2 id="org81e8273">Bibliografía</h2>
<div class="outline-text-2" id="text-org81e8273">
<ul class="org-ul">
<li>[ELM16] Fundamentals of Database Systems, 7th Edition. R. Elmasri, S.
Navathe, 2016. Capítulo 8</li>

<li>[SILB10] Database System Concepts, 6th Edition. A. Silberschatz, H. Korth, S.
Sudarshan, 2010. Capítulo 6</li>

<li>[CONN15] Database Systems, a Practical Approach to Design, Implementation and
Management, 6th Edition. T. Connolly, C. Begg, 2015. Capítulo 5</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
Last update: 2020-05-01 11:27
</div>
</body>
</html>
