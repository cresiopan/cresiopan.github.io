<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-01 Fri 11:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
<link rel="stylesheet" type="text/css" href="/home/mk/Documents/blogs/org.css"/>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
<div id="content">
<div id="outline-container-orgf6f0959" class="outline-2">
<h2 id="orgf6f0959">modelo relacional</h2>
<div class="outline-text-2" id="text-orgf6f0959">
<p>
modelo entidad interrelacion
</p>
<ul class="org-ul">
<li>tipo de entidad: tipo o clase de objeto
<ul class="org-ul">
<li><b>restriccion de unicidad</b>
<ul class="org-ul">
<li>cada instancia de tipo de entidad, tiene un subset de atributos que es
unico para dicha instancia/entidad</li>
<li>atributos <span class="underline">clave</span> | indentificadores unicos</li>
<li>dicho subset de atributos clave debe ser minimal, ie no posee un subset
que cumpla con la indentificacion univoca de la entidad</li>
</ul></li>
</ul></li>
<li>atributo: propiedad que describe a la entidad
<ul class="org-ul">
<li>pertenecen a un dominio</li>
<li>compuestos | simples</li>
<li>((multivaluados)) | monovaluados</li>
<li>almacenados | derivados -&#x2014;</li>
</ul></li>
<li>tipo de interrelacion: definicion de conjunto de relaciones entre entidades
<ul class="org-ul">
<li>grado | aridad: cantidad de tipos de entidad que participan de la relacion
<ul class="org-ul">
<li>binario</li>
<li>terciario</li>
<li>n ario</li>
</ul></li>
<li><b>cardinalidad</b>: maxima cant de instancias de cada tipo de entidad pueden
relacionarse con el resto de las instancias de la relacion</li>
<li><b>participacion</b>: cant minima de instancias de un tipo de entidad que se
relaciona con 1 instancia concreta de el otro tipo de entidad
<ul class="org-ul">
<li>total | parcial
<ul class="org-ul">
<li>se requiere de otra instancia al menos, del otro tipo de entidad</li>
</ul></li>
</ul></li>
<li>cardinalidad + participacion = restricciones estructurales</li>
<li>atributos: las interrelaciones pueden tener atributos</li>
<li>clave: las interrelaciones tienen claves. depende de la cardinalidad</li>
</ul></li>
</ul>

<p>
<span class="underline"><span class="underline"><span class="underline"><span class="underline">_</span></span></span></span>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Entidad</td>
</tr>
<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
(atributo)
</p>


<p>
#+BEGIN_SRC
<i>r\ /ela\ \cio</i> \n/ #+END_SRC
</p>


<p>
modelo entidad interrelacion avanzado
</p>

<ul class="org-ul">
<li>entidades fuerte y debiles:
<ul class="org-ul">
<li>debil: un tipo de entidad depende de otro para subsistir
<ul class="org-ul">
<li>clave: se compone de la clave de la entidad indentificadora -&#x2014;
discriminantes</li>
<li>siempre tiene participacion total</li>
</ul></li>
</ul></li>
<li>generalizacion | especializacion: representar relacion de tipo "es un"
auto,avio,tren "es un" vehiculo
<ul class="org-ul">
<li>se heredan atributos y relaciones del padre, pero pueden tener atributos
propios</li>
<li>superposicion: los subtipos pueden ser {disjuntos |
superpuestos}. superpuesto, si una instancia del padre puede
corresponderse a instancias de varios subtipos
<ul class="org-ul">
<li>superpuesta: una persona puede ser alumno y docente a la vez</li>
</ul></li>
<li>completitud: cobertura {total | parcial} del subtipo de entidad a tipos de
entidad padre
<ul class="org-ul">
<li>total: toda persona registrada debe ser alumno o docente</li>
</ul></li>
</ul></li>
<li>union: el tipo de entidad padre es subclase de los subtipos de entidad
<ul class="org-ul">
<li>los identificadores estan en los subtipos de entidad</li>
</ul></li>
</ul>
</div>
</div>



<div id="outline-container-orgd61748a" class="outline-2">
<h2 id="orgd61748a">algebra relacional</h2>
<div class="outline-text-2" id="text-orgd61748a">
<p>
lenguaje procedural: indica el procedimiento a seguir con sus operaciones
</p>

<p>
especifica procedimientos de consulta a partir de operaciones
</p>

<p>
operaciones
</p>
<ul class="org-ul">
<li>seleccion \(\sigma\)</li>
<li>proyeccion \(\pi\)</li>
<li>asignacion \(\leftarrow\)</li>
<li>redenominacion \(\rho\)</li>
<li>union \(\cup\)</li>
<li>interseccion \(\cap\)</li>
<li>diferencia \(-\)</li>
<li>producto cartesiano \(\times\)</li>
<li>junta: producto cartesiano con seleccion
<ul class="org-ul">
<li>natural: los nombres de atributos de las relaciones de la junta son iguales
<ul class="org-ul">
<li>la condicion de la seleccion es por igualdad de valor de los atributos, y
solamente igualdad</li>
</ul></li>
</ul></li>
<li><p>
division: operacion inversa al producto cartesiano
Sean R(A1 A2 &#x2026; An), S(B1 B2 &#x2026; Bm) A = {A1 A2 &#x2026; An}, B{B1 B2 &#x2026; Bm} B
&sub; A Y = A - B
</p>

<p>
\[div(R,S) = T(Y) = {t \in \pi_{Y}(R): \forall s \in S \exists r \in R /
    r[Y] = t \land r[B] = s}\]
</p></li>
</ul>

<p>
\({\sigma, \pi, \rho, \cup, -, \times}\) es un conjunto completo de operadores
</p>
</div>

<div id="outline-container-org8a859e4" class="outline-3">
<h3 id="org8a859e4">extension del algebra relacional</h3>
<div class="outline-text-3" id="text-org8a859e4">
<ul class="org-ul">
<li>proyeccion generalizada</li>
<li>agregacion</li>
<li>junta externa
outer join, evita que se descarten las tuplas que no cumplen con la
condicion de igualdad de los atributos de la junta</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orge7a059a" class="outline-2">
<h2 id="orge7a059a">calculo relacional</h2>
<div class="outline-text-2" id="text-orge7a059a">
<p>
lenguaje declarativo: indica el resultado que se quiere
</p>

<p>
los esquemas de relacion pueden pensarse como predicados
</p>

<p>
logica de predicados
</p>
<ul class="org-ul">
<li>predicados: funciones de variables cuyo resultado es un valor de verdad</li>
<li>operaciones entre predicados: &and;, &or;, &not;, \implies</li>
<li>cuantificadores de variables
<ul class="org-ul">
<li>universal &forall;</li>
<li>existencia &exist;</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgdf63cff" class="outline-3">
<h3 id="orgdf63cff">calculo relacional de tuplas</h3>
<div class="outline-text-3" id="text-orgdf63cff">
<p>
variables representan tuplas
</p>

<p>
nombre de jugadores nacidos antes de 1980
</p>

<p>
{p.name | Player(p) &and; p.date_birth &lt; 1980-01-01}
</p>


<p>
jugadores que hicieron algun gol
</p>

<p>
{p | Player(p) &and; (&exist; s)(Score(s) &and; s.player_id = p.id)}
</p>

<p>
UNA VARIABLE CUANTIFICADA NO PUEDE APARECER DEL LADO IZQUIERDO DEL PIPE "|"
</p>


<p>
jugador mas viejo
</p>

<p>
x {p | Player(p) &and; (&forall; j)(Player(j) &and; p.date_birth &lt;=
j.date_birth)}
</p>

<p>
! {p | Player(p) &and; (&forall; j)(&not; Player(j) &or; p.date_birth &gt;=
j.date_birth)}
</p>




<p>
{c.nombre | Campeones(c) &and; (&forall; t)(&not; Torneos(t) &or; t.tipo_torneo
&ne; "Gand Slam" &or; (&exist; c1)(Campeones(c1) &and; c1.nombre_torneo =
t.nombre_torneo &and; c.nombre_tenista = c1.nombre_tenista))}
</p>


<p>
#+BEGIN_SRC ?
not exists t = forall not t not forall t = exists not t #+END_SRC
</p>
</div>
</div>


<div id="outline-container-org6113248" class="outline-3">
<h3 id="org6113248">calculo relacional de dominios</h3>
<div class="outline-text-3" id="text-org6113248">
<p>
variables representan dominios
</p>

<p>
{x1 &#x2026; xn | p(x1 &#x2026; xn xn+1 &#x2026; xn+m)}
</p>

<p>
p: predicado valido
</p>

<p>
(x1 &#x2026; xn) variables libres
</p>

<p>
(xn+1 &#x2026; xn+m) variables ligadas
</p>


<p>
nombrar a todos los hijos de Abraham Simpson
</p>

<p>
{h n1 | Ed1 Eg1 Ef1 Ed2 En2 Eg2 Ef2 Ep (Persona(d1,n1,g1,f1) and
Persona(d2,n2,g2,f2) and HijoDe(p,h) and n2 = "Abraham Simpson" and p = d2
and h = d1)}
</p>
</div>
</div>
</div>


<div id="outline-container-org67f6831" class="outline-2">
<h2 id="org67f6831"><span class="todo TODO">TODO</span> SQL</h2>
</div>

<div id="outline-container-orge5e4eae" class="outline-2">
<h2 id="orge5e4eae"><span class="todo TODO">TODO</span> diseño relacional</h2>
<div class="outline-text-2" id="text-orge5e4eae">
<p>
preservacion de informacion
</p>

<p>
redundancia minima
</p>

<dl class="org-dl">
<dt>dependencia funcional</dt><dd><p>
X -&gt; Y, con X Y &sub; R restriccion sobre las
posibles tuplas de una relacion R que implica que 2 tuplas con igual
valor del conjunto de atributos X deben tener tambien igual valor del
conjunto de atributos Y
</p>

<p>
\[\forall s,t \in R: s[X]=t[X] \implies s[Y]=t[Y]\]
</p></dd>
</dl>
</div>

<div id="outline-container-orge416bf7" class="outline-3">
<h3 id="orge416bf7">formas normales</h3>
<div class="outline-text-3" id="text-orge416bf7">
<p>
normalizacion:
</p>
<ul class="org-ul">
<li>preservar informacion</li>
<li>eliminar redudancia</li>
<li>evitar las anomalias de abm (alta baja modi)</li>
</ul>
</div>

<div id="outline-container-orgfe37145" class="outline-4">
<h4 id="orgfe37145">1fn</h4>
<div class="outline-text-4" id="text-orgfe37145">
<p>
los dominios de todos los atributos permiten valores atomicos y monovaluados
</p>
</div>
</div>

<div id="outline-container-org08a63a7" class="outline-4">
<h4 id="org08a63a7">2fn</h4>
<div class="outline-text-4" id="text-org08a63a7">
<dl class="org-dl">
<dt>dependencia funcional parcial</dt><dd>PK -&gt; X es una df parcial si X no depende de
la PK completa, sino de una parte solamente.  X -&gt; Y es una df parcial
cuando &exist; A &sub; X, A &ne; X &and; A -&gt; Y</dd>

<dt>dependencia funcional completa</dt><dd>X -&gt; Y es completa sii no es parcial</dd>

<dt>atributo primo de una relacion</dt><dd>atributo que parte de alguna CK de la
relacion</dd>
</dl>

<p>
Una relacion esta en 2fn cuando todos sus atributos no primos tienen df
completa de las claves candidatas
</p>
</div>
</div>

<div id="outline-container-orgec454d0" class="outline-4">
<h4 id="orgec454d0">3fn</h4>
<div class="outline-text-4" id="text-orgec454d0">
<dl class="org-dl">
<dt>descomposicion</dt><dd>dada una relacion R(a1 a2 &#x2026; an) y un set de df F, decimos
que un set de relaciones R1(b11 b12 &#x2026; b1n) &#x2026; Rm(bm1
bm2 &#x2026; bmn) es una descomposicion de R cuando todos los
atributos de R se conservan, ie: \[\cup_{i=1}^{n} A_{i}
                        = \cup_{i=1}^{m} \cup_{j=1}^{n} B_{ij}\]</dd>

<dt>preservacion de informacion</dt><dd>una descomposicion cumple que para toda
instancia de R, la junta de las proyecciones sobre los R<sub>i</sub> permite
recuperar la misma instancia de la relacion</dd>

<dt>preservacion de df</dt><dd>toda df en R puede inferirse a partir de las df
definidas en los R<sub>i</sub></dd>

<dt>descomposicion equivalente</dt><dd>preserva info y df</dd>

<dt>df transitiva en la clave primaria</dt><dd>un atributo no primo tiene df con otro
atributo no primo</dd>

<dt>df transitiva</dt><dd>X -&gt; Y es transitiva cuando &exist; Z : X -&gt; Z &and; Z -&gt; Y,
siendo X-&gt;Y, Z -&gt; Y no triviales y Z -/-&gt; X</dd>
</dl>

<p>
Una relacion esta en 3fn cuando no existen df transitiva CK<sub>i</sub> -&gt; Y de
atributos no primos (Y \nsubset &cup;<sub>i</sub> CK<sub>i</sub>)
</p>

<p>
para toda df no trivial X -&gt; Y, X es superclave o Y contiene solo atributos
primos
</p>

<p>
ningun atributo no primo tiene df con otro atributo no primo
</p>

<p>
Lo siguiente no puede suceder
</p>

<p>
CK -&gt; X -&gt; Y
</p>
<ol class="org-ol">
<li>X no primo</li>
<li>Y no primo</li>
</ol>
</div>
</div>

<div id="outline-container-org0416dbb" class="outline-4">
<h4 id="org0416dbb">fnbc</h4>
<div class="outline-text-4" id="text-org0416dbb">
<p>
no puede haber df transitivas de una CK, inclusive de atributos primos
</p>


<p>
Lo siguiente no puede suceder
</p>

<p>
CK -&gt; X -&gt; Y
</p>
<ol class="org-ol">
<li>Y primo</li>
</ol>

<p>
para toda df no trivial X -&gt; Y, X es superclave
</p>

<p>
fnbc resuelve el problema cuando se tiene una relacion con claves candidatas
que se solapan.
</p>
</div>
</div>

<div id="outline-container-orgb62fef3" class="outline-4">
<h4 id="orgb62fef3">4fn</h4>
<div class="outline-text-4" id="text-orgb62fef3">
<dl class="org-dl">
<dt>dependencia multivaluada</dt><dd><p>
dada la rel R(A), la df multivaluada X -&gt;&gt; Y, es
una restriccion sobre las posibles tuplas de R que: &forall; t1,t2 :
t1[X] = t2[X], deberian existir otras dos tuplas t3,t4 que resulten de
intercambiar los valores de Y rnytr t1 y t2:
</p>

<p>
t3[X] = t4[X] = t1[X] = t2[X] t3[Y] = t1[Y] y t4[Y] = t2[Y] t3[A-(X+Y)]
= t2[A-(X+Y)] y t4[A-(X+Y)] = t1[A-(X+Y)]
</p></dd>
</dl>

<p>
Una rel esta en 4fn cuando para toda df multivaluada no trivial X -&gt;&gt; Y, X
es superclave
</p>

<p>
Se prohiben las df multivaluadas X -&gt;&gt; Y de atribs no primos o que no son
superclave
</p>
</div>
</div>

<div id="outline-container-orge28528c" class="outline-4">
<h4 id="orge28528c">5fn</h4>
<div class="outline-text-4" id="text-orge28528c">
<dl class="org-dl">
<dt>dependencia de junta</dt><dd>dada R(A) , decimos que (X1 X2 &#x2026; Xn) es df de
junta cuando la descomposicion de R en &pi;<sub>X1</sub>(R) &#x2026; &pi;<sub>Xn</sub>(R) es
sin perdida de informacion, ie &pi;<sub>X1</sub>(R) &#x2026; &pi;<sub>Xn</sub>(R) = R</dd>
</dl>

<p>
Una rel R esta en 5fn sii para toda df de junta no trivial todo los X_i son
superclave
</p>
</div>
</div>
</div>

<div id="outline-container-org5487363" class="outline-3">
<h3 id="org5487363">algritmos de normalizacion</h3>
<div class="outline-text-3" id="text-org5487363">
</div>
<div id="outline-container-orga5efdbb" class="outline-4">
<h4 id="orga5efdbb">inferencia de df | axiomas de armstrong</h4>
<div class="outline-text-4" id="text-orga5efdbb">
<dl class="org-dl">
<dt>reflexividad</dt><dd>Y in X =&gt; X -&gt; Y</dd>
<dt>aumento</dt><dd>para todo W: X -&gt; Y =&gt; WX -&gt; WY</dd>
<dt>transitividad</dt><dd>X -&gt; Y y Y -&gt; Z =&gt; X -&gt; Z</dd>
</dl>

<p>
F |= X -&gt; Y significa que la df puede inferirse a partir del conj de df F
</p>

<dl class="org-dl">
<dt>union</dt><dd>X -&gt; Y y X -&gt; Z =&gt; X -&gt; YZ</dd>
<dt>pseudotransitividad</dt><dd>para todo W: X -&gt; Y y YW -&gt; Z =&gt; XW -&gt; Z</dd>
<dt>descomposicion</dt><dd>X -&gt; YZ =&gt; X -&gt; Y y X -&gt; Z</dd>
</dl>
</div>
</div>

<div id="outline-container-org4cb4ef3" class="outline-4">
<h4 id="org4cb4ef3">clausuras</h4>
<div class="outline-text-4" id="text-org4cb4ef3">
<p>
clausura de un conj de df F
</p>

<p>
F* = {X-&gt;Y | F |= X-&gt;Y}
</p>

<p>
todas las df que se pueden inferir de F
</p>

<p>
clausura de un conj de atribs X respecto a F
</p>

<p>
X* = {A | F |= X-&gt;A}
</p>


<p>
dada R(A1 A2 &#x2026; An)
</p>

<p>
el conj de atribs CK es clave candidata sii CK* = A1 A2 &#x2026; An y es minimal
</p>
</div>


<div id="outline-container-org8df35bd" class="outline-5">
<h5 id="org8df35bd">X*</h5>
<div class="outline-text-5" id="text-org8df35bd">
<p>
#+BEGIN_SRC begin X* = X repeat oldX* = X* foreach Y -&gt; Z in F do if Y in
X* then X* += Z end end until oldX* = X* end #+END_SRC
</p>
</div>
</div>
</div>

<div id="outline-container-org31c7470" class="outline-4">
<h4 id="org31c7470">cubrimiento minimal y equivalencia</h4>
<div class="outline-text-4" id="text-org31c7470">
<p>
dadas F y G
</p>

<p>
F cubre a G cuando
</p>

<p>
para toda X -&gt; Y in G: F |= X -&gt; Y
</p>


<p>
F y G son equivalentes cuando F cubre a G y G cubre a F
</p>

<p>
cuando sus clasuras coinciden F* = G*
</p>


<p>
cubrimiento minimal G de F
</p>
<ol class="org-ol">
<li>no hay atribs innecesarios del lado izquierdo
<ul class="org-ul">
<li>para toda X -&gt; Y in G</li>
<li>no existe Z -&gt; Y in G</li>
<li>Z in X</li>
<li>Z <code>/</code> X</li>
</ul></li>
<li>no hay df redundantes
<ul class="org-ul">
<li>no existe X -&gt; Y in G</li>
<li>G - {X -&gt; Y} &equiv; G</li>
</ul></li>
</ol>
</div>

<div id="outline-container-orgbc18c43" class="outline-5">
<h5 id="orgbc18c43">algoritmo</h5>
<div class="outline-text-5" id="text-orgbc18c43">
<ol class="org-ol">
<li>pasar las df a forma canonica</li>
<li>eliminar atrib innecesarios del lado izquierdo de cada df</li>
<li>eliminar las df redundantes</li>
</ol>

<div class="org-src-container">
<pre class="src src-sh">begin <span style="color: #718CA1;">G</span> = F foreach X -&gt; Y<span style="color: #5EC4FF;"> in</span> G do <span style="color: #718CA1;">G</span> -= {X-&gt;Y} <span style="color: #5EC4FF;">foreach</span> A<span style="color: #5EC4FF;"> in</span> Y do <span style="color: #718CA1;">G</span> += {X-&gt;A}
  <span style="color: #5EC4FF;">done</span> done

  <span style="color: #5EC4FF;">foreach</span> X-&gt;A<span style="color: #5EC4FF;"> in</span> G do foreach B<span style="color: #5EC4FF;"> in</span> X do if {G - {X-&gt;A}} + {(X-B) -&gt; A} \equiv G
    <span style="color: #5EC4FF;">then</span> <span style="color: #718CA1;">G</span> = {G - {X-&gt;A}} + {(X-B) -&gt; A} <span style="color: #5EC4FF;">fi</span> done done

  <span style="color: #5EC4FF;">foreach</span> X-&gt;A<span style="color: #5EC4FF;"> in</span> G do if G - {X-&gt;A} \equiv G then <span style="color: #718CA1;">G</span> -= {X-&gt;A} <span style="color: #5EC4FF;">fi</span> done end
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbae3a09" class="outline-4">
<h4 id="orgbae3a09">3fn</h4>
<div class="outline-text-4" id="text-orgbae3a09">
<p>
find all CK
</p>

<p>
find minimal cover G if XB -&gt; A and X -&gt; A in G B is redundant
</p>

<p>
#+BEGIN_SRC sh
begin D = 0 G = cubrimiento minimal para F foreach X | E A (X-&gt;A in G) do
</p>

<p>
done end #+END_SRC
</p>

<p>
<a href="https://www.youtube.com/watch?v=L5R1l2eegtE">https://www.youtube.com/watch?v=L5R1l2eegtE</a>
</p>
</div>
</div>

<div id="outline-container-orgd5adc97" class="outline-4">
<h4 id="orgd5adc97"><span class="todo TODO">TODO</span> CK</h4>
</div>
<div id="outline-container-orgebbfe03" class="outline-4">
<h4 id="orgebbfe03"><span class="todo TODO">TODO</span> fnbc</h4>
</div>
</div>
</div>

<div id="outline-container-orgaf662e2" class="outline-2">
<h2 id="orgaf662e2">concurrencia</h2>
<div class="outline-text-2" id="text-orgaf662e2">
<dl class="org-dl">
<dt>Transaccion</dt><dd>unidad logica de trabajo. secuencia ordenada de instrucciones
que deben ser ejecutada de forma total o no ser ejecutadas</dd>
</dl>

<p>
props acid de transacciones
</p>
<dl class="org-dl">
<dt>atomicidad</dt><dd>ejecucion completa o nada</dd>
<dt>consistencia</dt><dd>consistencia de datos. condiciones que deben verificarse
sobre los datos en todo momento</dd>
<dt>aislamiento</dt><dd>el resultado de la ejec debe ser el mismo que si las ts
fuesen ejecutadas de forma serial</dd>
<dt>durabilidad</dt><dd>persistencia de transacciones completadas</dd>
</dl>
</div>


<div id="outline-container-org2e70c14" class="outline-3">
<h3 id="org2e70c14">anomalias</h3>
<div class="outline-text-3" id="text-org2e70c14">
<p>
dirty read: una T lee item modificado por otra T que se deshace (WR conflict)
</p>

<p>
lost update: una T modifica un item que fue leido antes por otra T que aun no
terminó. (y la 1ra modifica el item despues) (RW WW confl)
</p>

<p>
unrepeatabla read: la primer T vuelve a leer un item luego de que la 2da T
modifico el item (RW WR confl)
</p>

<p>
dirty write: una T escribe un item que fue escrito por otra T que aborta (WW)
</p>

<p>
phantom: una T realiza varias operaciones con muchos items, y estos items son
modificados/creados/eliminados por otras Ts al mismo tiempo
</p>
</div>
</div>

<div id="outline-container-orgcd18923" class="outline-3">
<h3 id="orgcd18923">serializabilidad</h3>
<div class="outline-text-3" id="text-orgcd18923">
<p>
el resultado de la ejecucion es igual al resultado de una ejecucion serial
</p>
</div>

<div id="outline-container-org41d4d89" class="outline-4">
<h4 id="org41d4d89">equiv por conflictos</h4>
<div class="outline-text-4" id="text-org41d4d89">
<dl class="org-dl">
<dt>conflicto</dt><dd>par de instrucciones ejecutadas por 2 Ts distintas sobre un mismo
item. una de ellas es una instruccion de escritura</dd>
</dl>

<p>
grafo de precedencias
</p>

<p>
si no tiene ciclos, el orden de ejecucion es serializable por conflictos
</p>

<p>
ordenamiento topologico
</p>

<p>
para todo arco x,y, el nodo x precede al nodo y
</p>
</div>
</div>

<div id="outline-container-orge6e3002" class="outline-4">
<h4 id="orge6e3002">control de concurrencia</h4>
<div class="outline-text-4" id="text-orge6e3002">
</div>
<div id="outline-container-orgd516ece" class="outline-5">
<h5 id="orgd516ece">locks</h5>
<div class="outline-text-5" id="text-orgd516ece">
<p>
bloquean a los recursos y no permiten que mas de una T los use de forma
simultanea
</p>

<p>
variables asociadas a recursos y permiten regular el acceso a ellos
</p>

<p>
exclusion mutua
</p>
</div>


<div id="outline-container-orgc84f703" class="outline-6">
<h6 id="orgc84f703">2pl</h6>
<div class="outline-text-6" id="text-orgc84f703">
<p>
una T no puede adquirir un lock luego de haber liberado un lock que
adquirio
</p>

<p>
el protocolo es condicion suficiente para garantizar que cualquier orden
de ejecucion sea serializable
</p>


<dl class="org-dl">
<dt>deadlock</dt><dd>condicion en la un set de Ts quedan bloqueadas a la  espera de
recursos que otra de ellas posee</dd>
</dl>

<p>
prevencion de deadlock
</p>
<ol class="org-ol">
<li>adquirir los locks de recursos que se van a utilizar, antes de comenzar con
la 1er instruccion</li>
<li>definir un ordenamiento de los items y que todas las Ts respeten dicho orden</li>
<li>metodos basados en timestamps</li>
</ol>

<p>
deteccion de deadlock
</p>
<ol class="org-ol">
<li>grafo de alocacion de recursos</li>
<li>definir un timeout para la adquisicion del lock. despues del cual se aborta
la T</li>

<li value="inanicion">cuando una T no logra ejecutarse por un periodo de tiempo
indefinido. starvation</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orga75a407" class="outline-5">
<h5 id="orga75a407">multiversion mvcc</h5>
<div class="outline-text-5" id="text-orga75a407">
<p>
cada T ve un snapshot del la bdd al instante de su inicio
</p>

<ol class="org-ol">
<li>mayor solapamiento</li>
<li>requiere de mas recursos</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-org5526d95" class="outline-3">
<h3 id="org5526d95">recuperabilidad</h3>
<div class="outline-text-3" id="text-org5526d95">
<dl class="org-dl">
<dt>recuperable</dt><dd>sii ninguna T <span class="underline">T</span> realiza el commit hasta todas las T que
escribieron antes de <span class="underline">T</span> los leyera hayan commiteado</dd>
</dl>

<p>
para un solapamiento recuperable puede ser necesario abortar una T antes de
llegado su commit
</p>

<p>
para evitar rollbacks en cascada es necesario que una T no lea valores que
aun no fueron commiteados
</p>

<p>
quedan prohibidos los conflictos WT1 RT2 sin que en el medio exista un commit
de T1.
</p>
</div>

<div id="outline-container-orgb1bc004" class="outline-4">
<h4 id="orgb1bc004">s2pl</h4>
<div class="outline-text-4" id="text-orgb1bc004">
<p>
una T no puede adquirir un lock luego de haber liberado un lock que
adquirio, y ademas los locks de Write solo pueden ser liberados despues de
haber commiteado la transaccion
</p>
</div>
</div>

<div id="outline-container-orgb362bed" class="outline-4">
<h4 id="orgb362bed">r2pl</h4>
<div class="outline-text-4" id="text-orgb362bed">
<p>
los locks solo pueden ser liberados despues del commit (si no se diferencian
los tipos de lock en Read y Write)
</p>


<p>
s2pl y r2pl garantizan serializabilidad y recuperabilidad y que no se
produce una cascada de rollbacks al deshacer una T
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfdcb986" class="outline-2">
<h2 id="orgfdcb986"><span class="todo TODO">TODO</span> nosql</h2>
<div class="outline-text-2" id="text-orgfdcb986">
<p>
necesidades:
</p>
<ol class="org-ol">
<li>mayor escalabilidad para trabajar con grandes volumenes de datos</li>
<li>mayor performance en aplicaciones web</li>
<li>mayor flexibilidad sobre estructuras de datos (evolucion de los datos)</li>
<li>mayor capacidad de distribucion (disponibilidad, tolerancia a fallas,
replicacion, fragmentacion, procesamiento distribuido)</li>
</ol>
</div>

<div id="outline-container-orgca6fefb" class="outline-3">
<h3 id="orgca6fefb">distribucion</h3>
<div class="outline-text-3" id="text-orgca6fefb">
<p>
aumentar la capacidad de procesamiento y de almacenar info
</p>

<p>
sgdb distribuido: distrib en distintas compus en una red
</p>
</div>

<div id="outline-container-orgaab2509" class="outline-4">
<h4 id="orgaab2509">fragmentacion</h4>
<div class="outline-text-4" id="text-orgaab2509">
<p>
dividir los datos de una tabla entre un conjunto de nodos
</p>

<p>
para:
</p>
<ul class="org-ul">
<li>almacenar conjuntos grandes de datos que no entran en un nodo</li>
<li>paralelizar el procesamiento, para luego integrar los resultados</li>
</ul>
</div>

<div id="outline-container-org6e5b540" class="outline-5">
<h5 id="org6e5b540">horizontal</h5>
<div class="outline-text-5" id="text-org6e5b540">
<p>
las filas de cada tabla se reparten entre los nodos
</p>

<p>
cada nodo almacena un subset de filas
</p>
</div>
</div>

<div id="outline-container-org60e68ed" class="outline-5">
<h5 id="org60e68ed">vertical</h5>
<div class="outline-text-5" id="text-org60e68ed">
<p>
distintos nodos guardan un subconjunto de las columnas de la tabla. todos
comparten las columnas de la clave primaria
</p>
</div>
</div>
</div>

<div id="outline-container-orgf98188d" class="outline-4">
<h4 id="orgf98188d">replicacion</h4>
<div class="outline-text-4" id="text-orgf98188d">
<p>
proceso por el cual se almacenan multiples copias de un mismo dato en
distintos nodos del sistema
</p>

<p>
ventajas:
</p>
<ul class="org-ul">
<li>mecanismo de backup, recuperacion ante fallas</li>
<li>repartir la carga de procesamiento</li>
<li>garantizar cierta disponibilidad del sistema en caso de caida de algunos nodos</li>
</ul>

<p>
primaria: puede realizar procesamiento sobre los datos secundaria: solo
funciona de backup
</p>
</div>
</div>

<div id="outline-container-orga8014e1" class="outline-4">
<h4 id="orga8014e1">tablas de hash distribuidas</h4>
</div>

<div id="outline-container-org6de971d" class="outline-4">
<h4 id="org6de971d">modelos de consistencia</h4>
<div class="outline-text-4" id="text-org6de971d">
</div>
<div id="outline-container-orga040c15" class="outline-5">
<h5 id="orga040c15">consistencia secuencial</h5>
<div class="outline-text-5" id="text-orga040c15">
<p>
cuando el resultado de cualquier ejec concurrente de los procesos es equiv
al de alguna ejec secuencial
</p>

<p>
(ie la instruccion no comienza hasta que no terminado de aplicarse en todas
las replicas)
</p>
</div>
</div>

<div id="outline-container-orgea4a764" class="outline-5">
<h5 id="orgea4a764">causal</h5>
<div class="outline-text-5" id="text-orgea4a764">
<p>
capturar eventos que pueden estar causalmente relacionados
</p>

<p>
dos Write que estan potencialmente causalmente relacionadas deben ser
vistas por todos en el mismo orden
</p>
</div>
</div>

<div id="outline-container-orgba86eee" class="outline-5">
<h5 id="orgba86eee">eventual</h5>
<div class="outline-text-5" id="text-orgba86eee">
<p>
la mayoria de los procesos lee.
</p>

<p>
si en el sistema no se producen modificaciones por un tiempo
suficientemente grande, entonces eventualmente todos los procesos veran los
mismos valores
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org3f97acb" class="outline-3">
<h3 id="org3f97acb">clasificacion</h3>
<div class="outline-text-3" id="text-org3f97acb">
</div>
<div id="outline-container-orgdf30064" class="outline-4">
<h4 id="orgdf30064">clave valor</h4>
<div class="outline-text-4" id="text-orgdf30064">
<p>
almacenan vectores asociativos o diccionarios, colleciones formadas por
pares de elementos de forma (key, value)
</p>

<ul class="org-ul">
<li>berkeley DB</li>
<li>dynamo</li>
<li>redis</li>
</ul>

<p>
operaciones:
</p>
<ul class="org-ul">
<li>put</li>
<li>delete</li>
<li>update</li>
<li>get</li>
</ul>

<p>
ventaja:
</p>
<ul class="org-ul">
<li>simplicidad
<ul class="org-ul">
<li>guardar y consultar grandes cants de datos, pero no de interrelaciones entre
datos</li>
</ul></li>
<li>velocidad (prioriza eficiencia de acceso sobre integridad)</li>
<li>escalabilidad (proveen replicacion y procesamiento distribuido)</li>
</ul>
</div>

<div id="outline-container-org55bcd50" class="outline-5">
<h5 id="org55bcd50"><span class="todo TODO">TODO</span> dynamo</h5>
</div>
</div>

<div id="outline-container-orgadfa5c3" class="outline-4">
<h4 id="orgadfa5c3">wide column</h4>
<div class="outline-text-4" id="text-orgadfa5c3">
<p>
permiten agrupar pares clave/valor vinculados a una misma entidad como
columnas asociadas a una misma clave primaria
</p>

<p>
un valor particular de la clave primaria junto con las columnas asociadas a
el forman una fila de la bdd
</p>

<p>
permiten agregar columnas en forma dinamica a una fila
</p>

<p>
un cliente que va comprando libros
</p>
</div>

<div id="outline-container-org69ad8de" class="outline-5">
<h5 id="org69ad8de">cassandra</h5>
<div class="outline-text-5" id="text-org69ad8de">
<p>
clave primaria = clave de particion + clave de clustering
</p>

<p>
atributo estatico
</p>
</div>
</div>
</div>

<div id="outline-container-org9e96f09" class="outline-4">
<h4 id="org9e96f09">orientadas a documentos</h4>
</div>



<div id="outline-container-org19cf790" class="outline-4">
<h4 id="org19cf790">basadas en grafos</h4>
</div>
</div>
</div>

<div id="outline-container-orgdd71096" class="outline-2">
<h2 id="orgdd71096">procesamiento de consultas</h2>
<div class="outline-text-2" id="text-orgdd71096">
<dl class="org-dl">
<dt>indices</dt><dd>estructura de busqueda que agilizan la busquedade registros a
partir del valor del conj de atributos
<dl class="org-dl">
<dt>primario</dt><dd>el indice se construye sobre el campo de
ordenamiento clave de un archivo ordenado</dd>
<dt>de clustering</dt><dd>el indice se construye sobre el campo de
ordenamiento fisico de un archivo y el campo
no es clave</dd>
<dt>secundario</dt><dd>el indice se construye sobre campos que no son
los campos de ordenamiento del archivo</dd>
</dl></dd>
</dl>
</div>
<div id="outline-container-org5564dd2" class="outline-3">
<h3 id="org5564dd2">costos</h3>
<div class="outline-text-3" id="text-org5564dd2">
</div>
<div id="outline-container-orgef9cd4c" class="outline-4">
<h4 id="orgef9cd4c">seleccion</h4>
<div class="outline-text-4" id="text-orgef9cd4c">
</div>
<div id="outline-container-org182b5dc" class="outline-5">
<h5 id="org182b5dc">file scan</h5>
<div class="outline-text-5" id="text-org182b5dc">
<p>
cost(&sigma;(R)) = B(R)
</p>
</div>
</div>

<div id="outline-container-orgcf2736d" class="outline-5">
<h5 id="orgcf2736d">index scan</h5>
<div class="outline-text-5" id="text-orgcf2736d">
<ul class="org-ul">
<li>indice primario
<dl class="org-dl">
<dt>Arbol</dt><dd>\(cost(\sigma(R)) = Height(I(A,R)) + 1\)</dd>
<dt>Hash</dt><dd>\(cost(\sigma(R)) = 1\)</dd>
</dl></li>
<li>indice de clustering
<dl class="org-dl">
<dt>Arbol</dt><dd>\(cost(\sigma(R)) = Height(I(A,R)) +
                  \ceil{\frac{n(R)}{V(A,R)F(R)}}\)</dd>
</dl></li>
<li>indice secundario
<dl class="org-dl">
<dt>Arbol</dt><dd>\(cost(\sigma(R)) = Height(I(A,R)) + \frac{n(R)}{V(A,R)}\)</dd>
</dl></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org7257dcc" class="outline-4">
<h4 id="org7257dcc">proyeccion</h4>
<div class="outline-text-4" id="text-org7257dcc">
<p>
\(\pi_{X}(R)\)
</p>
<ul class="org-ul">
<li>X es superclave
<ul class="org-ul">
<li>\(cost(\pi_{X}(R)) = B(R)\)</li>
</ul></li>
<li>X no es superclave
<dl class="org-dl">
<dt>sort externo</dt><dd>\(cost(\pi_{X}(R)) = B(R) + 2B(R)log_{2}(B(R))\)</dd>
<dt>(no term)</dt><dd>hashing
<dl class="org-dl">
<dt>en memoria</dt><dd>\(cost(\pi_{X}(R)) = B(R)\)</dd>
<dt>externo</dt><dd>\(cost(\pi_{X}(R)) = 3B(R)\)</dd>
</dl></dd>
</dl></li>
</ul>
</div>
</div>

<div id="outline-container-orgc1a5d5e" class="outline-4">
<h4 id="orgc1a5d5e">junta</h4>
<div class="outline-text-4" id="text-orgc1a5d5e">
</div>
<div id="outline-container-orgb5aa3f1" class="outline-5">
<h5 id="orgb5aa3f1">loop anidados por bloque</h5>
<div class="outline-text-5" id="text-orgb5aa3f1">
<p>
\(cost(R*S) = min(B(R)(1+B(S)),B(S)(1+B(R)))\)
</p>

<p>
\(cost(R*S) = B(R) + B(S)\)
</p>
</div>
</div>

<div id="outline-container-orgac31368" class="outline-5">
<h5 id="orgac31368">unico loop</h5>
<div class="outline-text-5" id="text-orgac31368">
<dl class="org-dl">
<dt>indice primario</dt><dd>\(cost(R*S) = B(S) + n(S) \left(Height(I(A,R)) + 1 \right)\)</dd>
<dt>indice de clustering</dt><dd>\(cost(R*S) = B(S) + n(S) \left(Height(I(A,R)) +
          \ceil{\frac{n(R)}{V(A,R)F(R)}}\right)\)</dd>
<dt>indice secundario</dt><dd>\(cost(R*S) = B(S) + n(S) \left(Height(I(A,R)) +
          \frac{n(R)}{V(A,R)}\right)\)</dd>
</dl>
</div>
</div>

<div id="outline-container-org8ef1686" class="outline-5">
<h5 id="org8ef1686">sort-merge</h5>
<div class="outline-text-5" id="text-org8ef1686">
<ol class="org-ol">
<li>ordenar los archivos de cada tabla por los atributos de la junta</li>
<li>hacer un merge de los archivos</li>
</ol>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">en memoria</td>
<td class="org-left">sort externo</td>
</tr>

<tr>
<td class="org-left">B(S)</td>
<td class="org-left">2B(S)log<sub>2</sub>(B(S))</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">merge</td>
</tr>

<tr>
<td class="org-left">B(S)</td>
</tr>
</tbody>
</table>

<p>
\(cost(R*S) = B(R)+ B(S) + 2B(R)log_{2}(B(R)) + 2B(S)log_{2}(B(S))\)
</p>
</div>
</div>

<div id="outline-container-org62a14d2" class="outline-5">
<h5 id="org62a14d2">junta hash grace</h5>
<div class="outline-text-5" id="text-org62a14d2">
<ol class="org-ol">
<li>particionar las tablas en m grupos usando una f de hash aplicada sobre los
atributos de la junta \(cost(R*S) = 2(B(R)+ B(S))\)</li>
<li>combinar cada par de grupos de cada tabla, viendo si se cumple la condicion
de junta</li>
</ol>

<p>
\(cost(R*S) = 3(B(R)+ B(S))\)
</p>
</div>
</div>
</div>

<div id="outline-container-org649aff3" class="outline-4">
<h4 id="org649aff3">pipelining</h4>
<div class="outline-text-4" id="text-org649aff3">
<p>
si el costo de una operacion siguiente es menor a la anterior, no agrega el
costo al plan de ejecucion
</p>
</div>
</div>
</div>


<div id="outline-container-org61fa919" class="outline-3">
<h3 id="org61fa919"><span class="todo TODO">TODO</span> estimacion de cardinalidad (falta histograma)</h3>
<div class="outline-text-3" id="text-org61fa919">
</div>
<div id="outline-container-org291bde2" class="outline-4">
<h4 id="org291bde2">proyeccion</h4>
</div>

<div id="outline-container-org888a7b0" class="outline-4">
<h4 id="org888a7b0">seleccion</h4>
<div class="outline-text-4" id="text-org888a7b0">
<p>
\(n(\sigma_{A}(R)) = \frac{n(R)}{V(A,R)}\) (selectividad de A en R)
</p>
</div>
</div>

<div id="outline-container-orgb4a62ad" class="outline-4">
<h4 id="orgb4a62ad">junta</h4>
<div class="outline-text-4" id="text-orgb4a62ad">
<p>
\(n(R*S) = \frac{n(R)n(S)}{max(V(A,R),V(A,S))}\)
</p>

<p>
\(F(R*S) \geq \left(\frac{1}{F(R)}+\frac{1}{F(S)}\right)^{-1}\)
</p>

<p>
\(B(R*S) = \frac{B(R)B(S)(F(R)+F(S))}{max(V(A,R),V(A,S))}\)
</p>
</div>
</div>
</div>

<div id="outline-container-org7b9968e" class="outline-3">
<h3 id="org7b9968e">heuristicas de optimizacion</h3>
<div class="outline-text-3" id="text-org7b9968e">
<ol class="org-ol">
<li>selecciones lo mas temprano posible</li>
<li>reemplazar prod cart por juntas</li>
<li>proyectar para descartar atributos no utilzados</li>
<li>relizar la junta mas restrictiva primero, en caso de haber varias</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org56059e9" class="outline-2">
<h2 id="org56059e9">geograficas</h2>
<div class="outline-text-2" id="text-org56059e9">
</div>
<div id="outline-container-org6322b6d" class="outline-3">
<h3 id="org6322b6d">simple features</h3>
<div class="outline-text-3" id="text-org6322b6d">
<ul class="org-ul">
<li>geometrias: puntos, lineas, poligonos</li>
<li>metodos basicos: asociados al objeto geometrico, area, perimetro</li>
<li>predicados de relacion: metodos que verifican una relacion entre objetos,
interseccion</li>
<li>metodo de analisis espacial: permiten operar a objetos con otros,
interseccion, union</li>
</ul>
</div>
</div>

<div id="outline-container-org5a85f2c" class="outline-3">
<h3 id="org5a85f2c">indexado de datos espaciales</h3>
<div class="outline-text-3" id="text-org5a85f2c">
<p>
buscar y combinar objetos de manera eficiente
</p>

<p>
ventajas y desventajas
</p>
<ul class="org-ul">
<li>tipos de objetos geometricos que se pueden almacenar</li>
<li>tipo de consulta que se pueden resolver</li>
<li>la complejudad de operaciones de insercion y eliminacion</li>
</ul>
</div>

<div id="outline-container-org4bb20e8" class="outline-4">
<h4 id="org4bb20e8">kd-trees</h4>
<div class="outline-text-4" id="text-org4bb20e8">
<p>
cada nodo no hoja esta asociado a un punto del set de datos y una dimension
</p>

<p>
divide el espacio en 2
</p>

<p>
los nodos hoja estan asociados directamente a un punto del set de datos
</p>

<ul class="org-ul">
<li>busqueda por rango</li>
<li>busqueda del vecino mas cercano</li>
</ul>
</div>
</div>

<div id="outline-container-org3029b49" class="outline-4">
<h4 id="org3029b49">R-trees</h4>
<div class="outline-text-4" id="text-org3029b49">
<p>
indexado de objetos geometricos a traves de minimum bounding rectangle
</p>

<p>
ortoedro k dimensional que contiene al objeto
</p>

<p>
se puede representar con 2 puntos k dimensionales
</p>

<p>
las hojas estan asociadas a MBRs de objetos
</p>

<p>
los nodos no hoja estan asociados a a MBR que contienen a todos los MBR de
sus hijos
</p>

<p>
pude haber solapamiento entre MBR
</p>

<p>
son arboles balanceados
</p>

<ul class="org-ul">
<li>busquedas de pertenencia (que poligonos contienen un punto x?)</li>
<li>busqueda de interseccion (que poligonos intersecta con un poligono x?)</li>
</ul>

<p>
juntas espaciales
</p>
</div>
</div>

<div id="outline-container-org5daa24b" class="outline-4">
<h4 id="org5daa24b">quad-trees</h4>
<div class="outline-text-4" id="text-org5daa24b">
<p>
el espacio es descompuesto en cuadrantes disjuntos
</p>

<p>
cuando un cuadrante llega al maximo de capacidad de cantidad de objs, se
particiona en 4
</p>

<p>
indexa puntos geometricos o datos raster en 2 dimensiones
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb4a5334" class="outline-2">
<h2 id="orgb4a5334">seguridad</h2>
<div class="outline-text-2" id="text-orgb4a5334">
<p>
seguridad de la info: {} de procedimientos y medidas tomadas para proteger los
componentes de sistemas de info
</p>
</div>

<div id="outline-container-org64ead1b" class="outline-3">
<h3 id="org64ead1b">rbac (control de accesos basado en roles)</h3>
<div class="outline-text-3" id="text-org64ead1b">
</div>
<div id="outline-container-org84a85a0" class="outline-4">
<h4 id="org84a85a0">DAC (discretionary access control)</h4>
<div class="outline-text-4" id="text-org84a85a0">
<p>
un obj solo puede ser accedido por el usu o grup al que pertenece.  existe
el concepto de owner que puede permitir el acceso al recurso a otro usu o
grup (unix)
</p>
</div>
</div>

<div id="outline-container-org49a9ce7" class="outline-4">
<h4 id="org49a9ce7">MAC (mandatory access control)</h4>
<div class="outline-text-4" id="text-org49a9ce7">
<p>
control de acceso es determinado por el sistema. se establecen relaciones
entre usus y objs (se asignan niveles). (dod)
</p>
</div>
</div>

<div id="outline-container-orgd1f4bbe" class="outline-4">
<h4 id="orgd1f4bbe">RBAC</h4>
<div class="outline-text-4" id="text-orgd1f4bbe">
<p>
evolucion de DAC
</p>

<p>
se definen roles para distintas actividades y funciones desarrolladas por
miembros de una orga. para regular el acceso de usuarios a los recursos
</p>

<ul class="org-ul">
<li>usuarios: personas</li>
<li>roles: funciones y responsabilidades</li>
<li>objs: a ser protegido</li>
<li>operaciones: acciones que pueden realizarse sobre los objetos</li>
<li>permisos: acciones concedidas o revocada a un usuario o rol sobre un obj</li>
</ul>

<p>
jerarquia de roles - ppios de seguridad
</p>
<ol class="org-ol">
<li>criterio de menor privilegio posible: si un usu no va a realizar una operacion, no debe
tener permisos para realizarla</li>
<li>division de responsabilidades: que nadie tenga permisos suficientes para
utilizar el sistema en benficio propio. para completar tareas sensibles,
deben participar roles mutuamente excluyentes</li>
<li>abstraccion de datos: los permisos son abstractos. las operaciones permitidas
/ prohibidas dependen de las propiedades del objeto</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbf76b80" class="outline-2">
<h2 id="orgbf76b80">recuperacion</h2>
<div class="outline-text-2" id="text-orgbf76b80">
<p>
fallas
</p>
<ul class="org-ul">
<li>de sistema: soft o hard que detienen la ejec del prog</li>
<li>de aplicacion: soft que utiliza la bdd</li>
<li>de dispositivo: daño fisico al hard</li>
<li>naturales externas: terremotos, etc</li>
</ul>


<p>
actualizacion
</p>
<ul class="org-ul">
<li>inmediata: los datos se guardan en disco antes del commit de la T</li>
<li>diferida: luego del commit</li>
</ul>
</div>


<div id="outline-container-org9a09043" class="outline-3">
<h3 id="org9a09043">gestor de recuperacion</h3>
<div class="outline-text-3" id="text-org9a09043">
<p>
reglas:
</p>
<ul class="org-ul">
<li>WAL (Write Ahead Log): antes de modificar el disco, modificar el log en
disco</li>
<li>FLC (Force Log at Commit): antes del commit en el log, volcar el log a
disco</li>
</ul>
</div>
</div>

<div id="outline-container-orgb1d6e73" class="outline-3">
<h3 id="orgb1d6e73">algoritmos</h3>
<div class="outline-text-3" id="text-orgb1d6e73">
</div>
<div id="outline-container-org59c18b7" class="outline-4">
<h4 id="org59c18b7">undo</h4>
<div class="outline-text-4" id="text-org59c18b7">
<p>
todo vOld asignado por una T que ya commiteo, debe ser guardado en log en
disco, antes de que la modificacion por otra T, sea guardada en disco.
</p>

<ol class="org-ol">
<li>T modifica X, vOld por v, escribe (WRITE T X vOld) en log en disco</li>
<li>registrar y flushear el WRITE en log antes de flushear el nuevo valor en
disco <code>WAL</code></li>
<li>todo item modificado debe ser guardado en disco antes del commit</li>
<li>cuando T hace commit, escribir (COMMIT T) en log en disco <code>FLC</code></li>
</ol>

<p>
reinicio
</p>
<ol class="org-ol">
<li>recorrer log de adelante hacia atras</li>
<li>por cada T que no commiteo, aplicar su WRITE (que escribe el valor
anterior)</li>
<li>por cada T que no commiteo, escribir ABORT T en log en disco</li>
</ol>
</div>
</div>

<div id="outline-container-org8d80623" class="outline-4">
<h4 id="org8d80623">redo</h4>
<div class="outline-text-4" id="text-org8d80623">
<p>
antes de realizar el commit, el valor nuevo v asignado por T debe ser
guardado en log en disco
</p>

<ol class="org-ol">
<li>cuando T modifica X, vOld por v, escribe (WRITE T X v) en log</li>
<li>T hace commit, escribir (COMMIT T) en log en disco</li>
<li>escribir el nuevo valor en disco</li>
</ol>

<p>
reinicio
</p>
<ol class="org-ol">
<li>analizar cuales son las T con commit</li>
<li>recorrer el log de atras hacia adelante, aplicar los WRITE de las T que
commitearon</li>
<li>por cada T que no commiteo, abortarla (ABORT en log en disco)</li>
</ol>
</div>
</div>

<div id="outline-container-org70a4d75" class="outline-4">
<h4 id="org70a4d75">undo/redo</h4>
<div class="outline-text-4" id="text-org70a4d75">
<ol class="org-ol">
<li>T modifica X, vOld por v, escribe (WRITE T X vOld v) en log</li>
<li>flushear log antes de escribir el nuevo valor v en disco</li>
<li>T hace commit, escribir (COMMIT T) en log en disco</li>
<li>se puede escribir en disco antes o despues del commit</li>
</ol>

<p>
reinicio
</p>
<ol class="org-ol">
<li>recorrer el log de adelante hacia atras</li>
<li>por cada T sin commit, aplicar cada WRITE escribiendo vOld en disco</li>
<li>recorrer el log de atras hacia adelante</li>
<li>por cada T con commit, aplicar cada WRITE escribiendo v en disco</li>
<li>por cada T sin commit, escribir (ABORT T) en log en disco</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgb7c2354" class="outline-3">
<h3 id="orgb7c2354">checkpointing</h3>
<div class="outline-text-3" id="text-orgb7c2354">
<p>
para evitar el retroceso hasta el inicio del sistema
</p>

<p>
registro en log que indica que los items modificados hasta ese punto fueron
almacenados en disco
</p>

<p>
inactivo: usa un registro (CKPT). suspende todas las Ts para volcar todos los
buffers a memoria
</p>

<p>
activo: usa 2 registros, para no suspender por mucho tiempo la ejecucion
</p>
</div>

<div id="outline-container-orgeee47ac" class="outline-4">
<h4 id="orgeee47ac">undo</h4>
<div class="outline-text-4" id="text-orgeee47ac">
</div>
<div id="outline-container-org3356e9b" class="outline-5">
<h5 id="org3356e9b">inactivo</h5>
<div class="outline-text-5" id="text-org3356e9b">
<ol class="org-ol">
<li>dejar de hacer nuevas Ts</li>
<li>esperar a que todas hagan commit (en log en disco)</li>
<li>escribir (CKPT) en log en disco</li>
</ol>

<p>
reinicio
</p>
<ol class="org-ol">
<li>deshacer las Ts sin commit hasta encontrar el (CKPT)</li>
</ol>
</div>
</div>

<div id="outline-container-orgdb10092" class="outline-5">
<h5 id="orgdb10092">activo</h5>
<div class="outline-text-5" id="text-orgdb10092">
<ol class="org-ol">
<li>escribir (BEGIN CKPT t) donde t es una lista de las Ts activas hasta el
momento (en log en disco)</li>
<li>esperar a que todas las activas hagan commit</li>
<li>escribir (END CKPT) en log en disco</li>
</ol>

<p>
reinicio a. encontrar 1ro un END CKPT
</p>
<ol class="org-ol">
<li>retroceder hasta el BEGIN CKPT y hacer UNDO</li>
</ol>
<p>
b. encontrar 1ro un BEGIN CKPT [t]
</p>
<ol class="org-ol">
<li>el sistema cayo sin asegurar commits de [t]</li>
<li>volver a hasta el begin de la T de [t] mas vieja</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orge5ba792" class="outline-4">
<h4 id="orge5ba792">redo</h4>
<div class="outline-text-4" id="text-orge5ba792">
</div>
<div id="outline-container-org5690c80" class="outline-5">
<h5 id="org5690c80">activo</h5>
<div class="outline-text-5" id="text-org5690c80">
<ol class="org-ol">
<li>escribir (BEGIN CKPT [t]) en log en disco</li>
<li>volcar a disco los items que fueron modificados por Ts que commitearon</li>
<li>escribir (END CKPT) en log en disco</li>
</ol>

<p>
reinicio
</p>
<ul class="org-ul">
<li>encontrar 1ro (END CKPT)
<ol class="org-ol">
<li>retroceder hasta (BEGIN T) de la T mas antigua de [t]</li>
<li>rehacer las Ts que commitearon</li>
<li>escribir ABORT T, para las T que no commitearon</li>
</ol></li>
<li>(BEGIN CKPT)
<ol class="org-ol">
<li>buscar el CKPT anterior en el log</li>
</ol></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf5b7696" class="outline-4">
<h4 id="orgf5b7696">undo redo</h4>
<div class="outline-text-4" id="text-orgf5b7696">
</div>
<div id="outline-container-org43d639b" class="outline-5">
<h5 id="org43d639b">activo</h5>
<div class="outline-text-5" id="text-org43d639b">
<ol class="org-ol">
<li>escribir (BEGIN CKPT [t]) en log en disco</li>
<li>volcar a disco los items modificados <span class="underline">antes</span> del BEGIN CKPT</li>
<li>escribir (END CKPT) en el log en disco</li>
</ol>

<p>
reinicio
</p>
<ol class="org-ol">
<li>retroceder hasta la T mas antigua de [t] para deshacerla si no commiteo</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgc5408b2" class="outline-4">
<h4 id="orgc5408b2">resumen</h4>
<div class="outline-text-4" id="text-orgc5408b2">
<p>
En el algoritmo UNDO, escribimos el (END CKPT) cuando todas las
transacciones del listado de transacciones activas hayan hecho commit.
</p>

<p>
Para el algoritmo REDO, escribimos (END CKPT) cuando todos los ítems
modificados por transacciones que ya habían commiteado al momento del (BEGIN
CKPT) hayan sido salvaguardadas en disco.
</p>

<p>
En el UNDO/REDO escribimos (END CKPT) cuando todos los ítems modificados
antes del (BEGIN CKPT) hayan sido guardados en disco.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcfb58ec" class="outline-2">
<h2 id="orgcfb58ec">datawarehousing</h2>
<div class="outline-text-2" id="text-orgcfb58ec">
</div>
<div id="outline-container-org8895df6" class="outline-3">
<h3 id="org8895df6">oltp online transaction processing</h3>
<div class="outline-text-3" id="text-org8895df6">
<p>
capacidad de procesar Ts en linea en forma concurrente entre gran cant de
usuarios y de forma escalable es OLTP
</p>
</div>
</div>

<div id="outline-container-org9f8241e" class="outline-3">
<h3 id="org9f8241e">olap online analitical processing</h3>
<div class="outline-text-3" id="text-org9f8241e">
<p>
capacidad analitica
</p>
<ul class="org-ul">
<li>reducir la cant de datos</li>
<li>expresar consultas mas complejas</li>
</ul>

<p>
para extraer info de datos almacenados que sirva de soporte para la toma de
decisiones
</p>

<p>
12 reglas olap - servicios que se deben brindar
</p>
<ul class="org-ul">
<li>vista conceptual multidim: datos en una matriz que cada dim representa un
atributo</li>
<li>manipulacion intuitiva de datos: diseño de vista conceptual a traves de
interfaz amigable</li>
<li>accesibilidad: homogeneizar datos que provienen de varias fuentes</li>
<li>extraccion batch e interpretativa:</li>
<li>modelos de analisis</li>
<li>arq cliente servidor</li>
</ul>
</div>
</div>

<div id="outline-container-org725af06" class="outline-3">
<h3 id="org725af06">datawarehouse</h3>
<div class="outline-text-3" id="text-org725af06">
<p>
copia paralela de las bdd ppales de la orga donde se ejecutan las
aplicaciones OLAP
</p>
</div>

<div id="outline-container-orge6e46c5" class="outline-4">
<h4 id="orge6e46c5">modelo dimensional</h4>
<div class="outline-text-4" id="text-orge6e46c5">
</div>
<div id="outline-container-org1eecc7d" class="outline-5">
<h5 id="org1eecc7d">modelo conceptual</h5>
<div class="outline-text-5" id="text-org1eecc7d">
<p>
definir medidas numericas sobre un set de atributos. se llaman dimensiones
a los atributos medidos
</p>

<p>
hecho: medida numerica asociada a un valor concreto de cada de las
dimensiones
</p>

<p>
cada dimension tiene atributos asociados, por lo que se la puede
representar como una relacion
</p>
</div>

<div id="outline-container-orgd79f67e" class="outline-6">
<h6 id="orgd79f67e">diag star</h6>
<div class="outline-text-6" id="text-orgd79f67e">
<p>
permite comunicar la estructura de hechos y dimensiones de un DW
</p>

<p>
tabla de hechos: tabla central con las dimensiones y su medidas esta
conectada a cada una de las tablas de dimensiones
</p>
</div>
</div>
</div>


<div id="outline-container-org2418ff8" class="outline-5">
<h5 id="org2418ff8">modelo logico</h5>
<div class="outline-text-5" id="text-org2418ff8">
<p>
OLAP guarda info sumarizada de las dimensiones que nos interesan
</p>
</div>

<div id="outline-container-orgf012719" class="outline-6">
<h6 id="orgf012719">MOLAP</h6>
<div class="outline-text-6" id="text-orgf012719">
<p>
multidimensional
</p>

<p>
los datos agregados se guardan en un bdd multidim o cubo de datos
</p>

<p>
cubo: matriz multidim que almacena una medida agregada por una serie de
dimensiones
</p>
</div>
</div>

<div id="outline-container-orge84575c" class="outline-6">
<h6 id="orge84575c">ROLAP</h6>
<div class="outline-text-6" id="text-orge84575c">
<p>
relational
</p>

<p>
la tabla de hechos agregada se almacena como una relacion mas
</p>

<p>
solamente se guarda la vista que la define
</p>

<p>
cada cierto tiempo la vista se ejecuta y se almacena el resultado (se
materializa)
</p>

<ul class="org-ul">
<li>inmediato: la vista se actualiza cada vez que se ejecuta una T nueva
sobre los datos</li>
<li>diferido
<ul class="org-ul">
<li>lazy: cuando el usuario lo pide</li>
<li>periodico: cada cierta cantidad de tiempo</li>
<li>forzado: luego de una cant de cambios</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org706d099" class="outline-6">
<h6 id="org706d099">HOLAP</h6>
<div class="outline-text-6" id="text-org706d099">
<p>
hybrid
</p>

<p>
combina un SGDB relacional con un servidor MOLAP
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8821fc1" class="outline-3">
<h3 id="org8821fc1">operaciones OLAP</h3>
<div class="outline-text-3" id="text-org8821fc1">
<p>
roll-up: agregar datos de una dimension, subiendo en su jerarquia
</p>

<p>
drill down
</p>

<p>
pivoteo: producir una tabla agregada por un subset del set de dimensiones en
cierto oeden deseado
</p>

<p>
slice / dice : seleccion de una dimension / mas de una dimension (pero sin
agregar los datos debido a la seleccion)
</p>
</div>
</div>

<div id="outline-container-orgf7000ab" class="outline-3">
<h3 id="orgf7000ab">soporte en SQL</h3>
<div class="outline-text-3" id="text-orgf7000ab">
<p>
group by <b>grouping sets</b>
</p>

<p>
union de agrupamientos distintos, especificados por los parametros
</p>

<p>
<b>rollup</b>: realiza el agrupamiento por cada conjunto de atributos y de algunos
de sus subconjuntos
</p>

<p>
rollup(a b c) = grouping sets ((abc) (ab) (a) ())
</p>

<p>
<b>cube</b>: realiza el agrupamiento por cada conjunto de atributos y de todos sus
subconjuntos
</p>

<p>
cube(abc) = grouping sets (abc) (ab) (ac) (bc) (a) (b) (c) ()
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
Last update: 2020-05-01 11:27
</div>
</body>
</html>
