<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-02-03 Mon 19:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Concurrencia</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
                   <script type="text/javascript" src="../res/org-info.js"></script>
                   <script type="text/javascript">
                    /* <![CDATA[ */
                       org_html_manager.setup ();
                    /* ]]> */
                   </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
<div id="content">
<div id="outline-container-org7322577" class="outline-2">
<h2 id="org7322577">Introducción</h2>
<div class="outline-text-2" id="text-org7322577">
</div>
<div id="outline-container-orgbbe2203" class="outline-3">
<h3 id="orgbbe2203">Concurrencia</h3>
<div class="outline-text-3" id="text-orgbbe2203">
</div>
<div id="outline-container-org1774be1" class="outline-4">
<h4 id="org1774be1">Sistemas monoprocesador, multiprocesador y distribuídos</h4>
<div class="outline-text-4" id="text-org1774be1">
<p>
En las bases de datos reales múltiples usuarios realizan operaciones de consulta
y/o actualización simultáneamente.
</p>

<p>
Nos gustaría aprovechar la capacidad de procesamiento lo mejor posible en la
resolución de consultas.
</p>

<p>
Sistemas monoprocesador
</p>
<ul class="org-ul">
<li>Permiten hacer multitasking(multitarea). Varios hilos o procesos pueden estar
corriendo concurrentemente.</li>
</ul>

<p>
Sistemas multiprocesador y sistemas distribuídos
</p>
<ul class="org-ul">
<li>Disponen de varias unidades de procesamiento que funcionan enforma simultánea.</li>
<li>Suelen replicar la base de datos, disponiendo de varias copias de algunas
tablas (o fragmentos de tabla) en distintas unidades de procesamiento</li>
</ul>
</div>
</div>

<div id="outline-container-orgc413609" class="outline-4">
<h4 id="orgc413609">Transacciones</h4>
<div class="outline-text-4" id="text-orgc413609">
<pre class="example">
En este contexto utilizaremos el concepto de transacción como
“unidad lógica de trabajo” o, más en detalle,
“secuencia ordenada de instrucciones atómicas”.
</pre>

<p>
Una transacción puede requerir varias operaciones de consulta/ABM para ser
resuelta.
</p>

<p>
Luego veremos que hay ciertas propiedades deseables que toda transacción debería
tener.
</p>

<p>
Antes de existir el multitasking, las transacciones se serializaban. Hasta tanto
no se terminara una, no se iniciaba la siguiente.
</p>
</div>
</div>

<div id="outline-container-org4402654" class="outline-4">
<h4 id="org4402654">Concepto</h4>
<div class="outline-text-4" id="text-org4402654">
<p>
La concurrencia es la posibilidad de ejecutar múltiples transacciones (tareas,
en la jerga de los sistemas operativos) enforma simultánea.
</p>

<p>
En sistemas distribuídos y multiprocesador:
</p>
<ul class="org-ul">
<li>Si dos transacciones utilizan sets de datos distintos deberían poder
ejecutarse concurrentemente en distintos procesadores.</li>
</ul>

<p>
Aún en sistemas monoprocesador, serializar no es una opción:
</p>
<ul class="org-ul">
<li>No es deseable que la ejecución de una transacción lenta demore a otras de
ejecución rápida.</li>
<li>Mientras una transacción espera que el SO escriba una página en disco, otra
transacción podría realizar una operación en memoria.</li>
</ul>

<p>
El problema que genera la ejecución concurrente es la <span class="underline">gestión de los recursos
compartidos</span>. Al nivel de los SGBDs, los recursos compartidos son los <span class="underline">datos</span>, a
los cuales distintas transacciones querrán acceder en forma simultánea.
</p>
</div>
</div>
</div>
<div id="outline-container-org696e403" class="outline-3">
<h3 id="org696e403">Modelos de procesamiento concurrente [ELM16 20.1.1]</h3>
<div class="outline-text-3" id="text-org696e403">
<p>
El <code>modelo de procesamiento</code> que utilizaremos es el de <code>concurrencia solapada</code>
(interleaved concurrency), que considera las siguientes hipótesis:
</p>

<p>
Asumiremos que disponemos de un único procesador que puede ejecutar múltiples
transacciones simultáneamente.
</p>

<p>
Cada transacción está formada por una secuencia de instrucciones atómicas, que
el procesador ejecuta de a una a la vez.
</p>

<p>
En un momento determinado, el procesador puede suspender la ejecución de una
transacción, e iniciar o retomar la ejecución de otra.
</p>

<p>
imagen
</p>

<p>
Si tuvieramos múltiples unidades de procesamiento, el modelo a utilizar sería el
de <code>procesamiento paralelo</code>.
</p>

<p>
Las herramientas teóricas que desarrollaremos se basan en el modelo de
concurrencia solapada, pero son en su mayoría extendibles al caso de
procesamiento paralelo.
</p>
</div>
</div>



<div id="outline-container-org5cfc6a7" class="outline-3">
<h3 id="org5cfc6a7">Ejemplo de ejecución concurrente</h3>
<div class="outline-text-3" id="text-org5cfc6a7">
<p>
&#x2026;
</p>

<p>
En este ejemplo, las instrucciones se corresponden con las operaciones del
álgebra relacional.
</p>
<ul class="org-ul">
<li>Problema: Una junta puede ser muy costosa. El SGDB debería poder solaparla con
otras transacciones más sencillas.</li>
</ul>

<p>
Dado que las instrucciones deben ser atómicas, es conveniente que nuestras
instrucciones tengan un nivel de granularidad más pequeño.
</p>
</div>
</div>

<div id="outline-container-org94fa0c9" class="outline-3">
<h3 id="org94fa0c9">Modelo de datos [ELM16 20.1.2]</h3>
<div class="outline-text-3" id="text-org94fa0c9">
</div>
<div id="outline-container-org8f3e04a" class="outline-4">
<h4 id="org8f3e04a">Items e instrucciones atómicas</h4>
<div class="outline-text-4" id="text-org8f3e04a">
<p>
Consideraremos que nuestra base de datos está formada por <code>ítems</code>.
</p>

<p>
Un ítem puede representar:
</p>
<ul class="org-ul">
<li>El valor de un atributo en una fila determinada de una tabla</li>
<li>Una fila de una tabla</li>
<li>Un bloque de disco</li>
<li>Una tabla</li>
</ul>

<p>
Las <code>instrucciones atómicas</code> básicas de una transacción sobre la base de datos
serán:
</p>
<ul class="org-ul">
<li><code>leer_item(X)</code>: Lee el valor del ítem X,cargándolo en una variable en memoria</li>
<li><code>escribir_item(X)</code>: Ordena escribir el valor que está en memoria del ítem X en
la base de datos</li>
</ul>


<p>
Nota: El tamaño de ítem escogido se conoce como <code>granularidad</code>, y afecta
sustancialmente al control de concurrencia.
</p>
</div>
</div>
</div>


<div id="outline-container-orge88422f" class="outline-3">
<h3 id="orge88422f">Observaciones</h3>
<div class="outline-text-3" id="text-orge88422f">
<p>
Desde ya que habrá otras instrucciones que involucran la manipulación de estos
datos en memoria (por ejemplo, realizar la junta en memoria de dos tablas ya
leídas), pero las mismas no afectan el análisis de concurrencia.
</p>

<p>
Ordenar escribir no es lo mismo que efectivamente escribir en el medio de
almacenamiento persistente en que se encuentra la base de datos. El nuevo valor
podría quedar temporalmente en un buffer en memoria.
</p>
</div>
</div>
</div>

<div id="outline-container-org3d37214" class="outline-2">
<h2 id="org3d37214">Transacciones</h2>
<div class="outline-text-2" id="text-org3d37214">
</div>
<div id="outline-container-orgf721af4" class="outline-3">
<h3 id="orgf721af4">Concepto</h3>
<div class="outline-text-3" id="text-orgf721af4">
<p>
Una <code>transacción</code> es una unidad lógica de trabajo en los SGDB.
</p>

<p>
Es una secuencia ordenada de instrucciones que deben ser ejecutadas en su
totalidad o bien no ser ejecutadas, al margen de la interferencia con otras
transacciones simultáneas.
</p>

<p>
Ejemplos:
</p>
<ul class="org-ul">
<li>Una transferencia de dinero de una cuenta corriente bancaria a otra.</li>
<li>La reserva de un pasaje aéreo.</li>
</ul>
</div>
</div>

<div id="outline-container-org9877c40" class="outline-3">
<h3 id="org9877c40">Propiedades ACID</h3>
<div class="outline-text-3" id="text-org9877c40">
<p>
La ejecución de transacciones por un SGDB debería cumplir con 4 propiedades
deseables, conocidas como propiedades ACID:
</p>
<ul class="org-ul">
<li>Atomicidad: Desde el punto de vista del usuario, las transacciones deben
ejecutarse de manera atómica. Esto quiere decir que, o bien la transacción se
realiza por completo, o bien no se realiza.</li>
<li>Consistencia: Cada ejecución, por sí misma, debe preservar la consistencia de
los datos. La consistencia se define a través de reglas de integridad:
condiciones que deben verificarse sobre los datos en todo momento.
<ul class="org-ul">
<li>Por ejemplo: la base de datos de una empresa puede tener como restricción
que no pueda haber más de un gerente por departamento.</li>
</ul></li>
<li>aIslamiento: El resultado de la ejecución concurrente de las transacciones
debe ser el mismo que si las transacciones se ejecutaran en forma aislada una
tras otra, es decir en forma serial. La ejecución concurrente debe entonces
ser equivalente a alguna ejecución serial.</li>
<li>Durabilidad: Una vez que el SGDB informa que la transacción se ha completado,
debe garantizarse la persistencia de la misma, independientemente de toda
falla que pueda ocurrir.</li>
</ul>
</div>
</div>

<div id="outline-container-org814124c" class="outline-3">
<h3 id="org814124c">Recuperación</h3>
<div class="outline-text-3" id="text-org814124c">
<p>
Para garantizar las propiedades ACID, los SGDB disponen de <code>mecanismos de
recuperación</code> que permiten deshacer/rehacer una transacción en caso de que se
produzca un error o falla.
</p>
<ul class="org-ul">
<li>Se debe garantizar la visión de "todo o nada" de las transacciones
(atomicidad), y que todos los cambios realizados por la transacción sean
efectivamente almacenados.</li>
</ul>

<p>
Para ello es necesario agregar a la secuencia de instrucciones de cada
transacción algunas instrucciones especiales:
</p>
<ul class="org-ul">
<li>begin: indica el comienzo de la transacción.</li>
<li>commit: indica que la transacción ha terminado exitosamente, y se espera que
su resultado haya sido efectivamente almacenado en forma persistente.</li>
<li>abort: indica que se produjo algún error o falla, y que por lo tanto todos los
efectos de la transacción deben ser deshechos (rolled back)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3bc9e07" class="outline-2">
<h2 id="org3bc9e07">Anomalías de la ejecución concurrente</h2>
<div class="outline-text-2" id="text-org3bc9e07">
</div>
<div id="outline-container-org45e7d29" class="outline-3">
<h3 id="org45e7d29">Problema de la lectura sucia</h3>
<div class="outline-text-3" id="text-org45e7d29">
<p>
Cuando se ejcutan transacciones en forma concurrente se da lugar a distintas
situaciones anómalas que pueden violar las propiedades ACID.
</p>

<p>
La anomalía de la <code>lectura sucia (dirty read)</code> se presenta cuando una
transacción lee un ítem que ha sido modificado por otra transacción que luego se
deshace.
</p>

<p>
En este caso la lectura <span class="underline">no es válida</span> en el sentido de que la ejecución
resultante puede no ser equivalente a una ejecución serial de las transacciones.
</p>

<p>
También se lo conoce con el nombre de "Temporary update" ó "Read uncommitted
data".
</p>

<p>
Es un conflicto de tipo WR.
</p>
</div>

<div id="outline-container-orgc03d828" class="outline-4">
<h4 id="orgc03d828">Ejemplo</h4>
</div>
</div>

<div id="outline-container-org7e5eb4a" class="outline-3">
<h3 id="org7e5eb4a">Problema de la actualización perdida y lectura no repetible</h3>
<div class="outline-text-3" id="text-org7e5eb4a">
<p>
La anomalía de la <code>actualización perdida (lost update)</code> ocurre cuando una
transacción modifica un ítem que fue leído anteriormente por una primera
transacción que aún no terminó.
</p>

<p>
En este caso, si la primera transacción luego modifica y escribe el ítem que
leyó, el valor escrito por la segunda se perderá.
</p>

<p>
Si en cambio la primera transacción vovliera a leer un ítem luego de que la
segunda lo escribiera, se encontraría con un valor distinto. Es este caso se lo
conoce como <code>lectura no repetible (unrepeatable read)</code>.
</p>

<p>
Ambas presentan un conflicto de tipo RW seguido por otro de tipo WW ó WR
respectivamente.
</p>
</div>

<div id="outline-container-org0e6fe7e" class="outline-4">
<h4 id="org0e6fe7e">Ejemplo</h4>
</div>
</div>

<div id="outline-container-org4a0784a" class="outline-3">
<h3 id="org4a0784a">Problema de escritura sucia</h3>
<div class="outline-text-3" id="text-org4a0784a">
<p>
La anomalía de la <code>escritura sucia (dirty write)</code> ocurre cuando una transacción
T<sub>2</sub> escribe un ítem que ya había sido escrito por otra transacción T<sub>1</sub> que
luego se deshace.
</p>

<p>
El problema se dará si los mecanismos de recuperación vuelven al ítem a su valor
inicial, deshaciendo la modificación realizada por T<sub>2</sub>.
</p>

<p>
imagen
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">T1</td>
<td class="org-left">T2</td>
</tr>

<tr>
<td class="org-left">begin</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">begin</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">A=A+100</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">escribir<sub>item</sub>(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">leer<sub>item</sub>(A)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">A=A+200</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">escribir<sub>item</sub>(A)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">commit</td>
</tr>

<tr>
<td class="org-left">abort</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
También se conoce con el nombre de overwrite uncommitted. Es un conflicto de
tipo WW.
</p>
</div>
</div>

<div id="outline-container-org892ac43" class="outline-3">
<h3 id="org892ac43">Problema del fantasma</h3>
<div class="outline-text-3" id="text-org892ac43">
<p>
La anomalía del <code>fantasma (phantom)</code> se produce cuando una transacción realiza
una operación compleja que involucra multiples ítems (o tablas enteras), y
algunos de esos ítems son al mismo tiempo modificados/creados/eliminados por
otras transacciones.
</p>

<p>
Aún cuando las transacciones escriban sus modificaciones inmediatamente (antes
de que otra intente leerlas) esta anomalía puede producirse, atentando contra
la serializabilidad<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.
</p>
</div>


<div id="outline-container-orgd186e29" class="outline-4">
<h4 id="orgd186e29">Ejemplo</h4>
</div>
</div>
</div>

<div id="outline-container-orge793832" class="outline-2">
<h2 id="orge793832">Serializabilidad</h2>
<div class="outline-text-2" id="text-orge793832">
</div>
<div id="outline-container-orged7303b" class="outline-3">
<h3 id="orged7303b">asd</h3>
<div class="outline-text-3" id="text-orged7303b">
</div>
<div id="outline-container-org033ee9b" class="outline-4">
<h4 id="org033ee9b">Notación</h4>
<div class="outline-text-4" id="text-org033ee9b">
</div>
<div id="outline-container-org444d1cd" class="outline-5">
<h5 id="org444d1cd">Transacción [ELM16 20.4.1]</h5>
<div class="outline-text-5" id="text-org444d1cd">
<p>
Para analizar la serializabilidad de un conjunto de transacciones en nuestro
modelo de concurrencia solapada, utilizaremos la siguiente notación breve para
las instrucciones:
</p>
<ul class="org-ul">
<li>R<sub>T</sub>(X): la transacción T lee el ítem X</li>
<li>W<sub>T</sub>(X): la transacción T escribe el ítem X</li>
<li>b<sub>T</sub>: comienzo de la transacción T</li>
<li>c<sub>T</sub>: la transacción T realiza el commit</li>
<li>a<sub>T</sub>: se aborta la transacción T</li>
</ul>

<p>
Con esta notación, podemos escribir una transacción general T como una lista de
instrucciones {}, en donde m(T) representa la cantidad de instrucciones de T.
</p>

<p>
T<sub>1</sub>: bT1;rT1(x);RT1(Y);WT1(Y);cT1
T<sub>2</sub>: bT2;rT2(x);WT2(X);cT2
</p>
</div>
</div>

<div id="outline-container-org17fce4d" class="outline-5">
<h5 id="org17fce4d">Solapamiento</h5>
<div class="outline-text-5" id="text-org17fce4d">
<p>
Un <code>solapamiento</code> entre dos transacciones T<sub>1</sub> y T<sub>2</sub> es una lista de
m(T<sub>1</sub>)+m(T<sub>2</sub>) instrucciones, en donde cada instrucción de T1 y T2 aparece
una única vez, y las instrucciones de cada transacción conservan el orden entre
ellas dentro del solapamiento.
</p>

<p>
Cuántos solapamientos distintos existen entre T1 y T2?
&#x2026;
</p>

<p>
En el ejemplo anterior, podemos representar un <code>solapamiento</code> entre T1 y T2 de
la siguiente manera
</p>

<p>
&#x2026;
</p>

<p>
La pregunta que nos haremos es si dicho solapamiento es serializable ó no.
</p>
</div>
</div>
</div>

<div id="outline-container-org9b399ed" class="outline-4">
<h4 id="org9b399ed">Ejecución serial</h4>
<div class="outline-text-4" id="text-org9b399ed">
</div>
<div id="outline-container-org68618e7" class="outline-5">
<h5 id="org68618e7">Definición [ELM16 20.5.1]</h5>
<div class="outline-text-5" id="text-org68618e7">
<p>
Dado un conjunto de transacciones T1,T2,&#x2026;,Tn una <code>ejecución serial</code> es aquella
en que las transacciones se ejecutan por completo una detrás de otra, en base a
algún orden Ti1, Ti2, &#x2026;, Tin
</p>

<p>
&#x2026;.
</p>

<p>
Para este par de transacciones existen dos ejecuciones seriales posibles:
</p>

<p>
&#x2026;
</p>

<p>
Cuántas ejecuciones seriales distintas existen entre n transacciones? n!
</p>
</div>
</div>
</div>

<div id="outline-container-orgbb32919" class="outline-4">
<h4 id="orgbb32919">Serializabilidad</h4>
<div class="outline-text-4" id="text-orgbb32919">
</div>
<div id="outline-container-org0c26761" class="outline-5">
<h5 id="org0c26761">Definición</h5>
<div class="outline-text-5" id="text-org0c26761">
<p>
Decimos que un solapamiento de un conjunto de transacciones T1,T2,&#x2026;,Tn es
<code>serializable</code> cuando la ejecución de sus instrucciones en dicho orden deja a la
base de datos en un estado <code>equivalente</code> a aquél en que la hubiera dejado alguna
ejecución serial de T1,T2,&#x2026;,Tn.
</p>

<p>
Nos interesa que los solapamientos producidos sean serializables, porque ellos
garantizan la propiedad de aislamiento de las transacciones.
</p>

<p>
Pero, cómo evaluamos esta "equivalencia" entre ordenes de ejecución?
</p>

<p>
Deberíamos no sólo mirar nuestra base de datos actual, que depende de un estado
inicial particular anterior a la ejecución de las transacciones, sino pensar en
cualquier estado inicial posible.
</p>
</div>
</div>
</div>

<div id="outline-container-org6574521" class="outline-4">
<h4 id="org6574521">Equivalencia de solapamientos</h4>
<div class="outline-text-4" id="text-org6574521">
<p>
Existen entonces distintas nociones de equivalencia entre ordenes de ejecución
de transacciones:
</p>
<ul class="org-ul">
<li>Equivalencia de resultados: Cuando, dado un estado inicial particular, ambos
órdenes de ejecución dejan a la base de datos en el mismo estado.</li>
<li>Equivalencia de conflictos: cuando ambos órdenes de ejecución poseen los
mismos <code>conflictos</code> entre instrucciones
<ul class="org-ul">
<li>Esta noción es particularmente interesante porque no depende del estado
inicial de la base de datos</li>
</ul></li>
<li>Equivalencia de vistas: cuando en cada órden de ejecución, cada lectura RTi(X)
lee el valor escrito por la misma transacción j, WTj(X). Además se pide que en
ambos órdenes la última modificación de cada ítem X haya sido hecha por la
misma transacción.</li>
</ul>
</div>
</div>

<div id="outline-container-org242cc1d" class="outline-4">
<h4 id="org242cc1d">Conflictos</h4>
<div class="outline-text-4" id="text-org242cc1d">
</div>
<div id="outline-container-orgcd9a13a" class="outline-5">
<h5 id="orgcd9a13a">Definición</h5>
<div class="outline-text-5" id="text-orgcd9a13a">
<p>
Dado un orden de ejecución, un <code>conflicto</code> es un par de instrucciones (I1,I2)
ejecutadas por dos transacciones distintas Ti y Tj, tales que I2 se encuentra
más tarde que I1 en el orden, y que responde a alguno de los siguientes
esquemas:
</p>
<ul class="org-ul">
<li>RTi, WTj: una transacción escribe un ítem que otra leyó</li>
<li>WTi, RTj: una transacción lee un ítem que otra escribió</li>
<li>WTi, WTj: dos transacciones escriben un mismo ítem</li>
</ul>

<p>
En otras palabras, tenemos un conflicto cuando dos transacciones distintas
ejecutan instrucciones sobre un mismo ítem X, y al menos una de las dos
instrucciones es una escritura.
</p>

<p>
Todo par de instrucciones consecutivas (I1, I2) de un solapamiento que no
constituye un conflicto puede ser invertido en su ejecución (es decir,
reemplazado por el par (I2, I1)) obeteniendo un solapamiento equivalente por
conflictos al inicial.
</p>
</div>
</div>

<div id="outline-container-orge1577c3" class="outline-5">
<h5 id="orge1577c3">Ejemplo</h5>
</div>
</div>
</div>


<div id="outline-container-org8682ca7" class="outline-3">
<h3 id="org8682ca7">Grafo de precedencias</h3>
<div class="outline-text-3" id="text-org8682ca7">
</div>
<div id="outline-container-org06f0480" class="outline-4">
<h4 id="org06f0480">Construcción [ELM16 20.5.2]</h4>
<div class="outline-text-4" id="text-org06f0480">
<p>
La serializabilidad por conflictos de un orden de ejecución puede ser evaluada
con la construcción de un <code>grafo de precedencias</code>.
</p>

<p>
Dado un conjunto de transacciones T1,T2,&#x2026;,Tn que acceden a determinados items
X1,X2,&#x2026;,Xp de la base de datos, el grafo de precedencias es un grafo dirigido
simple que se construye de la siguiente forma:
</p>

<ol class="org-ol">
<li>Se crea un nodo por cada transacción T1,T2,&#x2026;,Tn</li>
<li>Se agrega un arco entre los nodos Ti y Tj (i &ne; j) \iif existe algún
conflicto de la forma (RTi,WTj ),(WTi,RTj),(WTi,WTj)</li>
</ol>

<p>
Cada arco (Ti,Tj) en el grafo representa una <code>precedencia</code> entre Ti y Tj, e
indica que para que el conflicto sea equivalente por conflictos con una
ejecución serial, entonces en dicha ejecución serial Ti debe preceder a Tj.
</p>

<p>
Opcionalmente podemos etiquetar el arco con el nombre del recurso que causa el
conflicto:
</p>

<p>
RW
RT1,WT2
T1 &rarr; T2
</p>

<p>
WR
WT1,RT2
T1 &rarr; T2
</p>

<p>
WW
WT1,WT2
T1 &rarr; T2
</p>
</div>
</div>

<div id="outline-container-orgfff52cb" class="outline-4">
<h4 id="orgfff52cb">Ejemplo</h4>
</div>

<div id="outline-container-org9b262ea" class="outline-4">
<h4 id="org9b262ea">Resultados</h4>
<div class="outline-text-4" id="text-org9b262ea">
<p>
Un orden de ejecución es serializable por conflictos si y sólo si su grafo de
precedencias no tiene ciclos.
</p>

<p>
Si un orden de ejecución es serializable por conflictos, el orden de ejecución
serial equivalente puede ser calculado a partir del grafo de precedencias,
utilizando el <code>algoritmo de ordenamiento topológico</code>
</p>

<ol class="org-ol">
<li>Dado un grafo dirigido acíclico, un <code>orden topológico</code> es un ordenamiento de
los nodos del grafo tal que para todo arco (x,y), el nodo x precede al nodo y.</li>
<li>Es sencillo encontrar uno eliminando los nodos que no poseen predecesores en
forma recursiva y de a uno a la vez, hasta que no quede ninguno. El orden en
que los nodos fueron eliminados constituirá un orden topológico del grafo.</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-org6740100" class="outline-2">
<h2 id="org6740100">Control de concurrencia</h2>
<div class="outline-text-2" id="text-org6740100">
</div>
<div id="outline-container-org7b38538" class="outline-3">
<h3 id="org7b38538">Enfoques</h3>
<div class="outline-text-3" id="text-org7b38538">
<p>
El problema del control de concurrencia en vistas de garantizar el aislamiento
admite dos enfoques:
</p>
<ul class="org-ul">
<li><code>Enfoque optimista</code>: consiste en "dejar hacer" a las transacciones, y deshacer
(rollback) una de ellas si en fase de validación se descubre un conflicto.
<ul class="org-ul">
<li>Adecuado cuando el SGDB tiene poca carga, y la probabilidad de conflicto es
baja.</li>
</ul></li>
<li><code>Enfoque pesimista</code>: busca garantizar que no se produzcan conflictos. Existen
distintas variantes del mismo:
<ul class="org-ul">
<li>Control de concurrencia basado en locks</li>
<li>Control de concurrencia basado en timestamps</li>
<li>Control de concurrencia multiversión (MVCC)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org705abcd" class="outline-3">
<h3 id="org705abcd">Control de concurrencia basado en locks</h3>
<div class="outline-text-3" id="text-org705abcd">
<p>
En este método, el SGDB utiliza locks para bloquear a los recursos (los items) y
no permitir que mas de una transaccion los use en forma simultánea.
</p>

<p>
Los locks son insertados <span class="underline">por el SGDB</span> como instrucciones especiales en medio de
la transaccion.
</p>

<p>
Una vez insertados, las transacciones compiten entre ellas por su ejecucion.
</p>

<p>
Veremos que es posible -aunque no trivial- garantizar la serializabilidad
utilizando locks.
</p>
</div>
</div>

<div id="outline-container-org48ac54d" class="outline-3">
<h3 id="org48ac54d">Locks [ELM16 21.1.1]</h3>
<div class="outline-text-3" id="text-org48ac54d">
<p>
Los locks son variables asociadas a determinados recursos, y que permiten
regular el acceso a los mismos en los sistemas concurrentes.
</p>

<p>
Son una herramienta para resolver el problema de la <code>exclusión mutua</code>.
</p>

<p>
Un lock debe disponer de dos <code>primitivas</code> de uso, que permiten tomar y liberar el
recurso el recurso X asociado al mismo:
</p>
<ul class="org-ul">
<li><code>Acquire(X) | Lock (X)</code> (L(X))</li>
<li><code>Release(X) | Unlock(X)</code> (U(X))</li>
</ul>

<p>
Tienen caracter bloqueante: cuando una transacción tiene un lock sobre un item
X, ninguna otra transaccion puede adquirir un lock sobre el mismo item hasta
tanto la primera no lo libere.
</p>

<p>
Es fundamental que dichas primitivas sean <span class="underline">atómicas</span>. Es decir, la ejecucion de
la primitiva Lock(X) sobre un recurso X no puede estar solapada con una
ejecucion semejante en otra transaccion.
</p>
<ul class="org-ul">
<li>Lock(X) requiere leer y escribir una variable.</li>
</ul>
</div>

<div id="outline-container-orga90ccde" class="outline-4">
<h4 id="orga90ccde">Ejemplo</h4>
<div class="outline-text-4" id="text-orga90ccde">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Transacción T1</td>
<td class="org-left">Transacción T2</td>
</tr>

<tr>
<td class="org-left">begin</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">begin</td>
</tr>

<tr>
<td class="org-left">lock(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">lock(B)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(B)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">A = A + B</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">escribir<sub>item</sub>(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">unlock(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">unlock(B)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">lock(B)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">leer<sub>item</sub>(B)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">unlock(B)</td>
</tr>

<tr>
<td class="org-left">commit</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">commit</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1d4abfc" class="outline-4">
<h4 id="org1d4abfc">Tipos de locks</h4>
<div class="outline-text-4" id="text-org1d4abfc">
<p>
En general, los SGDB implementan locks de varios tipos. Los dos tipos de locks
principales son:
</p>
<ul class="org-ul">
<li><code>Locks de escritura</code> o "de acceso exclusivo"</li>
<li><code>Locks de lectura</code> o "de acceso compartido"</li>
</ul>

<p>
Cuando una transaccion posee un lock de acceso exclusivo (EX) sobre un item,
ninguna otra transaccion puede tener un lock de ningun tipo sobre ese mismo
item.
</p>

<p>
Pero muchas transacciones pueden poseer locks de acceso compartido (SH) sobre un
mismo item simultaneamente.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">SH</td>
<td class="org-left">EX</td>
</tr>

<tr>
<td class="org-left">SH</td>
<td class="org-left">v</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">EX</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org584552f" class="outline-4">
<h4 id="org584552f">Protocolo de locks de dos fases (2PL) [ELM16 21.1.2]</h4>
<div class="outline-text-4" id="text-org584552f">
<p>
El empleo de locks por si solos no basta. Una transaccion podria adquirir un
lock sobre un item para leerlo, luego liberarlo, y mas tarde volver a adquirirlo
para leerlo y modificarlo. Si en el intervalo otra transaccion lo lee y escribe
(aun tomando un lock), podria producirse la anomalía de la lectura no repetible.
</p>

<p>
El protocolo mas comunmente utilizado para la adquisicion y liberacion de locks
es el <code>protocolo de lock de dos fases (2PL two-phase lock)</code>.
</p>

<p>
El 2PL se rige por la siguiente regla:
</p>

<p>
Protocolo de lock de dos fases (2PL)
</p>
<blockquote>
<p>
Una transaccion no puede adquirir un lock luego de haber liberado un lock que
habia adquirido.
</p>
</blockquote>

<p>
La regla divide naturalmente en dos fases a la ejecucion de la transaccion:
</p>
<ul class="org-ul">
<li>Una fase de adquisicion de locks, en la que la cantidad de locks adquiridos
crece.</li>
<li>Una fase de liberacion de locks, en que la cantidad de locks adquiridos
decrece.</li>
</ul>

<p>
Puede demostrarse que el cumplimiento de este protocolo es condicion suficiente
para garantizar que cualquier orden de ejecucion de un conjunto de transacciones
sea serializable.
</p>

<p>
Sin embargo, la utilizacion de locks introduce otros dos problemas potenciales
que antes no teniamos:
</p>
<ul class="org-ul">
<li>Bloqueo (deadlock)</li>
<li>Inanicion o postergacion indefinida (livelock)</li>
</ul>
</div>
</div>

<div id="outline-container-org5882405" class="outline-4">
<h4 id="org5882405">Deadlock [ELM16 21.1.3]</h4>
<div class="outline-text-4" id="text-org5882405">
<p>
Un <code>deadlock</code> es una condicion en que un conjunto de transacciones quedan cada
una de ellas bloqueada a la espera de recursos que otra de ellas posee.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">TransacciónT1</td>
<td class="org-left">TransacciónT2</td>
</tr>

<tr>
<td class="org-left">begin</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">begin</td>
</tr>

<tr>
<td class="org-left">lock(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">lock(B)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">leer<sub>item</sub>(B)</td>
</tr>

<tr>
<td class="org-left">lock(B)†</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">lock(A)†</td>
</tr>
</tbody>
</table>

<p>
Observemos que el problema no habría existido si las transacciones hubieran
adquirido los locks en el mismo orden.
</p>
</div>

<div id="outline-container-orgaafbae4" class="outline-5">
<h5 id="orgaafbae4">Mecanismos de prevención</h5>
<div class="outline-text-5" id="text-orgaafbae4">
<ol class="org-ol">
<li>Que cada transaccion adquiera todos los locks que necesita antes de comenzar
su primera instrucción, y en forma simultánea.</li>
<li>Definir un ordenamiento de los recursos, y obligar a que luego todas las
transacciones respeten dicho ordenamiento en la adquisicion de locks.</li>
<li>Métodos basados en timestamps</li>
</ol>

<p>
La limitación del enfoque preventivo es que será necesario saber qué recursos
serán necesarios de antemano.
</p>
</div>
</div>

<div id="outline-container-org1ac3715" class="outline-5">
<h5 id="org1ac3715">Métodos de detección</h5>
<div class="outline-text-5" id="text-org1ac3715">
<ol class="org-ol">
<li>Analizar el <code>grafo de alocacion de recursos</code>: un grafo dirigido que posee a
las transacciones y los recursos como nodos, y en el cual se coloca un arco
de una transaccion a un recurso cada vez que una transaccion espera por un
recurso, y un arco de un recurso a una transaccion cada vez que la
transaccion posee el lock de dicho recurso:
<ul class="org-ul">
<li>Cuando se detecta un ciclo en este grafo, se aborta (rollback) una de las
transacciones involucradas</li>
<li>El concepto es muy similar al del grafo de precedencias para un
solapamiento.</li>
</ul></li>
<li>Definir un timeout para la adquisicion del Lock(X), despues del cual se
aborta la transaccion.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgd83e596" class="outline-4">
<h4 id="orgd83e596">Inanición</h4>
<div class="outline-text-4" id="text-orgd83e596">
<p>
La <code>inanicion</code> es una condicion vinculada con el deadlock, y ocurre cuando una
transaccion no logra ejecutarse por un periodo de tiempo indefinido.
</p>

<p>
Puede suceder por ejemplo, si ante la detección de un deadlock se elije siempre
a la misma transaccion para ser abortada.
</p>

<p>
La solucion mas comun consiste en encolar los pedidos de locks, de manera que
las transacciones que esperan desde hace mas tiempo por un recurso tengan
prioridad en la adquisicion de su lock.
</p>
</div>
</div>
</div>

<div id="outline-container-org69f2fdd" class="outline-3">
<h3 id="org69f2fdd">Control de concurrencia multiversión (MVCC) [ELM16 21.3]</h3>
<div class="outline-text-3" id="text-org69f2fdd">
<p>
En el <code>control de concurrencia multiversión</code>, cada transaccion ve una snapshot
de la base de datos correspondiente al instante de su inicio. También se lo
conoce con el nombre de snapshot isolation.
</p>
<ul class="org-ul">
<li>Ventaja: permite un mayor solapamiento, ya que lecturas que hubieran sido
bloqueadas utilizando locks, ahora siempre puede realizarse.</li>
<li>Desventajas:
<ul class="org-ul">
<li>Requiere uso de un mayor espacio en disco o memoria, al tener que mantener
multiples versiones de los mismos items.</li>
<li>Cuando ocurren conflictos de tipo RW ó WW entre transacciones, puede obligar
a deshacer una de ellas.</li>
</ul></li>
</ul>

<p>
Suele implementarse utilizando timestamps para registrar cuándo fue la última
vez que cada item se leyó/escribió.
</p>
</div>
</div>
</div>

<div id="outline-container-org7ccb75e" class="outline-2">
<h2 id="org7ccb75e">Recuperabilidad</h2>
<div class="outline-text-2" id="text-org7ccb75e">
</div>
<div id="outline-container-orgdb2e7c7" class="outline-3">
<h3 id="orgdb2e7c7">Definición [ELM1620.4.2]</h3>
<div class="outline-text-3" id="text-orgdb2e7c7">
<p>
La serializabilidad de las transacciones ya nos asegura la propiedad de
aislamiento.
</p>

<p>
Nos interesa ahora asegurar que una vez que una transaccion commiteó, la misma
no deba ser desecha. Esto nos ayudará a implementar de una forma sencilla la
propiedad de durabilidad.
</p>

<p>
<code>Definición</code>: un solapamiento es <code>recuperable</code> si y solo si ninguna transaccion
T realiza commit hasta tanto todas las transacciones que escribieron datos antes
de que T los leyera hayan commiteado.
</p>
</div>
</div>

<div id="outline-container-org92d2d32" class="outline-3">
<h3 id="org92d2d32">Gestor de recuperación</h3>
<div class="outline-text-3" id="text-org92d2d32">
<p>
Dado un solapamiento recuperable, puede ser necesario deshacer (abortar) una
transacción antes de llegado su commit, ypara ello el SGBD deberá contar con una
serie de información que es almacenada por su <code>gestor de recuperación</code> en
un log (bitácora).
</p>

<p>
El log almacena generalmente los siguientes registros:
</p>
<ul class="org-ul">
<li>(BEGIN, T<sub>id</sub>): indica que la transaccion T<sub>id</sub> comenzo.</li>
<li>(WRITE, T<sub>id</sub>, X,x<sub>old</sub>,x<sub>new</sub>): indica que la transaccion T<sub>id</sub> escribio
el item X, cambiando su viejo valor x<sub>old</sub> por un nuevo valor x<sub>new</sub>.</li>
<li>(READ, T<sub>id</sub>, X): indica que la transaccion T<sub>id</sub> leyo el item X.</li>
<li>(COMMIT, T<sub>id</sub>): indica que la transaccion T<sub>id</sub> commiteó.</li>
<li>(ABORT, T<sub>id</sub>): indica que la transaccion T<sub>id</sub> abortó.</li>
</ul>

<p>
En particular, los valores viejos de cada item almacenados en los registros
WRITE del log son los que permitiran deshacer los efectos de la transaccion en
el momento de hacer el rollback.
</p>
</div>
</div>

<div id="outline-container-org26bebcb" class="outline-3">
<h3 id="org26bebcb">Rollback</h3>
<div class="outline-text-3" id="text-org26bebcb">
<p>
Un SGDB no deberia jamas permitir la ejecucion de un solapamiento que no sea
recuperable.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Transacción T1</td>
<td class="org-left">Transacción T2</td>
</tr>

<tr>
<td class="org-left">begin</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">begin</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">A=A+100</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">escribir<sub>item</sub>(A)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">leer<sub>item</sub>(A)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">A=A+200</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">escribir<sub>item</sub>(A)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">commit</td>
</tr>

<tr>
<td class="org-left">abort</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
A pesar de que el solapamiento es serializable, el SGBD no podrá deshacer los
efectos de la transacción T1 sin eliminar también los efectos de T2, que ya
commiteó.
</p>

<p>
Este tipo de solapamientos no debe producirse.
</p>

<p>
En general, pensemos en un solapamiento serializable de transacciones como una
lista de instrucciones. Cuando una transacción Tj es abortada, el SGBD debe
mantener la serializabilidad de las transacciones restantes.
</p>

<p>
Si las modificaciones hechas por Tj no fueron leídas por nadie, entonces basta
con procesar el log de Tj en forma inversa para deshacer sus efectos.
</p>

<p>
Pero si una transacción Ti leyó un dato modificado por Tj, entonces será
necesario hacer el rollback de Ti para volverla a ejecutar. ¡Sería conveniente
que Ti no hubiera commiteado aún
</p>

<p>
!Resultado: Si un solapamiento de transacciones es recuperable, entonces nunca
será necesario deshacer transacciones que ya hayan commiteado.
</p>
<ul class="org-ul">
<li>Aún así puede ser necesario deshacer transacciones que no aúnno han
commiteado.</li>
<li>¡Y puede que ésto produzca una cascada de rollbacks!</li>
</ul>
</div>
</div>

<div id="outline-container-orgd67eb0d" class="outline-3">
<h3 id="orgd67eb0d">Cascada de rollbacks</h3>
<div class="outline-text-3" id="text-orgd67eb0d">
<p>
Que un solapamiento sea recuperable, no implica que no sea necesario tener que
hacer rollbacks en cascada de transacciones que aún no commitearon.
</p>

<p>
Ejemplo:
</p>

<p>
b<sub>T<sub>1</sub></sub>;r<sub>T<sub>1</sub></sub>(X);b<sub>T<sub>2</sub></sub>;w<sub>T<sub>1</sub></sub>(X);r<sub>T<sub>2</sub></sub>(X);r<sub>T<sub>1</sub></sub>(Y);w<sub>T<sub>2</sub></sub>(X);w<sub>T<sub>1</sub></sub>(Y);C<sub>T<sub>1</sub></sub>;c<sub>T<sub>2</sub></sub>;
</p>

<p>
es recuperable
</p>

<p>
es serializable
</p>

<p>
Pero qué sucede si T<sub>1</sub> aborta después de de w<sub>T<sub>2</sub></sub>(X)?
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Transacción T1</td>
<td class="org-left">Transacción T2</td>
</tr>

<tr>
<td class="org-left">begin</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(X)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">begin</td>
</tr>

<tr>
<td class="org-left">escribir<sub>item</sub>(X)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">leer<sub>item</sub>(X)</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(Y)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">escribir<sub>item</sub>(X)</td>
</tr>

<tr>
<td class="org-left">escribir<sub>item</sub>(Y)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">commit</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">commit</td>
</tr>
</tbody>
</table>

<p>
Como T<sub>2</sub> lee un item que T<sub>1</sub> habia modificado, la lectura que hace T<sub>2</sub> ya
no es válida. Entonces, T<sub>2</sub> deberá ser abortada en cascada.
</p>



<p>
Para evitar los rollbacks en cascada es necesario que una transaccion no lea
valores que aun no fueron commiteados. Esto es mas fuerte que la condicion de
recuperabilidad.
</p>

<p>
Esta definición implica que quedan prohibidos los conflictos de la forma
(W<sub>T<sub>i</sub></sub>(X);R<sub>T<sub>j</sub></sub>(X)) sin que en el medio exista un commit c<sub>T<sub>i</sub></sub>.
</p>

<p>
Se evita entonces la anomalía de la lectura sucia.
</p>

<p>
Evitar rollbacks en cascada \implies Recuperable
</p>

<p>
Evitar rollbacks en cascada \nimplies Recuperable
</p>

<p>
Que anomalía de las que vimos no cubre esta definicion?
</p>
<ul class="org-ul">
<li>La actualización perdida.</li>
</ul>

<p>
Ejemplo:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Transacción T1</td>
<td class="org-left">Transacción T2</td>
</tr>

<tr>
<td class="org-left">begin</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(X)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">begin</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">leer<sub>item</sub>(X)</td>
</tr>

<tr>
<td class="org-left">escribir<sub>item</sub>(X)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">leer<sub>item</sub>(Y)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">escribir<sub>item</sub>(X)</td>
</tr>

<tr>
<td class="org-left">abort</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Es recuperable</li>
<li>Evita rollbacks en cascada</li>
<li>No es serializable</li>
</ul>
</div>
</div>

<div id="outline-container-orgf81f503" class="outline-3">
<h3 id="orgf81f503">Protocolo de lock de dos fases estricto (S2PL)</h3>
<div class="outline-text-3" id="text-orgf81f503">
<p>
Los locks también pueden ayudar a asegurar la recuperabilidad.
</p>

<p>
El <code>protocolo de 2PL estricto (S2PL)</code> emplea la siguiente regla:
</p>

<p>
Protocolo de lock de dos fases estricto (S2PL)
</p>
<pre class="example">
Una transacción no puede adquirir un lock luego de haber liberado un lock que
había adquirido, y además los locks de escritura sólo pueden ser liberados
después de haber commiteado la transacción.
</pre>

<p>
En caso de no diferenciar tipos de lock, se convierte en <code>riguroso</code>:
</p>

<p>
Protocolo de lock de dos fases riguroso (R2PL)
</p>
<pre class="example">
Los locks sólo pueden ser liberados después del commit.
</pre>

<p>
Resultado: S2PL y R2PL garantizan que todo solapamiento sea no sólo
serializable, sino también recuperable, y que no se producirán cascadas de
rollbacks al deshacer una transacción.
</p>
</div>
</div>
</div>

<div id="outline-container-org4d38559" class="outline-2">
<h2 id="org4d38559">Niveles de aislamiento</h2>
<div class="outline-text-2" id="text-org4d38559">
</div>
<div id="outline-container-orga05794d" class="outline-3">
<h3 id="orga05794d">SQL [ELM16 20.6]</h3>
<div class="outline-text-3" id="text-orga05794d">
<p>
SQL permite definir el nivel de aislamiento de las transacciones con el comando
<code>SET TRANSACTION ISOLATION LEVEL</code>.
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #ff79c6; font-weight: bold;">SET</span> <span style="color: #ff79c6; font-weight: bold;">TRANSACTION</span> <span style="color: #ff79c6; font-weight: bold;">ISOLATION</span> <span style="color: #ff79c6; font-weight: bold;">LEVEL</span>
<span style="color: #ff79c6; font-weight: bold;">READ</span> <span style="color: #ff79c6; font-weight: bold;">UNCOMMITTED</span> | <span style="color: #ff79c6; font-weight: bold;">READ</span> <span style="color: #ff79c6; font-weight: bold;">COMMITTED</span> | <span style="color: #ff79c6; font-weight: bold;">REPEATABLE</span> <span style="color: #ff79c6; font-weight: bold;">READ</span> | <span style="color: #ff79c6; font-weight: bold;">SERIALIZABLE</span>;
</pre>
</div>

<p>
y para definir una transaccion
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #ff79c6; font-weight: bold;">START</span> <span style="color: #ff79c6; font-weight: bold;">TRANSACTION</span> [<span style="color: #ff79c6; font-weight: bold;">ISOLATION</span> <span style="color: #ff79c6; font-weight: bold;">LEVEL</span> ...]
...
<span style="color: #ff79c6; font-weight: bold;">COMMIT</span> | <span style="color: #ff79c6; font-weight: bold;">ROLLBACK</span>
</pre>
</div>

<p>
Distintos motores pueden implementar los niveles de aislamiento con distintas
técnicas, pero de acuerdo con el nivel de aislamiento configurado, el SGDB debe
garantizar que ciertas anomalías no ocurran.
</p>
</div>
</div>

<div id="outline-container-orgb53ed44" class="outline-3">
<h3 id="orgb53ed44">Tabla de anomalías</h3>
<div class="outline-text-3" id="text-orgb53ed44">
<p>
De acuerdo con el nivel de aislamiento elegido, pueden producirse ó no ciertas
anomalías:
</p>
<ol class="org-ol">
<li>Read Uncommitted: Es la carencia total de aislamiento: No se emplean locks, y
se accede a los items son tomar ninguna precaución.</li>
<li>Read Committed: evita la anomalía de lectura sucia.</li>
<li>Repeatable Read: Evita la lectura no repetible y la lectura sucia.</li>
<li>Serializable: Evita todas las anomalías, y asegura que el resultado de la
ejecucion de las transacciones es equivalente al de algun orden serial.</li>
</ol>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Nivel de aislamiento</td>
<td class="org-left">Lectura sucia</td>
<td class="org-left">Lectura no repetible</td>
<td class="org-left">Fantasma</td>
</tr>

<tr>
<td class="org-left">READ UNCOMMITTED</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left">READ COMMITTED</td>
<td class="org-left">v</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left">REPEATABLE READ</td>
<td class="org-left">v</td>
<td class="org-left">v</td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left">SERIALIZABLE</td>
<td class="org-left">v</td>
<td class="org-left">v</td>
<td class="org-left">v</td>
</tr>
</tbody>
</table>

<p>
Si bien la anomalía de "escritura sucia" no se menciona en el estándar, la misma
debería ser proscripta en todos los niveles de aislamiento, y practicamente
todos los SGDB lo hacen.
</p>
</div>
</div>

<div id="outline-container-org95ab057" class="outline-3">
<h3 id="org95ab057">Ejemplo</h3>
<div class="outline-text-3" id="text-org95ab057">
<p>
Un SGBD implementa el siguiente protocolo de locks: “Cada vez que una
transacción va a leer un ítem, adquiere un lock de lectura sobre el mismo
inmediatamente antes, y lo libera inmediatamente después. Cuando va a modificar
un ítem, adquiere un lock de escritura inmediatamente antes, y sólo lo libera
después de realizar el commit”.¿Qué nivel de aislamiento logra este protocolo?
</p>

<p>
Read Committed, dado que sólo evita la lectura sucia (y la escriturasucia).
</p>
</div>
</div>
</div>

<div id="outline-container-org4593b5d" class="outline-2">
<h2 id="org4593b5d">Implementaciones</h2>
<div class="outline-text-2" id="text-org4593b5d">
</div>
<div id="outline-container-org3dbd2f2" class="outline-3">
<h3 id="org3dbd2f2">Oracle</h3>
<div class="outline-text-3" id="text-org3dbd2f2">
<p>
Sólo se definen locks de escritura.
</p>

<p>
Se adquieren en forma automática, y sin la intervención del usuario.
</p>

<p>
El nivel de granularidad es la fila, para minimizar el bloqueo de recursos y
maximizar la concurrencia.
</p>

<p>
Para evitar inconsistencias de lectura se utiliza un control de concurrencia
multiversión:
</p>
<ul class="org-ul">
<li>Query’s Snapshot Time: Cada consulta de una transacción ve los datos que
fueron commiteados en el momento t1 en que comenzó la consulta. Si luego la
fila resulta ser modificada por otra transacción que ya había comenzado antes
de t1, se aplica un mecanismo de rollback. Esto mantiene un nivel de
aislamiento de Read Committed, evitando la lectura sucia.</li>
<li>Transaction’s Snapshot Time: Todas las consultas de una transacción verán los
valores de las filas commiteados antes de comenzar la transacción. Garantiza
un nivel de aislamiento Serializable.</li>
</ul>
</div>
</div>

<div id="outline-container-org3d92d56" class="outline-3">
<h3 id="org3d92d56">DB2</h3>
<div class="outline-text-3" id="text-org3d92d56">
<p>
Tiene un complejo sistema de locks.
</p>

<p>
Pueden obtenerse a distintos niveles de granularidad, pero lo más común es la
tabla ó la fila.
</p>

<p>
Los tipos delock, por nivel de control creciente, son: Intent None(IN), Intent
Share (IS), Next Key Share (NS), Share(S), Intent Exclusive (IX), Share with
Intent Exclusive (SIX), Update(U), NextKey Exclusive (NX), Next Key Weak
Exclusive (NW), Exclusive(X), Weak Exclusive (WE), Super Exclusive (Z).
</p>

<p>
El funcionamiento básico es:
</p>
<ul class="org-ul">
<li>Los Shared locks sólo permiten leer el ítem.</li>
<li>Los Update locks permiten leer, pero con aviso de que luego se intentará
actualizar el ítem.</li>
<li>Los Exclusive locks permiten actualizar el ítem.</li>
</ul>

<p>
Por ejemplo&#x2026;
</p>
<ul class="org-ul">
<li>Mientras T1 posee un update lock, T2 puede pedir un share lock.</li>
<li>Mientras T1 posee un share lock, T2 puede pedir un update lock.</li>
<li>Mientras T1 posee un update lock, T2 no puede pedir un update lock.</li>
<li>Mientras T1 posee un exclusive lock, T2no puede pedir siquiera un share lock.</li>
</ul>

<p>
Se utiliza una técnica de Lock Scalation para convertir locks de fila en un lock
de tabla.
</p>

<p>
Se pueden elegir 4 niveles de aislamiento distintos.
</p>
</div>
</div>

<div id="outline-container-orgec673dd" class="outline-3">
<h3 id="orgec673dd">SQL SERVER</h3>
<div class="outline-text-3" id="text-orgec673dd">
<p>
El control de concurrencia de MS-SQL Server está basado enlocks, aunque también
implementa mecanismos de control multiversión.
</p>

<p>
Al igual que en DB2, en SQL Server hay una gran cantidad de tipos de locks.
</p>

<p>
Se implementan 5 niveles de aislamiento. El parámetro <code>ALLOW_SNAPSHOT_ISOLATION</code>
permite, en algunos de ellos, elegirentre un control basado en locks y un
control multiversión.
</p>
</div>
</div>
</div>

<div id="outline-container-org4e89d6c" class="outline-2">
<h2 id="org4e89d6c">Bibliografía</h2>
<div class="outline-text-2" id="text-org4e89d6c">
<ul class="org-ul">
<li>[ELM16] Fundamentals of Database Systems, 7th Edition.R. Elmasri, S. Navathe,
2016.Capítulo 20, Capítulo 21</li>
<li>[GM09] Database Systems, The Complete Book, 2nd Edition.H. García-Molina,
J. Ullman, J. Widom, 2009.Capítulo 18, Capítulo 19</li>
<li>[CONN15] Database Systems, a Practical Approach to Design,Implementation and
Management, 6th Edition.T. Connolly, C. Begg, 2015.Capítulo 22</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Para resolverla suelen necesitarse locks a nivel de tabla, o bien métodos
de snapshot isolation.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
Last update: 2020-02-03 19:40
</div>
</body>
</html>
 
