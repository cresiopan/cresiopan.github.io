<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-08-10 Sat 00:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Concurrencia</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<p>
Page 1
</p>















<p>
Concurrencia y Transacciones
75.15 / 75.28 / 95.05 - Base de Datos
Concurrencia y Transacciones
</p>


<p>
3 de octubre de 2018
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 2
</p>


















<p>
Concurrencia y Transacciones
Temas
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 3
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 4
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Concurrencia
Sistemas monoprocesador, multiprocesador y distribuídos
operaciones de consulta y/o actualización simultáneamente.
posible en la resolución de consultas.
Sistemas monoprocesador
pueden estar corriendo concurrentemente.
Sistemas multiprocesador
y
sistemas distribuídos
Suelen
replicar
la base de datos, disponiendo de varias copias de
procesamiento.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 5
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Concurrencia
Transacciones
En este contexto utilizaremos el concepto de
transacción
como “unidad
instrucciones atómicas”.
consulta/ABM para ser resuelta.
transacción debería tener.
Antes de existir el multitasking, las transacciones se
serializaban
.
Hasta tanto no se terminara una, no se iniciaba la siguiente.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 6
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Concurrencia
Concepto
La
concurrencia
es la posibilidad de ejecutar múltiples
En sistemas distribuídos y multiprocesador:
ejecutarse concurrentemente en distintos procesadores.
Aún en sistemas monoprocesador, serializar no es una opción:
disco, otra transacción podría realizar una operación en memoria.
transacciones querrán acceder en forma simultánea.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 7
</p>



















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Modelo de procesamiento concurrente
El
modelo de procesamiento
que utilizaremos es el de
concurrencia solapada
(interleaved concurrency), que considera
las siguientes hipótesis:
1
ejecutar múltiples transacciones simultáneamente.
2
atómicas, que el procesador ejecuta de a una a la vez.
3
otra.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 20.1.1]
</p>






<p>
Page 8
</p>
















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Modelo de procesamiento concurrente
utilizar sería el de
procesamiento paralelo
.
extendibles al caso de procesamiento paralelo.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 9
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Ejemplo de ejecución concurrente
un banco:
Sucursales(codigo, localidad, &#x2026;.)
(110, ‘La Paternal’, &#x2026;)
Clientes(CUIT, nombre, cod<sub>sucursal</sub>, saldo)
(‘27-40182490-5’, ‘Juana Hass’, 110, 2500)
110 a la sucursal 220.
Operación 1
Operación 2
PAT ← σ
nombre=‘LaPaternal‘
(
Sucursales)
ID<sub>PAT</sub> ← π
codigo
(
PAT )
UN<sub>CLI</sub> ← σ
CUIT =‘27-40182490-5‘
(
Clientes)
Clientes ← σ
CUIT &amp;lt;&amp;gt;‘27-40182490-5‘
(
Clientes)
CLI ← ID<sub>PAT</sub> ./
codigo=cod _sucursal
Clientes
Clientes ← Clientes ∪ {‘27-40182490-5‘, ‘Juana Hass‘, 220, 2500}
π
nombre
(
CLI)
procesador sólo puede ejecutar una instrucción de una de las dos transacciones a la vez.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 10
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Ejemplo de ejecución concurrente
operaciones del álgebra relacional.
Problema:
Una junta puede ser muy costosa. El SGBD debería
poder solaparla con otras transacciones más sencilla.
granularidad más pequeño.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 11
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Modelo de datos
Items e instrucciones atómicas
Consideraremos que nuestra base de datos está formada por
ítems
.
Un ítem puede representar:
Una tabla.
Las
instrucciones atómicas
básicas de una transacción sobre la
base de datos serán:
leer<sub>item</sub>(X):
Lee el valor del ítem X , cargándolo en una variable
en memoria
escribir<sub>item</sub>(X):
Ordena escribir el valor que está en memoria del
ítem X en la base de datos
Nota: El tamaño de ítem escogido se conoce como
granularidad
,
y afecta sustancialmente al control de concurrencia.
[ELM16 21.5]
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 20.1.2]
</p>






<p>
Page 12
</p>
















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Observaciones
Observación 1:
Desde ya que habrá otras instrucciones que
pero las mismas no afectan el análisis de concurrencia.
Observación 2:
Ordenar escribir no es lo mismo que
quedar temporalmente en un buffer en memoria.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 13
</p>



















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Transacciones
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 14
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Transacciones
Transacciones
Concepto
Una
transacción
es una unidad lógica de trabajo en los SGBD.
Ejemplos:
La reserva de un pasaje aéreo.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 15
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Propiedades ACID
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 16
</p>























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Propiedades ACID
Transacciones
Propiedades ACID
4 propiedades deseables, conocidas como
propiedades ACID
</p>
<pre class="example">


</pre>
<p>
Atomicidad:
Desde el punto de vista del usuario, las transacciones
la transacción se realiza por completo, o bien no se realiza.
Consistencia:
Cada ejecución, por sí misma, debe preservar la
datos en todo momento.
restricción que no pueda haber más de un gerente por departamento.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 17
</p>

















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Propiedades ACID
Transacciones
Propiedades ACID
aIslamiento:
El resultado de la ejecución concurrente de las
ejecución serial.
Durabilidad:
Una vez que el SGBD informa que la transacción se
independientemente de toda falla que pueda ocurrir.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 18
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Propiedades ACID
Transacciones
Recuperación
Para garantizar las propiedades ACID, los SGBD disponen de
mecanismos de recuperación
que permiten deshacer/rehacer una
transacción en caso de que se produzca un error o falla.
sean efectivamente almacenados.
cada transacción algunas instrucciones especiales:
begin:
Indica el comienzo de la transacción.
commit:
Indica que la transacción ha terminado exitosamente, y se
forma persistente.
abort:
Indica que se produjo algún error o falla, y que por lo tanto
back).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 19
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 20
</p>

















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
Anomalías
Problema de la lectura sucia
propiedades ACID.
La anomalía de la
lectura sucia (dirty read)
se presenta cuando
transacción que luego se deshace.
serial de las transacciones.
“Read uncommitted data”.
Es un conflicto de tipo WR (write-read).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 21
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
Anomalías
Problema de la lectura sucia: Ejemplo
T
1
transfiere 100 de la cuenta A a la cuenta B, mientras que T
2
$
900 respectivamente. Consideremos el siguiente solapamiento:
Transacción T
1
Transacción T
2
begin
begin
escribir<sub>item</sub>(A)
commit
abort
La lectura que hace T
2
de A es una lectura sucia, porque la
transacción T
1
luego será abortada.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 22
</p>

















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
Anomalías
Problema de la actualización perdida y lectura no repetible
La anomalía de la
actualización perdida (lost update)
ocurre
anteriormente por una primera transacción que aún no terminó.
ítem que leyó, el valor escrito por la segunda se perderá.
distinto. En este caso se lo conoce como
lectura no repetible
(unrepeatable read)
.
otro de tipo WW ó WR, respectivamente.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 23
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
Anomalías
Problemas de la actualización perdida y lectura no repetible: Ejemplo
La transacción T
1
realiza un depósito de $100 en la cuenta A,
mientras que T
2
extrae $100 de la misma. El saldo inicial de A es
de $500.
Transacción T
1
Transacción T
2
begin
begin
A = A + 100
A = A − 100
escribir<sub>item</sub>(A)
escribir<sub>item</sub>(A)
commit
commit
Claramente, el saldo final de la cuenta A debía ser de $500.
saldo de $400, porque T
2
lo actualizó después de que T
1
lo leyera.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 24
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
Anomalías
Problema de la escritura sucia
La anomalía de la
escritura sucia (dirty write)
ocurre cuando una
transacción T
2
escribe un ítem que ya había sido escrito por otra
transacción T
1
que luego se deshace.
por T
2
.
Transacción T
1
Transacción T
2
begin
begin
escribir<sub>item</sub>(A)
commit
abort
un conficto de tipo WW (write-write).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 25
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
Anomalías
Problema del fantasma
La anomalía del
fantasma (phantom)
se produce cuando una
transacciones.
puede producirse, atentando contra la serializabilidad
1
.
1
Para resolverla suelen necesitarse locks a nivel de tabla, o bien métodos de
snapshot isolation.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 26
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Anomalías de la ejecución concurrente
Anomalías
Problema del fantasma: Ejemplo
transacción T
1
calcula la cantidad de cuentas con saldo menor a
$
500 y cuando termina cuenta aquellas con saldo igual ó superior
B con saldo de $12000 y una cuenta C con saldo de $300.
Transacción T
1
Transacción T
2
begin
begin
menores<sub>500</sub>=1
escribir<sub>item</sub>(B)
mayores<sub>10000</sub>=1
commit
commit
Si T
1
volviera a ejecutarse, encontraría 2 cuentas con saldo
menor a $500.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 27
</p>



















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 28
</p>
























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
Notación
Transacción
siguiente notación breve para las instrucciones:
R
T
(
X ):
La transacción T lee el ítem X .
W
T
(
X ):
La transacción T escribe el ítem X .
b
T
</p>
<pre class="example">


</pre>
<p>
Comienzo de la transacción T .
c
T
</p>
<pre class="example">


</pre>
<p>
La transacción T realiza el commit.
a
T
</p>
<pre class="example">


</pre>
<p>
Se aborta la transacción T (abort).
Con esta notación, podemos escribir una transacción general T
como una lista de instrucciones {I
1
T
;
I
2
T
; &#x2026;;
I
m(T )
T
}, en donde m(T )
Ejemplo:
T
1
</p>
<pre class="example">


</pre>
<p>
b
T
1
;
R
T
1
(
X ); R
T
1
(
Y ); W
T
1
(
Y ); c
T
1
;
T
2
</p>
<pre class="example">


</pre>
<p>
b
T
2
;
R
T
2
(
X ); W
T
2
(
X ); c
T
2
;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 20.4.1]
</p>






<p>
Page 29
</p>






















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
Notación
Solapamiento
Un
solapamiento
entre dos transacciones T
1
y T
2
es una lista de
m(T
1
) +
m(T
2
)
instrucciones, en donde cada instrucción de T
1
y
T
2
aparece una única vez, y las instrucciones de cada transacción
conservan el orden entre ellas dentro del solapamiento.
¿Cuántos solapamientos distintos existen entre T
1
y T
2
?
→
(
m(T
1
)+
m(T
2
))!
m(T
1
)!
m(T
2
)!
En el ejemplo anterior, podemos representar un
solapamiento
entre T
1
y T
2
de la siguiente manera:
b
T
1
;
R
T
1
(
X ); b
T
2
;
R
T
2
(
X ); W
T
2
(
X ); R
T
1
(
Y ); W
T
1
(
Y ); c
T
2
;
c
T
1
;
serializable ó no.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 30
</p>
























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
Ejecución serial
Definición
Dado un conjunto de transacciones T
1
,
T
2
, &#x2026;,
T
n
una
ejecución
serial
es aquella en que las transacciones se ejecutan por
completo una detrás de otra, en base a algún orden T
i
1
,
T
i
2
, &#x2026;,
T
i
n
.
Ejemplo:
T
1
</p>
<pre class="example">


</pre>
<p>
b
T
1
;
R
T
1
(
X ); R
T
1
(
Y ); W
T
1
(
Y ); c
T
1
;
T
2
</p>
<pre class="example">


</pre>
<p>
b
T
2
;
R
T
2
(
X ); W
T
2
(
X ); c
T
2
;
posibles:
b
T
1
;
R
T
1
(
X ); R
T
1
(
Y ); W
T
1
(
Y ); c
T
1
;
b
T
2
;
R
T
2
(
X ); W
T
2
(
X ); c
T
2
;
b
T
2
;
R
T
2
(
X ); W
T
2
(
X ); c
T
2
;
b
T
1
;
R
T
1
(
X ); R
T
1
(
Y ); W
T
1
(
Y ); c
T
1
;
transacciones? → n!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 20.5.1]
</p>






<p>
Page 31
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
Serializabilidad
Definición
T
1
,
T
2
, &#x2026;,
T
n
es
serializable
cuando la ejecución de sus
estado
equivalente
a aquél en que la hubiera dejado alguna
ejecución serial de T
1
,
T
2
, &#x2026;,
T
n
.
de las transacciones.
ejecución?
las transacciones, sino pensar en cualquier estado inicial posible.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 32
</p>
























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
Equivalencia de solapamientos
Nociones
órdenes de ejecución de transacciones:
poseen los mismos
conflictos
entre instrucciones.
estado inicial de la base de datos.
lectura R
T
i
(
X ) lee el valor escrito por la misma transacción j,
W
T
j
(
X ). Además se pide que en ambos órdenes la última
transacción.
conflictos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 33
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
Conflictos
Definición
Dado un orden de ejecución, un
conflicto
es un par de
instrucciones (I
1
,
I
2
)
ejecutadas por dos transacciones distintas T
i
y T
j
, tales que I
2
se encuentra más tarde que I
1
en el orden, y que
responde a alguno de los siguientes esquemas:
(
R
T
i
(
X ), W
T
j
(
X )): Una transacción escribe un ítem que otra leyó.
(
W
T
i
(
X ), R
T
j
(
X )): Una transacción lee un ítem que otra escribió.
(
W
T
i
(
X ), W
T
j
(
X )): Dos transacciones escriben un mismo ítem.
ítem X , y al menos una de las dos instrucciones es una escritura.
Todo par de instrucciones consecutivas (I
1
,
I
2
)
de un
en su ejecución (es decir, reemplazado por el par (I
2
,
I
1
)
)
obteniendo un solapamiento equivalente por conflictos al inicial.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 34
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
Serializabilidad por conflictos
Ejemplo
Indicar si el siguiente solapamiento de dos transacciones T
1
y T
2
es
R
T
1
(
A); W
T
1
(
A); R
T
2
(
A); W
T
2
(
A); R
T
1
(
B); W
T
1
(
B); R
T
2
(
B); W
T
2
(
B);
Comenzamos buscando los conflictos existentes:
(
W
T
1
(
A); R
T
2
(
A)), ((R
T
1
(
A), W
T
2
(
A)), ((W
T
1
(
A), W
T
2
(
A)),
(
W
T
1
(
B); R
T
2
(
B)), ((R
T
1
(
B), W
T
2
(
B)), ((W
T
1
(
B), W
T
2
(
B))
Observemos que T
2
podría realizar la lectura y escritura de B antes de
que T
1
realice la lectura y escritura de A, sin cambiar el resultado:
R
T
1
(
A); W
T
1
(
A); R
T
1
(
B); W
T
1
(
B); R
T
2
(
A); W
T
2
(
A); R
T
2
(
B); W
T
2
(
B);
Obtenemos así una ejecución serial (concretamente: T
1
,
T
2
) que es
Entonces el solapamiento es serializable por conflictos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 35
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Grafo de precedencias
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 36
</p>























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Grafo de precedencias
Grafo de precedencias
Construcción
ser evaluada con la construcción de un
grafo de precedencias
.
Dado un conjunto de transacciones T
1
,
T
2
, &#x2026;,
T
n
que acceden a
determinados ítems X
1
,
X
2
, &#x2026;,
X
p
de la base de datos, el grafo de
siguiente forma:
1
Se crea un nodo por cada transacción T
1
,
T
2
, &#x2026;,
T
n
.
2
Se agrega un arco entre los nodos T
i
y T
j
(con i 6= j) si y sólo si
existe algún conflicto de la forma (R
T
i
(
X
k
),
W
T
j
(
X
k
))
,
(
W
T
i
(
X
k
),
R
T
j
(
X
k
))
ó (W
T
i
(
X
k
),
W
T
j
(
X
k
))
.
Cada arco (T
i
,
T
j
)
en el grafo representa una
precedencia
entre T
i
y T
j
, e indica que para que el resultado sea equivalente por
serial T
i
debe T
j
preceder a (es decir, “ejecutarse antes que”) T
j
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 20.5.2]
</p>






<p>
Page 37
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Grafo de precedencias
Grafo de precedencias
Construcción
recurso que causa el conflicto.
Conflicto RW:
R
T
1
(
X ); W
T
2
(
X );
T2
T1
X
Conflicto WR:
W
T
1
(
X ); R
T
2
(
X );
T2
T1
X
Conflicto WW:
W
T
1
(
X ); W
T
2
(
X );
T2
T1
X
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 38
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Grafo de precedencias
Grafo de precedencias
Ejemplo
Ejemplo
Construya el grafo de precedencias del siguiente solapamiento:
Transacción T
1
Transacción T
2
Transacción T
3
Transacción T
4
leer<sub>item</sub>(X)
leer<sub>item</sub>(X)
escribir<sub>item</sub>(Y)
leer<sub>item</sub>(Y)
escribir<sub>item</sub>(X)
escribir<sub>item</sub>(Y)
escribir<sub>item</sub>(W)
escribir<sub>item</sub>(Z)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 39
</p>
















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Grafo de precedencias
Grafo de precedencias
Ejemplo
Solución
T1
T2
T3
T4
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 40
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Serializabilidad
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Grafo de precedencias
Grafo de precedencias
Resultados
grafo de precedencias no tiene ciclos.
de precedencias, utilizando el
algoritmo de ordenamiento
topológico
.
Dado un grafo dirigido acíclico, un
orden topológico
es un
constituirá un orden topológico del grafo.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 41
</p>



















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 42
</p>






















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
Control de concurrencia
Enfoques
aislamiento admite dos enfoques:
Enfoque optimista:
Consiste en “dejar hacer” a las transacciones, y
descubre un conflicto.
conflicto es baja.
Enfoque pesimista:
Busca garantizar que no se produzcan
conflictos. Existen distintas variantes del mismo:
Control de concurrencia basado en locks.
Control de concurrencia basado en timestamps.
Control de concurrencia multiversión (MVCC).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 43
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 44
</p>
















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
Control de concurrencia
Control de concurrencia basado en locks
use en forma simultánea.
especiales en medio de la transacción.
ejecución.
serializabilidad utilizando locks.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 45
</p>























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Locks
Control de concurrencia
Locks
Son una herramienta para resolver el problema de la
exclusión
mutua
.
Un lock debe disponer de dos
primitivas
de uso, que permiten
tomar y liberar el recurso X asociado al mismo:
Acquire(X)
ó
Lock(X)
(L(X)).
Release(X)
ó
Unlock(X)
(U(X)).
estar solapada con una ejecución semejante en otra transacción.
¡No trivial! Lock (X ) requiere leer y escribir una variable.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 21.1.1]
</p>






<p>
Page 46
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Locks
Control de concurrencia
Locks - Ejemplo
Ejemplo:
Transacción T
1
Transacción T
2
begin
begin
unlock(B)
unlock(B)
commit
commit
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 47
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Locks
Control de concurrencia
Tipos de locks
tipos de locks principales son:
Locks de escritura
o “de acceso exclusivo”.
Locks de lectura
o “de acceso compartido”.
ningún tipo sobre ese mismo ítem.
compartido (SH, shared) sobre un mismo ítem simultáneamente.
Tabla de compatibilidad de locks:
↓ Se puede otorgar otro de tipo
Si alguien tiene un lock →
SH
EX
SH
3
7
EX
7
7
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 48
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Protocolo de lock de dos fases
(2PL)
Control de concurrencia
Protocolo de lock de dos fases (2PL)
producirse la anomalía de la lectura no repetible.
liberación de locks es el
protocolo de lock de dos fases (2PL,
two-phase lock)
.
El 2PL se rige por la siguiente regla:
Protocolo de lock de dos fases (2PL)
lock que había adquirido.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 21.1.2]
</p>






<p>
Page 49
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Protocolo de lock de dos fases
(2PL)
Control de concurrencia
Protocolo de lock de dos fases (2PL)
transacción:
adquiridos decrece.
potenciales que antes no teníamos:
Inanición o postergación indefinida (livelock)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 50
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Deadlocks y livelocks
Control de concurrencia
Deadlocks
Un
deadlock
es una condición en que un conjunto de
de recursos que otra de ellas posee.
Transacción T
1
Transacción T
2
begin
begin
leer<sub>item</sub>(A)
leer<sub>item</sub>(B)
lock(B) †
lock(A) †
transacciones hubieran adquirido los locks en el mismo orden.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 21.1.3]
</p>






<p>
Page 51
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Deadlocks y livelocks
Control de concurrencia
Deadlocks - Mecanismos de prevención
Mecanismos de prevención de deadlocks:
1
(Lock (X
1
,
X
2
, &#x2026;
X
n
)
).
2
adquisición de locks.
3
Métodos basados en timestamps.
qué recursos serán necesarios de antemano.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 52
</p>






















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Deadlocks y livelocks
Control de concurrencia
Deadlocks - Métodos de detección
Mecanismos de detección de deadlocks:
1
Analizar el
grafo de alocación de recursos
</p>
<pre class="example">
un grafo dirigido que

</pre>
<p>
recurso.
solapamiento.
2
cual se aborta la transacción.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 53
</p>

















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia basado en locks
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Deadlocks y livelocks
Control de concurrencia
Inanición
La
inanición
es una condición vinculada con el deadlock, y ocurre
tiempo indefinido.
se elije siempre a la misma transacción para ser abortada.
lock.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 54
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia multiversión (MVCC)
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 55
</p>
























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Control de concurrencia multiversión (MVCC)
Control de concurrencia
Control de concurrencia multiversión (MVCC)
En el
control de concurrencia multiversión
, cada transacción ve
isolation.
Desventajas:
puede obligar a deshacer una de ellas.
fue la última vez que cada ítem se leyó/escribió.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 21.3]
</p>






<p>
Page 56
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 57
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Definición
propiedad de aislamiento.
implementar de una forma sencilla la propiedad de durabilidad.
Definición:
Un solapamiento es
recuperable
si y sólo si ninguna
hayan commiteado.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 20.4.2]
</p>






<p>
Page 58
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Ejemplos
Ejemplos:
b
T
1
;
r
T
1
(
X ); b
T
2
;
r
T
2
(
X ); w
T
1
(
X ); r
T
1
(
Y ); w
T
2
(
X ); c
T
2
;
w
T
1
(
Y ); C
T
1
;
¿Es recuperable? →
3
¿Es serializable? →
7
b
T
1
;
r
T
1
(
X ); b
T
2
;
w
T
1
(
X ); r
T
2
(
X ); r
T
1
(
Y ); w
T
2
(
X ); &#x2026;
Si T
2
commitea ahora, ¿el solapamiento es recuperable? →
7
(Si T
1
luego aborta, T
2
va a haber escrito en un forma persistente
datos inválidos.)
¿Recuperable ⇒ Serializable?
7
Falso
¿Serializable ⇒ Recuperable?
7
Falso
Un solapamiento serializable podría tener un conflicto WR.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 59
</p>






















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
El gestor de recuperación
que es almacenada por su
gestor de recuperación
en un log
El log almacena generalmente los siguientes registros:
(BEGIN, T
id
):
Indica que la transacción T
id
comenzó.
(WRITE, T
id
, X , x
old
, x
new
):
Indica que la transacción T
id
escribió el
ítem X , cambiando su viejo valor x
old
por un nuevo valor x
new
.
(READ, T
id
, X ):
Indica que la transacción T
id
leyó el ítem X
2
.
(COMMIT, T
id
):
Indica que la transacción T
id
committeó.
(ABORT, T
id
):
Indica que la transacción T
id
abortó.
efectos de la transacción en el momento de hacer el rollback.
2
En general no es necesario loguear los READ’s, pero los incluímos por motivos didácticos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 60
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Rollback
solapamiento que no sea recuperable.
Transacción T
1
Transacción T
2
begin
begin
escribir<sub>item</sub>(A)
commit
abort
deshacer los efectos de la transacción T
1
sin eliminar también los
efectos de T
2
, que ya commiteó.
Este tipo de solapamientos no debe producirse.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 61
</p>






















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Rollback
transacción T
j
es abortada, el SGBD debe mantener la
Si las modificaciones hechas por T
j
no fueron leídas por nadie,
entonces basta con procesar el log de T
j
en forma inversa para
Pero si una transacción T
i
leyó un dato modificado por T
j
,
entonces será necesario hacer el rollback de T
i
para volverla a
ejecutar. ¡Sería conveniente que T
i
no hubiera commiteado aún!
Resultado:
Si un solapamiento de transacciones es recuperable,
hayan commiteado.
¡Y puede que ésto produzca una
cascada de rollbacks
!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 62
</p>























<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Cascadas de rollbacks
Ejemplo:
b
T
1
;
r
T
1
(
X ); b
T
2
;
w
T
1
(
X ); r
T
2
(
X ); r
T
1
(
Y ); w
T
2
(
X ); w
T
1
(
Y ); C
T
1
;
c
T
2
;
¿Es recuperable? →
3
¿Es serializable? →
3
Pero, ¿qué sucede si T
1
aborta después de w
T
2
(
X )?
Transacción T
1
Transacción T
2
leer<sub>item</sub>(X)
begin
escribir<sub>item</sub>(X)
leer<sub>item</sub>(X)
leer<sub>item</sub>(Y)
escribir<sub>item</sub>(X)
commit
commit
Como T
2
lee un ítem que T
1
había modificado, la lectura que hace
T
2
ya no es válida. Entonces, T
2
deberá ser abortada en cascada.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 63
</p>






















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Cascadas de rollbacks
es más fuerte que la condición de recuperabilidad.
forma (W
T
i
(
X ); R
T
j
(
X )) sin que en el medio exista un commit c
T
i
.
¿Evita rollbacks en cascada ⇒ Recuperable?
3
Verdadero
¿Evita rollbacks en cascada ⇒ Serializable?
7
Falso
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 64
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Cascadas de rollbacks
¿Qué anomalía de las que vimos no cubre esta definición?
La actualización perdida.
Ejemplo:
Transacción T
1
Transacción T
2
leer<sub>item</sub>(X)
leer<sub>item</sub>(X)
leer<sub>item</sub>(Y)
escribir<sub>item</sub>(X)
abort
¿Es recuperable? →
3
¿Evita rollbacks en cascada? →
3
¿Es serializable? →
7
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 65
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Recuperabilidad
Recuperabilidad
Protocolo de lock de dos fases estricto (S2PL)
El
protocolo de 2PL estricto (S2PL)
emplea la siguiente regla:
Protocolo de lock de dos fases estricto (S2PL)
ser liberados después de haber commiteado la transacción.
En caso de no diferenciar tipos de lock, se convierte en
riguroso
</p>
<pre class="example">


</pre>
<p>
Protocolo de lock de dos fases riguroso (R2PL)
Los locks sólo pueden ser liberados después del commit.
Resultado:
S2PL y R2PL garantizan que todo solapamiento sea
producirán cascadas de rollbacks al deshacer una transacción.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 66
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Niveles de aislamiento
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 67
</p>




















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Niveles de aislamiento
Niveles de aislamiento
SQL
con el comando
SET TRANSACTION ISOLATION LEVEL
.
SET TRANSACTION ISOLATION LEVEL
READ UNCOMMITTED
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
READ COMMITTED
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
REPEATABLE READ
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SERIALIZABLE
;
Y para definir una transacción:
START TRANSACTION
[
ISOLATION LEVEL
&#x2026;]
&#x2026;. ( sql commands )
COMMIT
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ROLLBACK
ocurran.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>

<p>
[ELM16 20.6]
</p>






<p>
Page 68
</p>






















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Niveles de aislamiento
Niveles de aislamiento
Tabla de anomalías
producirse ó no ciertas anomalías:
1
precaución.
2
Read Committed: Evita la anomalía de lectura sucia.
3
Repeatable Read: Evita la lectura no repetible y la lectura sucia.
4
orden serial.
Nivel de aislamiento
Lectura sucia
Lectura no repetible
Fantasma
READ UNCOMMITTED
7
7
7
READ COMMITTED
3
7
7
REPEATABLE READ
3
3
7
SERIALIZABLE
3
3
3
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 69
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Niveles de aislamiento
Niveles de aislamiento
Aclaración
lo hacen.
(Berenson et al.
3
definen un nivel de aislamiento ’0’ en que ni
siquiera se evitan las escrituras sucias).
3
“A Critique of ANSI SQL Isolation Levels”, Berenson et al., SIGMOD ’95
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 70
</p>

















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Niveles de aislamiento
Niveles de aislamiento
Ejercicio
Ejercicio
¿Qué nivel de aislamiento logra este protocolo?
Respuesta
sucia).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 71
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Implementaciones
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 72
</p>





















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Implementaciones
Implementaciones
Oracle
Para evitar inconsistencias de lectura se utiliza un
control de
concurrencia multiversión
</p>
<pre class="example">


</pre>
<p>
datos que fueron commiteados en el momento t
1
en que comenzó
transacción que ya había comenzado antes de t
1
, se aplica un
Serializable.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 73
</p>



















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Implementaciones
Implementaciones
DB2
Tiene un complejo sistema de locks.
común es la tabla ó la fila.
El funcionamiento básico es:
Los Exclusive locks permiten actualizar el ítem.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 74
</p>



















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Implementaciones
Implementaciones
DB2
Por ejemplo&#x2026;
Mientras T
1
posee un update lock, T
2
puede pedir un share lock.
Mientras T
1
posee un share lock, T
2
puede pedir un update lock.
Mientras T
1
posee un update lock, T
2
no puede pedir un update
Mientras T
1
posee un exclusive lock, T
2
no puede pedir siquiera un
share lock.
fila en un lock de tabla.
Se pueden elegir 4 niveles de aislamiento distintos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 75
</p>

















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Implementaciones
Implementaciones
MS-SQL Server
multiversión.
tipos de locks.
Se implementan 5 niveles de aislamiento. El parámetro
ALLOW<sub>SNAPSHOT</sub><sub>ISOLATION</sub>
permite, en algunos de ellos, elegir
entre un control basado en locks y un control multiversión.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 76
</p>


















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bibliografía
1
Introducción
2
Transacciones
Propiedades ACID
3
Anomalías de la ejecución concurrente
4
Serializabilidad
Grafo de precedencias
5
Control de concurrencia
Control de concurrencia basado en locks
</p>

<p>
Control de concurrencia multiversión (MVCC)
6
Recuperabilidad
7
Niveles de aislamiento
8
Implementaciones
9
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>







<p>
Page 77
</p>

















<p>
Concurrencia y Transacciones
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bibliografía
Bibliografía
[ELM16] Fundamentals of Database Systems, 7th Edition.
R. Elmasri, S. Navathe, 2016.
Capítulo 20, Capítulo 21
[GM09] Database Systems, The Complete Book, 2nd Edition.
H. García-Molina, J. Ullman, J. Widom, 2009.
Capítulo 18, Capítulo 19
Implementation and Management, 6th Edition.
T. Connolly, C. Begg, 2015.
Capítulo 22
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
3 de octubre de 2018
</p>
</div>
<div id="postamble" class="status">
Last update: 2019-08-10 00:34
</div>
</body>
</html>
