<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-11-08 Fri 15:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Structured Query Language (SQL)</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/res/nostyle"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<div id="outline-container-org8b999ef" class="outline-2">
<h2 id="org8b999ef">Introducción</h2>
</div>
<div id="outline-container-orgf491886" class="outline-2">
<h2 id="orgf491886">Definición de Datos en SQL</h2>
</div>
<div id="outline-container-org7e064c0" class="outline-2">
<h2 id="org7e064c0">Manipulación de Datos en SQL</h2>
<div class="outline-text-2" id="text-org7e064c0">
</div>
<div id="outline-container-orgd020e10" class="outline-3">
<h3 id="orgd020e10">SELECT&#x2026;FROM&#x2026;WHERE</h3>
</div>
<div id="outline-container-orga402c1e" class="outline-3">
<h3 id="orga402c1e">JOIN</h3>
</div>
<div id="outline-container-org4829d40" class="outline-3">
<h3 id="org4829d40">Operaciones de conjuntos</h3>
</div>
<div id="outline-container-orgf69e86f" class="outline-3">
<h3 id="orgf69e86f">Ordenamiento y paginación</h3>
</div>
<div id="outline-container-org1f837a9" class="outline-3">
<h3 id="org1f837a9">GROUP BY&#x2026;HAVING</h3>
</div>
<div id="outline-container-org6d00d6d" class="outline-3">
<h3 id="org6d00d6d">Consultas anidadas</h3>
</div>
<div id="outline-container-org2dcd2cd" class="outline-3">
<h3 id="org2dcd2cd">ABM</h3>
</div>
<div id="outline-container-org0af9860" class="outline-3">
<h3 id="org0af9860">DROP’s</h3>
</div>
</div>

<div id="outline-container-org64f71bf" class="outline-2">
<h2 id="org64f71bf">Funciones y estructuras auxiliares</h2>
</div>

<div id="outline-container-org365cc41" class="outline-2">
<h2 id="org365cc41">Bibliografía</h2>
<div class="outline-text-2" id="text-org365cc41">
<p>
Recordemos que los
lenguajes
son las herramientas a través de
las cuales interactuamos con los modelos de datos.
dos tipos:
Lenguajes
de Definición de Datos
de Manipulación de Datos
Los
lenguajes de definición de datos
nos permiten expresar la
estructura y las restricciones de nuestro modelo de datos.
Los
lenguajes de manipulación de datos
nos permiten ingresar,
modificar, eliminar y consultar datos en nuestro modelo.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 5
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Características
SQL como DML
El lenguaje
SQL (Structured Query Language)
es hoy en día el
lenguaje estándar para la operación de bases de datos.
Como lenguaje de manipulación de datos, SQL:
Está basado en el cálculo relacional de tuplas.
Para ponernos de acuerdo&#x2026;
Modelo relacional
SQL
Relación
Tabla
Tupla
Fila
Atributo
Columna
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 6
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Ejemplo
que ganaron algún Oscar:
PELÍCULAS
nombre<sub>película</sub>
año
nombre<sub>director</sub>
cant<sub>oscars</sub>
Kill Bill
2003
Quentin Tarantino
0
Django Unchained
2012
Quentin Tarantino
2
Star Wars III
2005
George Lucas
0
Coco
2017
Lee Unkrich
2
SELECT
∗
FROM
Peliculas
WHERE
cant<sub>oscars</sub> &amp;gt;0;
nombre<sub>película</sub>
año
nombre<sub>director</sub>
cant<sub>oscars</sub>
Django Unchained
2012
Quentin Tarantino
2
Coco
2017
Lee Unkrich
2
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 7
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Historia
Language) y fue desarrollada por IBM Research (1974).
basado en SEQUEL fue Oracle (1979).
1986
•
Estándar ANSI-SQL.
1987
•
Estándar ISO-SQL.
1989
•
Una pequeña revisión introduce la definición de restricciones de integridad.
1992
•
Sale la segunda versión del estándar. Aparecen numerosos tipos de datos: DATE, TIME, VARCHAR. Se introduce
soporte para transacciones, esquemas, el NATURAL JOIN y la consulta de información de catálogo
(INFORMATION<sub>SCHEME</sub>).
1999
•
El SQL::1999 (SQL3) introduce numerosas mejoras: tipos de dato booleanos, la clausura transitiva (WITH
RECURSIVE), capacidades analíticas OLAP (CUBE, ROLLUP) y soporte para control de acceso basado en roles (RBAP).
Las versiones comienzan a dividirse en varias partes.
2003
•
SQL::2003. Algunas novedades son: el CREATE TABLE AS SELECT, los MERGE de tablas, los tipos de dato XML y el
mapeo SQL/XML.
2006
•
SQL::2006. Crece la integración con XML, permitiendo la creación y manipulación de documentos XML desde SQL.
2008
•
pattern matching y triggers de INSTEAD OF.
2011
•
temporales.
2016
•
pattern matching de filas.
1
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 8
</p>























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Estructura del estándar
El estándar ISO SQL tiene actualmente 9 partes:
ISO/IEC 9075-14: XML Related Specifications (SQL/XML)
Se llama
Core SQL a los requerimientos incluídos en las partes 2
la conformance mínima al estándar.
El estándar SQL es abierto pero no es gratuito. En
<a href="http://modern-sql.com/standard">http://modern-sql.com/standard</a>
pueden encontrar drafts
muy cercanos a la publicación de algunas versiones.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[SQL]
</p>






<p>
Page 9
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Características
SQL como gramática libre de contexto
SQL es una
gramática libre de contexto (context-free grammar,
CFG)
. Ésto implica que su sintaxis puede ser descripta a través
de reglas de producción.
Una de las notaciones más conocidas para CFG’s es la
notación
de Backus-Naur (Backus-Naur form, BNF)
. Esta es la notación
adoptada en el estándar.
El sitio
<a href="https://jakewheat.github.io/sql-overview/">https://jakewheat.github.io/sql-overview/</a>
sql-2011-foundation-grammar.html
recopila la gramática
de la Parte 2 del estándar.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[SQL PART1 6; SQLGRAM]
</p>






<p>
Page 10
</p>
















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
SQL como gramática libre de contexto
Especificación: Ejemplo
&amp;lt; query specification &amp;gt; ::=
SELECT
[ &amp;lt;set quantifier &amp;gt; ] &amp;lt; select list &amp;gt; &amp;lt; table expression &amp;gt;
&amp;lt;set quantifier &amp;gt; ::=
DISTINCT
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ALL
&amp;lt; select list &amp;gt; ::=
&amp;lt; asterisk &amp;gt;
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&amp;lt; select sublist &amp;gt; [ { &amp;lt;comma &amp;gt; &amp;lt; select sublist &amp;gt; }&#x2026; ]</td>
</tr>
</tbody>
</table>
<p>
&amp;lt; table expression &amp;gt; ::=
&amp;lt; from clause &amp;gt;
[ &amp;lt; where clause &amp;gt; ]
[ &amp;lt; group by clause &amp;gt; ]
[ &amp;lt; having clause &amp;gt; ]
[ &amp;lt; window clause &amp;gt; ]
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 11
</p>















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Recursos utilizados en esta clase
Stack Exchange Data Explorer
<a href="https://data.stackexchange.com/stackoverflow/query/new">https://data.stackexchange.com/stackoverflow/query/new</a>
Corre sobre un servidor SQL Server
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 12
</p>












<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 13
</p>
















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Stack Exchange Data Explorer
Modelo conceptual simplificado
Post
Id
Body
Score
CreationDate
IS A
total, disjunta
Question
Answer
answers
parent (1,1)
N
writes
N
User
(1,1)
receives
(1,1)
Comment
N
makes
(1,1)
N
User
(1,1)
contains
N
Tag
N
Id
TagName
Count
Text
Id
Score
Age
ViewCount
Title
DisplayName
Id
received
(1,1)
Badge
N
Id
Date
IS A
parcial
Tag-based Badge
Non tag-based Badge
Name
applies
N
(1,1)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 14
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Stack Exchange Data Explorer
Diagrama de tablas simplificado
Posts
Id
PK
ParentId
FK
Title
Body
OwnerUserId
FK
ViewCount
Score
Users
Id
PK
DisplayName
Age
Badges
Id
PK
UserId
FK
TagBased
Name
Date
PostTags
       PostId
PK, FK
       TagId
PK, FK
Tags
Id
PK
TagName
Count
Comments
Id
PK
PostId
FK
UserId
FK
Text
Score
Esta es una visualización comunmente utilizada del modelo lógico relacional. No estudiaremos estos diagramas en el curso, pero
aquí utilizamos uno para ilustrar la estructura de la base de datos de Stack Exchange. Encontrarán un diagrama más completo
en
<a href="https://meta.stackexchange.com/questions/250396/database">https://meta.stackexchange.com/questions/250396/database</a>- diagram- of- stack- exchange- model
.
También, en el panel de la derecha del Data Explorer se muestra la descripción completa de cada tabla.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 15
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
1
Introducción
2
Definición de Datos en SQL
3
Manipulación de Datos en SQL
SELECT&#x2026;FROM&#x2026;WHERE
JOIN
</p>

<p>
GROUP BY&#x2026;HAVING
</p>

<p>
DROP
’s
4
Funciones y estructuras auxiliares
5
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 16
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
CREATE SCHEMA
Creación de una base de datos
El comando
CREATE SCHEMA
nos permite crear un nuevo esquema
Su sintaxis es:
CREATE SCHEMA
nombre<sub>esquema</sub> [
AUTHORIZATION
AuthId ];
Ejemplo:
CREATE SCHEMA
empresa [
AUTHORIZATION
mbeiro ];
La opción
AUTHORIZATION
identifica quién será el
dueño
del
datos. Los esquemas se agrupan en colecciones denominadas
catálogos
.
Todo catálogo contiene un esquema llamado
INFORMATION<sub>SCHEMA</sub>
,
que describe a todos los demás esquemas contenidos en él.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 17
</p>




















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
Tipos de variables en SQL
Tipos numéricos estándar:
INTEGER
</p>
<pre class="example">
Tipo entero. Abreviado INT.

</pre>
<p>
SMALLINT:
Tipo entero pequeño.
FLOAT(n)
</p>
<pre class="example">
Tipo numérico aproximado. n indica la precisión en bits.

</pre>
<p>
DOUBLE PRECISION:
Tipo numérico aproximado de alta precisión.
→En Postgres, double precision f-p, IEEE 754 (n=53, e=11)
NUMERIC(i,j)
</p>
<pre class="example">
Tipo numérico exacto. Permite especificar la

</pre>
<p>
precisión
dígitos totales
(i)
y la escala
dígitos decimales
(j)
en dígitos.
Strings:
Se delimitan con comillas simples (’).
CHARACTER(n)
</p>
<pre class="example">
De longitud fija. Abreviado CHAR(n).

</pre>
<p>
→default, n=1
CHARACTER VARYING(n)
</p>
<pre class="example">
De longitud variable. Abrev. VARCHAR(n).

</pre>
<p>
Fecha y hora:
DATE
</p>
<pre class="example">
Precisión de días. Se ingresa como string con formato

</pre>
<p>
YYYY-MM-DD.
→(ISO 8601)
TIME(i)
</p>
<pre class="example">
Precisión de hasta microsegundos. Se ingresa como

</pre>
<p>
string con formato HH:MM:SS.[0-9]
i
(ISO 8601). Tantos dígitos
decimales como i.
TIMESTAMP(i)
</p>
<pre class="example">
Combina un DATE y un TIME(i).

</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.1.3]
</p>






<p>
Page 18
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
Tipos de variables en SQL
Booleanos (opcional):
BOOLEAN
</p>
<pre class="example">
TRUE, FALSE o UNKNOWN. Se emplea lógica de tres valores.

</pre>
<p>
Otros tipos:
CLOB
</p>
<pre class="example">
(Character Large Object) Para documentos de texto de

</pre>
<p>
gran extensión.
BLOB
</p>
<pre class="example">
(Binary Large Object) Para archivos binarios de gran

</pre>
<p>
extensión.
Tipos definidos por el usuario:
CREATE DOMAIN
NOMBRE<sub>DOMINIO</sub>
AS
TIPO<sub>BASICO</sub> ;
Ejemplo:
CREATE DOMAIN
CODIGO<sub>PAIS</sub>
AS CHAR
(2);
Facilita la realización de cambios futuros en el diseño.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 19
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
CREATE TABLE
Creación de una tabla
El comando
CREATE TABLE
nos permite definir la estructura de una
tabla:
CREATE TABLE
Persona (
dni<sub>persona</sub>
INT PRIMARY KEY
,
nombre<sub>persona</sub>
VARCHAR
(255) ,
fecha<sub>nacimiento</sub>
DATE
);
CREATE TABLE
HijoDe (
dni<sub>hijo</sub>
INT
,
dni<sub>padre</sub>
INT
,
PRIMARY KEY
( dni<sub>hijo</sub> , dni<sub>padre</sub> ),
FOREIGN KEY
( dni<sub>hijo</sub> )
REFERENCES
Persona ( dni<sub>persona</sub> ),
FOREIGN KEY
( dni<sub>padre</sub> )
REFERENCES
Persona ( dni<sub>persona</sub> ));
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 20
</p>

























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
CREATE TABLE
Creación de una tabla
CREATE TABLE T
1
(
A
1
type
1
[NOT NULL] [CHECK condition
1
] [PRIMARY KEY],
A
2
type
2
[NOT NULL] [CHECK condition
2
] [PRIMARY KEY],
A
n
type
n
[NOT NULL] [CHECK condition
n
] [PRIMARY KEY],
[
PRIMARY KEY (A
p
1
,
A
p
2
, &#x2026;,
A
p
k
)
]
{
UNIQUE (A
u
1
,
A
u
2
, &#x2026;,
A
u
k
)
} &#x2026;
{
FOREIGN KEY (A
h
1
,
A
h
2
, &#x2026;,
A
h
k
)
REFERENCES T
2
(
B
f
1
,
B
f
2
, &#x2026;,
B
f
00
k
)
[ON DELETE }&#x2026;);
Creación de una tabla: estructura general
defecto (
DEFAULT
) o autoincrementales (
AUTO<sub>INCREMENT</sub>
).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 21
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
Restricciones de dominio
Además de definir el tipo de una columna, es posible:
Restringir la posibilidad de que tome un valor nulo (NOT NULL).
fecha<sub>nac</sub>
DATE NOT NULL
,
“chequeo en forma dinámica”:
CUIT<sub>tipo</sub>
INT CHECK
( CUIT<sub>tipo</sub> =20)
OR
( CUIT<sub>tipo</sub> =23)
OR
&#x2026;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.2.1]
</p>






<p>
Page 22
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
Restricciones de unicidad
La clave primaria se indica con
PRIMARY KEY
. Si está compuesta
de una única columna, puede indicarse a continuación del tipo.
Con la palabra clave
UNIQUE
se indica que una columna o conjunto
de columnas no puede estar repetido en dos filas distintas.
Es una manera de identificar claves candidatas.
Atención!
SQL no obliga a definir una clave primaria, pero
siempre deberíamos hacerlo.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.2.2]
</p>






<p>
Page 23
</p>
















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
Restricciones de integridad
Integridad de entidad
La clave primaria de una tabla nunca debería ser
NULL
, aunque
algunos SGBD’s lo permiten.
Integridad referencial
Las claves foráneas se especifican con
FOREIGN KEY&#x2026;REFERENCES
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 24
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Definición de Datos en SQL
SQL vs. modelo relacional
Diferencias
elementos son las tuplas.
Por lo tanto, una tupla no puede estar repetida en una relación.
una tabla.
Este concepto se conoce como
multiset
o
bag of tuples
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.3.4]
</p>






<p>
Page 25
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
1
Introducción
2
Definición de Datos en SQL
3
Manipulación de Datos en SQL
SELECT&#x2026;FROM&#x2026;WHERE
JOIN
</p>

<p>
GROUP BY&#x2026;HAVING
</p>

<p>
DROP
’s
4
Funciones y estructuras auxiliares
5
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 26
</p>






















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
Esquema básico de consulta
El esquema básico de una consulta en SQL es:
SELECT A
1
, A
2
, &#x2026;, A
n
FROM T
1
, T
2
, &#x2026;, T
m
[
WHERE condition ];
En donde A
1
,
A
2
, &#x2026;,
A
n
es una lista de nombres de columnas,
T
1
,
T
2
, &#x2026;,
T
m
es una lista de nombres de tablas, y condition es
Es el análogo a la siguiente expresión del álgebra relacional:
π
A
1
,
A
2
,&#x2026;,
A
n
(σ
condition
(
T
1
× T
2
× &#x2026; × T
m
))
repetidas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 27
</p>























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
WHERE
</p>
<pre class="example">
Condiciones

</pre>
<p>
Las condiciones atómicas admitidas dentro de la cláusula
WHERE
son:
A
i
 A
j
A
i
 c
, con c
∈ dom(A
i
)
A
i
[NOT] LIKE p
, en donde A
i
es un string y p es un patrón
(
A
i
,
A
i+1
, &#x2026;)
[NOT] IN m
, en donde m es un set o un multiset
A
i
[NOT] BETWEEN a AND b
, con a, b
∈ dom(A
i
)
A
i
IS [NOT] NULL
EXISTS t
, en donde t es una tabla
A
i
 [ANY |ALL] t
, en donde t es una tabla
En donde
 debe ser un operador de comparación:
&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=
(para columnas cuyos dominios están ordenados)
operadores lógicos permitidos son:
AND
, OR, NOT
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.3.1]
</p>






<p>
Page 28
</p>























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
FROM
</p>
<pre class="example">
Alias y ambigüedad

</pre>
<p>
En la cláusula
FROM
es posible indicar un
alias
para las tablas:
&#x2026;
FROM
Persona p &#x2026;
&#x2026;
FROM
Persona
AS
p &#x2026;
Cuando se selecciona una columna, si la misma es ambigua
se
deberá indicar el nombre de la tabla ó su alias.
SELECT
business . id
FROM
business &#x2026;
SELECT
b. id
FROM
business b &#x2026;
Si una tabla se utiliza dos veces en la cláusula
FROM
, será
es posible renombrar las columnas.
..
FROM
Persona
AS
p1 ( dni1 , nombre1 ), Personas
AS
p2 ( dni2 , nombre2 )..
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.3.2]
</p>






<p>
Page 29
</p>






















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
SELECT
</p>
<pre class="example">
Redenominación y operaciones

</pre>
<p>
resultado:
SELECT
p1 . nombre
AS
NPadre , p2 . nombre
AS
NHijo &#x2026;
Y realizar operaciones entre las columnas en el resultado:
SELECT
Producto . precio
∗
0.90
AS
precioDescontado &#x2026;
Las operaciones permitidas son:
Core-SQL)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 30
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
SELECT
</p>
<pre class="example">
Funciones de agregación

</pre>
<p>
Por último, podemos aplicar una
función de agregación
a cada
una de las columnas del resultado. Las más habituales son:
SUM(A)
Suma los valores de la columna A de todas las filas
COUNT([DISTINCT] A | *)
COUNT(A)
cuenta la cantidad de filas con valor no nulo de A.
COUNT(DISTINCT A)
cuenta la cantidad de valores distintos de A,
sin contar el valor nulo.
COUNT(*)
cuenta la cantidad de filas no nulas en el resultado. Con
DISTINCT
, cuenta la cantidad de filas no nulas distintas.
AVG(A)
nulos.
MAX(A)
Sólo para dominios ordenados.
MIN(A)
Sólo para dominios ordenados.
En este caso, el resultado colapsa a una única fila.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 31
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
Ejemplos
Cuente la cantidad de usuarios existentes en la base de datos.
SELECT COUNT
(
∗
)
FROM
Users ;
Cuente la cantidad de posts que son preguntas.
SELECT COUNT
(
∗
)
FROM
Posts p
WHERE
p. ParentId
IS NULL
;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 32
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
Omisión de la selección y de la proyección. Duplicados
cláusula
WHERE
.
escribiendo
SELECT *
.
La palabra clave
DISTINCT
después de la cláusula
SELECT
elimina
los duplicados en el resultado.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 33
</p>






















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
WHERE
</p>
<pre class="example">
Pattern matching

</pre>
<p>
La cláusula
WHERE
también permite condiciones de reconocimiento
de patrones para columnas que son strings.
&#x2026;
WHERE
attrib
LIKE
pattern ;
especiales en su interior:
_ (representa un caracter arbitrario)
% (representa cero o más caracteres arbitrarios)
Si se necesita un _ ó un % literal en el patrón, se debe escapear
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.3.5]
</p>






<p>
Page 34
</p>




















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
SELECT&#x2026;FROM&#x2026;WHERE
SELECT&#x2026;FROM&#x2026;WHERE
Ejemplos
están basados en tags.
SELECT DISTINCT
Name
FROM
Badges
WHERE
TagBased =0;
Liste los tags que utilizó el usuario ‘Jon Skeet’.
SELECT DISTINCT
t. TagName
FROM
Users u , Posts p , PostTags pt , Tags t
WHERE
pt . PostId =p. Id
AND
pt . TagId =t. Id
AND
p. OwnerUserId =u. Id
AND
u. DisplayName =
’Jon   Skeet ’
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 35
</p>























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
JOIN
JOIN
operador
JOIN
</p>
<pre class="example">


</pre>
<p>
Junta theta (./)
&#x2026;
FROM
R
INNER JOIN
S
ON
condition &#x2026;
Junta natural (
∗)
&#x2026;
FROM
R
NATURAL JOIN
S &#x2026;
junta deben coincidir en ambas tablas.
Junta externa ( ./, ./ , ./ )
&#x2026;
FROM
R
LEFT OUTER JOIN
S
ON
condition &#x2026;
&#x2026;
FROM
R
RIGHT OUTER JOIN
S
ON
condition &#x2026;
&#x2026;
FROM
R
FULL OUTER JOIN
S
ON
condition &#x2026;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 7.1.6]
</p>






<p>
Page 36
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
JOIN
JOIN
Ejemplo
el id del post, el título y la cantidad de vistas.
SELECT DISTINCT
p.Id , p. Title , p. ViewCount
FROM
((( Tags t1
INNER JOIN
PostTags pt1
ON
t1 . Id = TagId )
INNER JOIN
Posts p
ON
pt1 . PostId =p. Id )
INNER JOIN
PostTags pt2
ON
p. Id = pt2 . PostId )
INNER JOIN
Tags t2
ON
pt2 . TagId = t2 . Id
WHERE
t1 . TagName =
’ relational ’
AND
t2 . TagName =
’entity
−
relationship ’
;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 37
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Operaciones de conjuntos
Operaciones de conjuntos
SQL incorpora las 3 operaciones de conjuntos:
Unión (
∪)
&#x2026; R
UNION
[
ALL
] S &#x2026;
Intersección (
∩)
&#x2026; R
INTERSECT
[
ALL
] S &#x2026;
Diferencia (
−)
&#x2026; R
EXCEPT
[
ALL
] S &#x2026;
Tener en cuenta que:
R y S deben ser
union compatibles
.
Si no se agrega la palabra clave
ALL
, el resultado será un set en
vez de un multiset, y entonces no habrá filas repetidas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 38
</p>
























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Ordenamiento y paginación
Ordenamiento y paginación
Extendemos el esquema básico con la cláusula
ORDER BY
</p>
<pre class="example">


</pre>
<p>
SELECT A
1
,
A
2
, &#x2026;,
A
n
FROM T
1
,
T
2
, &#x2026;,
T
m
[
WHERE condition ]
[
ORDER BY A
k
1
[ ASC | DESC ], A
k
2
[ ASC | DESC ], &#x2026;];
Las
columnas de ordenamiento
A
k
1
,
A
k
2
, &#x2026;
deben pertenecer a
columnas de la proyección en la cláusula
SELECT
.
La
paginación
es la posibilidad de escoger un rango [t
inicio
,
t
fin
]
del
listado de filas del resultado.
La forma estándar es:
[OFFSET..ROWS] FETCH FIRST..ROWS ONLY
.
Algunos SGBD’s implementan otras cláusulas como
LIMIT
.
<a href="https://www.jooq.org/doc/3.10/manual/sql">https://www.jooq.org/doc/3.10/manual/sql</a>- building/sql- statements/select- statement/
limit- clause/
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 39
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Ordenamiento y paginación
Ordenamiento y paginación
Ejemplo
Ejemplo
cantidad de visitas que recibieron.
SELECT
Title , CreationDate , ViewCount
FROM
Posts
WHERE
CreationDate &amp;gt;=
’2017
−
01
−
01’
ORDER BY
ViewCount
DESC
OFFSET
0
ROWS FETCH FIRST
10
ROWS ONLY
;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 40
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
GROUP BY&#x2026;HAVING
Agregación
distintos tenistas en 2016:
CAMPEONES
nombre<sub>tenista</sub>
nombre<sub>torneo</sub>
premio
Novak Djokovic
Abierto de Australia
8.000.000
Rafael Nadal
Abierto de Barcelona
1.500.000
Novak Djokovic
Abierto de Madrid
2.500.000
Novak Djokovic
Roland Garros
5.000.000
Andy Murray
Abierto de China
2.500.000
Andy Murray
Master de Shangai
4.000.000
Juan Martín del Potro
Abierto de Estocolmo
300.000
Andy Murray
Master BNP Paribas
2.000.000
Andy Murray
ATP Tours Final de Londres
4.000.000
por cada tenista y su premio total anual.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 41
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
GROUP BY&#x2026;HAVING
Agregación
Para ello necesitamos agrupar los datos de cada tenista&#x2026;
CAMPEONES
nombre<sub>tenista</sub>
nombre<sub>torneo</sub>
premio
Novak Djokovic
Abierto de Australia
8.000.000
Novak Djokovic
Abierto de Madrid
2.500.000
Novak Djokovic
Roland Garros
5.000.000
Rafael Nadal
Abierto de Barcelona
1.500.000
Juan Martín del Potro
Abierto de Estocolmo
300.000
Andy Murray
Abierto de China
2.500.000
Andy Murray
Master de Shangai
4.000.000
Andy Murray
Master BNP Paribas
2.000.000
Andy Murray
ATP Tours Final de Londres
4.000.000
premios mostrando el total.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 42
</p>






















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
GROUP BY&#x2026;HAVING
Agregación
El resultado sería:
nombre<sub>tenista</sub>
nombre<sub>torneo</sub>
premio
Novak Djokovic
3
15.500.000
Rafael Nadal
1
1.500.000
Juan Martín del Potro
1
300.000
Andy Murray
4
12.500.000
La
agregación
colapsa las tuplas que coinciden en una serie de
En SQL, esto puede hacerse con la cláusula
GROUP BY
</p>
<pre class="example">


</pre>
<p>
SELECT
nombre<sub>tenista</sub> ,
COUNT
( nombre<sub>torneo</sub> ),
SUM
( premio )
FROM
Campeones
GROUP BY
nombre<sub>tenista</sub> ;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 43
</p>

























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
GROUP BY&#x2026;HAVING
GROUP BY&#x2026;HAVING
Esquema de consulta con agregación
La cláusula
GROUP BY
implementa la operación de agregación. El
esquema de una consulta con agregación es:
SELECT A
k
1
, A
k
2
, &#x2026;, f
1
(
B
1
)
, f
2
(
B
2
)
, &#x2026;, f
p
(
B
p
)
FROM T
1
, T
2
, &#x2026;, T
m
[
WHERE condition
1
]
GROUP BY A
1
, A
2
, &#x2026;, A
n
[
HAVING condition
2
]
[
ORDER BY A
k
1
[ ASC | DESC ], A
k
2
[ ASC | DESC ], &#x2026;];
A
1
,
A
2
, &#x2026;,
A
n
son las columnas de agrupamiento, y algunas de
ellas participan de la selección final. B
1
,
B
2
, &#x2026;,
B
p
no son
través de las
funciones de agregación
anteriormente
mencionadas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 7.1.8]
</p>






<p>
Page 44
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
GROUP BY&#x2026;HAVING
GROUP BY&#x2026;HAVING
Cláusula
HAVING
La cláusula
HAVING
es opcional, y nos permite seleccionar sólo
algunos de los grupos del resultado.
condition
2
es por lo tanto una condición que involucra funciones
agrupamiento en el
GROUP BY
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 45
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
GROUP BY&#x2026;HAVING
GROUP BY&#x2026;HAVING
Ejemplo
Ejemplo
taggeadas con ‘c#’ acumulan mayor puntaje.
SELECT
u. DisplayName ,
SUM
( resp . Score )
FROM
Users u , Posts resp , Posts preg , PostTags pt , Tags t
WHERE
u. Id = resp . OwnerUserId
AND
pt . PostId = preg . Id
AND
pt . TagId =t. Id
AND
t. TagName =
’c# ’
AND
resp . ParentId = preg . Id
GROUP BY
u.Id , u. DisplayName
ORDER BY SUM
( resp . Score )
DESC
OFFSET
0
ROWS FETCH FIRST
10
ROWS ONLY
;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 46
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
GROUP BY&#x2026;HAVING
GROUP BY&#x2026;HAVING
Ejemplo
Ejemplo
Liste los tags cuyo primer uso ocurrió después del 01/01/2018.
SELECT
t. TagName
FROM
Tags t , PostTags pt , Posts p
WHERE
t. Id = pt . TagId
AND
pt . PostId = p. Id
GROUP BY
t. TagName
HAVING MIN
(p. CreationDate ) &amp;gt;=
’2018
−
01
−
01’
;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 47
</p>























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Consultas anidadas
Consultas anidadas
Subqueries en la cláusula
WHERE
Es posible introducir una subconsulta SQL dentro de la cláusula
WHERE
de una consulta más general.
Recordemos: el resultado de una consulta es siempre una tabla.
Tip:
¡Cuando el resultado sólo contiene una fila con una única
columna, puede ser pensado y utilizado como un valor constante!
SELECT
&#x2026;
FROM
&#x2026;
WHERE
A
IN
(
SELECT
X
FROM
&#x2026;);
−−
Debe devolver una única columna
SELECT
&#x2026;
FROM
&#x2026;
WHERE
A = (
SELECT
X
FROM
&#x2026;);
−−
Debe devolver sólo 1 fila !
SELECT
&#x2026;
FROM
&#x2026;
−−
( feature opcional )
WHERE
(A , B)
IN
(
SELECT
X , Y
FROM
&#x2026;);
−−
Debe devolver 2 columnas
SELECT
&#x2026;
FROM
&#x2026;
WHERE
A &amp;lt; [
SOME
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ALL
] (
SELECT
X
FROM
&#x2026;);
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 7.1.2 7.1.3]
</p>






<p>
Page 48
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Consultas anidadas
Consultas anidadas
Subqueries en la cláusula
WHERE
que haya/n tenido la mayor cantidad de vistas.
SELECT
preg .Id , preg . Title , preg . ViewCount
FROM
Posts preg
WHERE
preg . ParentId
IS NULL
AND
ViewCount = (
SELECT MAX
( ViewCount )
FROM
Posts );
correlacionadas.
¡El costo de una subconsulta correlacionada es mucho más alto!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 49
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Consultas anidadas
Consultas anidadas
Cuantificadores:
ALL
y
SOME
para los que la cantidad de vistas es de al menos 2 millones.
SELECT
t. TagName , preg . Title , preg . ViewCount
FROM
Tags t , PostTags pt , Posts preg
WHERE
t. Id = pt . TagId
AND
pt . PostId = preg . Id
AND
preg . ParentId
IS NULL
AND
preg . ViewCount &amp;gt; 1000000
AND
ViewCount &amp;gt;=
ALL
(
SELECT
ViewCount
FROM
PostTags pt2 , Posts p
WHERE
pt2 . TagId = t. Id
AND
pt2 . PostId = p. Id );
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 50
</p>
















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Consultas anidadas
Bonus Track
Ejercicio
puntaje máximo tiene un puntaje de al menos 30000.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 51
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Consultas anidadas
Bonus Track: World Cup 2010 Dataset
Ejercicio 1
Selección Argentina.
Ejercicio 2
convirtieron 4 o más goles en el Mundial.
(Nota: No cuente los goles en series de penales ni los goles en contra (sólo cuentan los score<sub>types</sub> 1,2, 3 ó 4)
.
Ejercicio 3
Encuentre el nombre del jugador de mayor edad que participó del Mundial.
(Puede ejecutar estas consultas directamente desde la solapa SQL del RelaX. Tenga en cuenta que no podrá utilizar
subconsultas y que los alias en la cláusula FROM requieren de AS (ej., FROM Player AS p)).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 52
</p>






















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ABM
Inserciones
Las inserciones se realizan con el comando
INSERT INTO
. Dada
una tabla T con columnas A
1
,
A
2
, &#x2026;,
A
n
, se admiten las siguientes
posibilidades:
Insertar un listado de n-filas:
INSERT INTO (a
11
,
a
12
, &#x2026;,
a
1n
), (
a
21
,
a
22
, &#x2026;,
a
2n
),
&#x2026;, (
a
p1
,
a
p2
, &#x2026;,
a
pn
);
columnas en la tabla.
Insertar un listado de k -filas, con k &amp;lt; n
INSERT INTO T (A
i
1
,
A
i
2
, &#x2026;,
A
i
k
)
VALUES (a
1i
1
,
a
1i
2
, &#x2026;,
a
1i
k
), (
a
2i
1
,
a
2i
2
, &#x2026;,
a
2i
k
),
&#x2026;, (
a
pi
1
,
a
pi
2
, &#x2026;,
a
pi
k
);
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.4.1]
</p>






<p>
Page 53
</p>






















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ABM
Inserciones
Insertar el resultado de una consulta:
INSERT INTO T (A
i
1
,
A
i
2
, &#x2026;,
A
i
k
)
SELECT &#x2026;;
deben ser unión compatibles.
En cualquiera de los casos, si&#x2026;
Una clave foránea hace referencia a una clave no existente
&#x2026;
7
no se inserta.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 54
</p>























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ABM
Eliminaciones
La sintaxis para las eliminaciones es:
DELETE FROM condition;
Si no se especifican condiciones, se eliminan todas las filas.
una clave foránea desde otra tabla:
Si dicha clave foránea se configuró en ON DELETE CASCADE
3
Se eliminan todas las filas que referencian a ésta, y luego se
elimina t.
Si en cambio se configuró en ON DELETE SET NULL
3
Se ponen en
NULL
todas las claves foráneas de las filas que
referencian a ésta, y luego se elimina t.
Si se configuró en ON DELETE RESTRICT
7
No se elimina t.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.4.2]
</p>






<p>
Page 55
</p>






















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ABM
Modificaciones
Las modificaciones se realizan con el comando
UPDATE
.
UPDATE A
1
=
c
1
,
A
2
=
c
2
, &#x2026;,
A
k
=
c
k
WHERE condition;
Un único UPDATE puede modificar muchas filas.
Para cada fila t que cumpla la condición, si&#x2026;
existente
&#x2026;
7
entonces t no se actualiza.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[ELM16 6.4.3]
</p>






<p>
Page 56
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
ABM
Modificaciones
referenciada por una clave foránea desde otra tabla:
Si dicha clave foránea se configuró en ON UPDATE CASCADE
3
Se modifican todas las filas que referencian a ésta en forma
acorde, y luego se modifica t.
Si en cambio se configuró en ON UPDATE SET NULL
3
Se ponen en
NULL
todas las claves foráneas de las filas que
referencian a ésta, y luego se modifica t.
Si se configuró en ON UPDATE RESTRICT
7
No se modifica t.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 57
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Manipulación de Datos en SQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
DROP
’s
DROP SCHEMA
y
DROP TABLE
Una tabla se elimina con
DROP TABLE
.
DROP TABLE
T [
RESTRICT
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
CASCADE
];
Un esquema se elimina con
DROP SCHEMA
.
DROP SCHEMA
S [
RESTRICT
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
CASCADE
];
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 58
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
1
Introducción
2
Definición de Datos en SQL
3
Manipulación de Datos en SQL
SELECT&#x2026;FROM&#x2026;WHERE
JOIN
</p>

<p>
GROUP BY&#x2026;HAVING
</p>

<p>
DROP
’s
4
Funciones y estructuras auxiliares
5
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 59
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Manejo de strings
strings. Entre ellas:
SUBSTRING
(string FROM start FOR length)
</p>
<pre class="example">
Selecciona un

</pre>
<p>
substring desde la posición start y de largo length.
UPPER
(string)/
LOWER
(string)
</p>
<pre class="example">
Convierte el string a

</pre>
<p>
mayúsculas/minúsculas.
CHAR<sub>LENGTH</sub>
(string)
</p>
<pre class="example">
Devuelve la longitud del string.

</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>

<p>
[SQLDR Strings; SQLCOMP Functions and operators]
</p>






<p>
Page 60
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Conversión de tipos
CAST
(attr AS TYPE)
permite realizar conversiones entre tipos.
EXTRACT
(campo FROM attr)
permite extraer información de una
columna de fecha/hora (feature opcional).
SELECT
(
EXTRACT
(
DAY FROM
fecha ))
AS
dia ,
COUNT
( nro<sub>factura</sub> )
FROM
Facturas f;
GROUP BY
dia ;
MINUTE, SECOND, &#x2026;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 61
</p>




















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Conversión de tipos
Ejercicio
fecha de vencimiento de cada factura, con tipo de dato
DATE
. Complete
para ello el siguiente código.
SELECT
nro<sub>factura</sub> ,
CAST
(
&#x2026;.
AS DATE
)
AS
fecha<sub>venc</sub>
FROM
Facturas f;
Nota: Suponga que las mismas representan una fecha válida, y que todos los años tienen 4 dígitos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 62
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Conversión de tipos
Respuesta
SELECT
nro<sub>factura</sub> ,
CAST
(
CAST
(y
AS CHAR
) ||
’
−
’
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
SUBSTRING
((
’0 ’
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
CAST
( mes<sub>venc</sub>
AS VARCHAR
)
FROM
(2
−
CAST
( mes<sub>venc</sub> &amp;lt;10
AS INTEGER
)) FOR 2
) ||
’
−
’
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
SUBSTRING
((
’0 ’
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
CAST
( dia<sub>venc</sub>
AS VARCHAR
))
FROM
(2
−
CAST
( dia<sub>venc</sub> &amp;lt;10
AS INTEGER
)) FOR 2
)
AS DATE
)
AS
fecha<sub>venc</sub>
FROM
Facturas f;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 63
</p>























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Estructura
CASE WHEN..THEN..ELSE..END
La estructura
CASE
nos permite agregar cierta lógica de la
función de distintas condiciones.
padrón
apellido
nombre
primera<sub>op</sub>
primer<sub>rec</sub>
segundo<sub>rec</sub>
102111
Bertrán
Verónica
9
103553
Salamanca
Ernesto
2
7
104617
Guzmán
Claudia
8
105928
Sanz
Rubén
2
SELECT
padrón , apellido , nombre ,
CASE
WHEN
primera<sub>op</sub> &amp;gt;=4
OR
primer<sub>rec</sub> &amp;gt;=4
OR
segundo<sub>rec</sub> &amp;gt;=4
THEN
’ APROBÓ<sub>PARCIAL</sub> ’
ELSE
’ DESAPROBÓ<sub>PARCIAL</sub> ’
END AS
situacion<sub>parcial</sub>
FROM
Notas<sub>Parcial</sub> ;
→
padrón
apellido
nombre
situacion<sub>parcial</sub>
102111
Bertrán
Verónica
APROBÓ<sub>PARCIAL</sub>
103553
Salamanca
Ernesto
APROBÓ<sub>PARCIAL</sub>
104617
Guzmán
Claudia
APROBÓ<sub>PARCIAL</sub>
105928
Sanz
Rubén
DESAPROBÓ<sub>PARCIAL</sub>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 64
</p>




















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Estructura
CASE WHEN..THEN..ELSE..END
Solución alternativa usando CASE
SELECT
nro<sub>factura</sub> ,
CAST
(
CAST
(y
AS CHAR
) ||
’
−
’
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
CASE WHEN
mes<sub>venc</sub> &amp;gt;9
THEN
’’
ELSE
’0 ’
END
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
CAST
( mes<sub>venc</sub>
AS VARCHAR
)||
’
−
’
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
CASE WHEN
dia<sub>venc</sub> &amp;gt;9
THEN
’’
ELSE
’0 ’
END
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
CAST
( dia<sub>venc</sub>
AS VARCHAR
)
AS DATE
)
AS
fecha<sub>venc</sub>
FROM
Facturas f;
Nota: La comparación por mayor es una extensión, y puede no ser soportada por algunos SGBD’s. Se puede
reemplazar por LENGTH(CAST(mes<sub>venc</sub> AS VARCHAR))=2.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 65
</p>

























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Cláusula
WITH
(opcional según estándar)
La cláusula
WITH
permite construir una tabla auxiliar temporal
previa a una consulta. No es Core-SQL.
WITH T [(A
1
, A
2
, &#x2026;, A
n
)]
AS &amp;lt;query&amp;gt;;
WITH 1: Pseudocódigo
T = subquery (R
1
,
R
2
, &#x2026;);
return query (T , &#x2026;);
Listar los nombres de badges que tiene el usuario Jon Skeet.
WITH
Jon
AS
(
SELECT
Id
FROM
Users
WHERE
DisplayName =
’Jon   Skeet ’
)
SELECT DISTINCT
Name
FROM
Badges b , Jon j
WHERE
b. UserId = j. Id ;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 66
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
Cláusula
WITH
(opcional según estándar)
Ejercicio 1
más consultas.
Ayuda: Construya primero una tabla auxiliar que indique para cada usuario la cantidad de preguntas distintas que el
mismo respondió.
Ejercicio 2
forma [0,10), [10,100), [100,1000), &#x2026;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 67
</p>

























<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
WITH
recursivo
(opcional según estándar)
La cláusula
WITH RECURSIVE
amplia el poder expresivo de SQL
permitiendo encontrar la
clausura transitiva
de una consulta.
Dada una tabla T
1
que es input de una consulta, permite que el
resultado de la misma, T
2
← subquery(T
1
)
, sea utilizado en el
lugar de T
1
para volver a ejecutar la misma consulta.
Esto se repite hasta encontrar un punto fijo, i.e., T
i
=
subquery (T
i
)
.
WITH RECURSIVE T [(A
1
, A
2
, &#x2026;, A
n
)]
AS (&amp;lt;initial<sub>value</sub><sub>query</sub>&amp;gt;
UNION &amp;lt;subquery&amp;gt;)
&amp;lt;query with T&amp;gt;;
WITH recursivo 2: Pseudocódigo
T
0
=
initial<sub>value</sub><sub>query</sub> (R
1
,
R
2
, &#x2026;);
T
new
=
T
0
;
do
T = T
new
;
T
new
=
T
0
∪ subquery(T , R
1
,
R
2
, &#x2026;);
while T
new
6= T ;
return query (T , &#x2026;);
La consulta &amp;lt;initial<sub>value</sub><sub>query</sub>&amp;gt; no puede depender de T .
Tanto en
WITH
como en
WITH RECURSIVE
puede definirse más de
una tabla auxiliar antes de la consulta.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 68
</p>





















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Funciones y estructuras auxiliares
WITH
recursivo
(opcional según estándar)
Ejemplo
que sea necesario hacer.
WITH RECURSIVE
DestinosAlcanzables ( ciudad )
AS
(
VALUES
(
’ París ’
)
UNION
SELECT
v. ciudadHasta
AS
ciudad
FROM
DestinosAlcanzables d , Vuelos v
WHERE
d. ciudad = v. ciudadDesde
)
SELECT
ciudad
FROM
DestinosAlcanzables ;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 69
</p>


















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bibliografía
1
Introducción
2
Definición de Datos en SQL
3
Manipulación de Datos en SQL
SELECT&#x2026;FROM&#x2026;WHERE
JOIN
</p>

<p>
GROUP BY&#x2026;HAVING
</p>

<p>
DROP
’s
4
Funciones y estructuras auxiliares
5
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 70
</p>

















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bibliografía
Bibliografía
[ELM16] Fundamentals of Database Systems, 7th Edition.
R. Elmasri, S. Navathe, 2016.
Capítulo 6, Capítulo 7
Implementation and Management, 6th Edition.
T. Connolly, C. Begg, 2015.
Capítulo 6, Capítulo 7, Capítulo 8
[GM09] Database Systems, The Complete Book, 2nd Edition.
H. García-Molina, J. Ullman, J. Widom, 2009.
Capítulo 6, Capítulo 7
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 71
</p>



















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bibliografía
Bibliografía
Bibliografía relativa al estándar
[SQL] ISO/IEC 9075:2011 Standard
Estándar ISO, 2011
<a href="http://www.wiscorp.com/sql20nn.zip">http://www.wiscorp.com/sql20nn.zip</a>
.
[SQLGRAM] SQL::2011 Foundation Grammar
Gramática de la Parte 2 del estándar
<a href="https://jakewheat.github.io/sql-overview/">https://jakewheat.github.io/sql-overview/</a>
sql-2011-foundation-grammar.html
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>







<p>
Page 72
</p>

















<p>
Structured Query Language (SQL)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bibliografía
Bibliografía
Sitios comparativos DBMS’s vs. estándar
[SQLDR] SQL Dialects Reference
Wikibooks
https:
//en.wikibooks.org/wiki/SQL<sub>Dialects</sub><sub>Reference</sub>
.
[SQLCOMP] Comparison of different SQL implementations
T. Arvin
<a href="http://troels.arvin.dk/db/rdbms/">http://troels.arvin.dk/db/rdbms/</a>
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
12 de septiembre de 2018
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
Last update: 2019-11-08 15:45
</div>
</body>
</html>
