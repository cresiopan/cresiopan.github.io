<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-09-16 Wed 14:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Procesamiento de Consultas</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
<script type="text/javascript" src="/res/org-info.js"></script>
<script type="text/javascript" src="../res/org-info.js"></script>
<link rel="stylesheet" type="text/css" href="../res/org.css"/>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
<div id="content">
<div id="outline-container-org79e73bc" class="outline-1">
<h1 id="org79e73bc"><span class="section-number-1">1</span> Esquema de procesamiento</h1>
<div class="outline-text-1" id="text-1">
<p>
Imagen extraída de
<a href="http://web.cs.ucdavis.edu/~green/courses/ecs165a-w11/8-query.pdf">http://web.cs.ucdavis.edu/~green/courses/ecs165a-w11/8-query.pdf</a>.
</p>
</div>

<div id="outline-container-org9e004ed" class="outline-2">
<h2 id="org9e004ed"><span class="section-number-2">1.1</span> Información de catálogo</h2>
<div class="outline-text-2" id="text-1-1">
<p>
Los SGBD’s guardan distinto tipo de <b>información de catálogo</b> quees utilizada
para estimar costos y optimizar las consultas. Nosotros utilizaremos la
siguiente notación:
</p>
<ul class="org-ul">
<li>\(n(R)\): Cantidad de tuplas de la relación \(R\).</li>
<li>\(B(R)\): Cantidad de bloques de almacenamiento que ocupa \(R\).</li>
<li>\(V(A,R)\): Cantidad de valores distintos que adopta el atributo \(A\) en \(R\)
(variabilidad).</li>
<li>\(F(R)\): Cantidad de tuplas de R que entran en un bloque (factor de
bloque). \(F(R)=\ceil{\frac{n(R)}{B(R)}}\)</li>
</ul>

<p>
También se almacena información sobre la cantidad de nivelesque tienen los
índices construídos, y la cantidad de bloques queocupan sus hojas.
</p>
<ul class="org-ul">
<li>\(Height(I(A, R))\): Altura del índice de búsqueda \(I\) por el atributo \(A\) de la
relación \(R\).</li>
<li>\(Length(I(A, R))\): Cantidad de bloques que ocupan las hojas del índice \(I\).</li>
</ul>
</div>

<div id="outline-container-org818cdce" class="outline-3">
<h3 id="org818cdce"><span class="section-number-3">1.1.1</span> Mantenimiento</h3>
<div class="outline-text-3" id="text-1-1-1">
<p>
Actualizar la información de catálogo en cada operación de ABM puede ser muy
costoso.
</p>

<p>
Los SGBD’s suelen hacerlo con cierta periodicidad, o cuandoestán ociosos, o
cuando el usuario lo indica explícitamente.
</p>
</div>
</div>
</div>

<div id="outline-container-org7a3bd83" class="outline-2">
<h2 id="org7a3bd83"><span class="section-number-2">1.2</span> Plan de consulta y plan de ejecución</h2>
<div class="outline-text-2" id="text-1-2">
<p>
La optimización de una consulta se inicia con una expresión en álgebra
relacional.
</p>

<p>
La expresión se optimiza a través de una heurística y utilizando reglas de
equivalencia, obteniendo un plan de consulta.
</p>

<p>
Luego, cada plan de consulta <i>lógico</i>, se materializa para obtener un <b>plan
de ejecución</b> en el que se indica el procedimiento físico: estructuras de
datos a utilizar, índices, algoritmos a utilizar, etc.
</p>

<p>
Para comparar distintos planes de ejecución, necesitamos estimar su costo.
Algunos de los factores que inciden en la performance son:
</p>
<ul class="org-ul">
<li>El costo de acceso a disco (lectura o escritura)</li>
<li>El costo de procesamiento</li>
<li>El costo de uso de memoria</li>
<li>El costo de uso de red</li>
</ul>

<p>
Sólo estudiaremos los costos de acceso a disco, por ser los de mayor
envergadura en bases de datos relacionales centralizadas.
</p>
</div>
</div>
</div>

<div id="outline-container-orgec1fbdd" class="outline-1">
<h1 id="orgec1fbdd"><span class="section-number-1">2</span> Índices [ELM16 17.1]</h1>
<div class="outline-text-1" id="text-2">
<p>
Los índices son estructuras de búsqueda almacenadas y actualizadas por el
SGBD, que agilizan la búsqueda de registros a partir del valor de un atributo
o conjunto de atributos.
</p>

<p>
Pueden implementarse con distintas estructuras de datos:
</p>
<ul class="org-ul">
<li>Árboles (binarios, B, B+, B*, &#x2026;)</li>
<li>Tablas de hash</li>
</ul>

<p>
En los SGBD’s los índices se clasifican en distintos tipos:
</p>
<ul class="org-ul">
<li>Cuando el índice se construye sobre el campo de ordenamiento clave de un
archivo ordenado de registros, se denomina <b>índice primario.</b></li>
<li>Cuando se construye sobre el campo de ordenamiento del archivo físico pero
este no es clave, el índice se denomina <b>índice de clustering</b>.</li>
<li>Los índices que se construyen sobre campos que no son los campos de
ordenamiento del archivo se denominan <b>índices secundarios</b>.</li>
</ul>

<p>
Observación: Un archivo sólo puede tener un único índice primario o de
clustering.
</p>
</div>

<div id="outline-container-org60f3c5e" class="outline-2">
<h2 id="org60f3c5e"><span class="section-number-2">2.1</span> Definición en SQL</h2>
<div class="outline-text-2" id="text-2-1">
<p>
SQL no dispone de una sentencia estándar para la definición de índices,
aunque la mayoría de los SGBDs tiene una sentencia del tipo <code>CREATE INDEX</code>
con la siguiente sintaxis:
</p>

<p>
   #+BEGIN<sub>SRC</sub> sql
CREATE [UNIQUE] INDEX nombreIndice ON tabla (A1, &#x2026;, An); #+END<sub>SRC</sub>
</p>

<p>
PostgreSQL
</p>
<ul class="org-ul">
<li><code>ON tabla [ USING BTREE | GiST | HASH ](A1,...)</code></li>
<li>Para claves múltiples (más de un atributo) sólo se admite <code>BTREE</code>.</li>
<li>El comando <code>CLUSTER tabla [ USING nombreIndice ]</code> la reorganiza físicamente.</li>
</ul>

<p>
DB2
</p>
<ul class="org-ul">
<li><code>ON tabla (A1, A2, ..., An) [CLUSTER]</code></li>
<li>La opción <code>CLUSTER</code> indica que el índice será de ordenamiento.</li>
</ul>

<p>
SQLServer
</p>
<ul class="org-ul">
<li><code>CREATE INDEX nombre ON tabla (A1, A2, ..., An)</code> (Índice secundario)</li>
<li><code>CREATE CLUSTERED INDEX nombre ON tabla (A1, A2, ..., An)</code> (Índice de
ordenamiento -primario o de clustering-)</li>
<li><code>CREATE UNIQUE INDEX nombre ON tabla (A1, A2, ..., An)</code> (Índice de
no-ordenamiento sobre atributo clave)</li>
</ul>

<p>
MySQL
</p>
<ul class="org-ul">
<li><code>CREATE [ UNIQUE | FULLTEXT | SPATIAL ] INDEX nombre [USING BTREE | HASH ]</code></li>
<li><code>FULLTEXT</code> permite indexar tablas con datos de tipo <code>TEXT</code> para búsquedas con
<code>MATCH ... AGAINST</code>.</li>
<li><code>SPATIAL</code> permite indexar tipos de dato espaciales (<code>POINT</code> y <code>GEOMETRY</code>)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3b84f6b" class="outline-1">
<h1 id="org3b84f6b"><span class="section-number-1">3</span> Costos de los operadores</h1>
<div class="outline-text-1" id="text-3">
</div>
<div id="outline-container-orgb0e9c72" class="outline-2">
<h2 id="orgb0e9c72"><span class="section-number-2">3.1</span> Selección</h2>
<div class="outline-text-2" id="text-3-1">
<p>
Partimos de una selección básica del tipo &sigma;<sub>cond</sub>(R), en donde \(cond\)
es una condición atómica del tipo: A<sub>i</sub> \REL A<sub>j</sub> A<sub>i</sub> \REL c, con c &isin;
dom(A<sub>i</sub>) , en donde \REL es un operador de comparación.
</p>

<p>
Existen distintas estrategias de búsqueda, según los recursos con los que
contamos.
</p>

<p>
Analizaremos distintas situaciones para la comparación por igual.
</p>
</div>

<div id="outline-container-orgd3f0132" class="outline-3">
<h3 id="orgd3f0132"><span class="section-number-3">3.1.1</span> File scan vs Index scan [ELM16 18.3.1 19.4; GM09 15.6.2]</h3>
<div class="outline-text-3" id="text-3-1-1">
</div>
<div id="outline-container-orgb96579b" class="outline-4">
<h4 id="orgb96579b"><span class="section-number-4">3.1.1.1</span> File scan</h4>
<div class="outline-text-4" id="text-3-1-1-1">
<p>
Los métodos de <code>file scan</code> recorren el/los archivo/s en busca de los
registros que cumplen con la condición.
</p>

<p>
<code>Búsqueda lineal</code>: Consiste en explorar cada registro, analizando si se
verifica la condición. Cuando no queda otro camino&#x2026; \[cost(S_{1}) =
     B(R)\] (cantidad de bloques de la relación)
</p>
</div>
</div>

<div id="outline-container-org90c6ebc" class="outline-4">
<h4 id="org90c6ebc"><span class="section-number-4">3.1.1.2</span> Index scan</h4>
<div class="outline-text-4" id="text-3-1-1-2">
<p>
Los métodos de <code>index scan</code> utilizan un índice de búsqueda.
</p>

<p>
<code>Búsqueda con índice primario</code>: Cuando A<sub>i</sub> ó A<sub>j</sub> es un atributo clave
del que se tiene un índice primario.
</p>
<ul class="org-ul">
<li>Sólo una tupla puede satisfacer la condición.</li>
<li>Si utilizamos un árbol de búsqueda: \[cost(S_{3a}) = Height(I(A_{i}, R))+1\]</li>
<li>Si utilizamos una clave de hash: \[cost(S_{3b}) = 1\]</li>
</ul>

<p>
<code>Búsqueda con índice de clustering</code>: Cuando ni A<sub>i</sub> ni A<sub>j</sub> son atributos
clave pero se tiene un índice de ordenamiento (clustering) por alguno de
ellos.
</p>
<ul class="org-ul">
<li>Las tuplas se encuentran contiguas en los bloques, los cuales estarán
disjuntos. \[cost(S_{5}) = Height(I(A_{i},R)) +
       \ceil{\frac{n(R)}{V(A_{i},R)·F(R)}}\]</li>
</ul>

<p>
<code>Búsqueda con índice secundario</code>: Cuando ni A<sub>i</sub> ni A<sub>j</sub> tienen un índice
de clustering, pero existe un índice secundario asociado a uno de ellos.
\[cost(S_{6}) = Height(I(A_{i},R))+\frac{n(R)}{V(A_{i},R)}\]
</p>

<p>
Los cálculos que hemos visto pueden extenderse para otros tipos de
comparación \((<,\leq,>,\geq,\neq)\).
</p>
</div>
</div>
</div>

<div id="outline-container-org0b33530" class="outline-3">
<h3 id="org0b33530"><span class="section-number-3">3.1.2</span> Selecciones complejas</h3>
<div class="outline-text-3" id="text-3-1-2">
<p>
Si la selección involucra la <code>conjunción</code> de varias condiciones simples,
pueden adoptarse distintas estrategias:
</p>
<ul class="org-ul">
<li>Si uno de los atributos tiene un índice asociado, se aplica primero esta
condición, y luego se selecciona del resultado a aquellas tuplas que
cumplen con las demas condiciones.</li>
<li>Si hay un índice compuesto que involucra a atributos de más de una condición,
se utiliza este índice y luego se seleccionan las tuplas que cumplen los
demás criterios.</li>
<li>Si hay índices simples para varios atributos, se utilizan los índices por
separado y luego se intersecan los resultados.</li>
</ul>

<p>
Si la selección involucra una <code>disyunción</code> de condiciones simples, debemos
aplicar las mismas por separado y luego unir los resultados.
</p>
<ul class="org-ul">
<li>Si uno de los atributos no dispone de índice, hay que usar fuerza bruta.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdca1616" class="outline-2">
<h2 id="orgdca1616"><span class="section-number-2">3.2</span> Proyeccion [ELM16 18.5; GM09 15.2.2 15.5.2]</h2>
<div class="outline-text-2" id="text-3-2">
<p>
Dividiremos el análisis de la proyección &pi;<sub>X</sub>(R) en dos casos:
</p>
<ul class="org-ul">
<li><code>X</code> es superclave:
<ul class="org-ul">
<li>En este caso no es necesario eliminar duplicados.</li>
<li>El costo es R(B).</li>
</ul></li>
<li><code>X</code> no es superclave:
<ul class="org-ul">
<li>Debemos eliminar duplicados. Podemos:
<ul class="org-ul">
<li>Ordenar la tabla
<ul class="org-ul">
<li>Si &pi;<sub>X</sub>(R) &le; M podemos ordenar en memoria. De lo contrario, el
costo usando sort externo será: \[cost(\pi_{X}(R)) =
           B(R)+2.B(R).log_2(B(R))\]</li>
</ul></li>
<li>Utilizar una estructura hash de.
<ul class="org-ul">
<li>Si &pi;<sub>X</sub>(R) &le; M también podemos utilizar hashing en memoria, con
costo B(R). Utilizando hashing externo el costo es de \(3.B(R)\)</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
Observación: Si la consulta SQL no incluye <code>DISTINCT</code>, entónces el resultado
es un multiset, y el costo es siempre B(R).
</p>
</div>
</div>

<div id="outline-container-org2e0911e" class="outline-2">
<h2 id="org2e0911e"><span class="section-number-2">3.3</span> Junta</h2>
<div class="outline-text-2" id="text-3-3">
<p>
La operación de junta es una de las más frecuentes y demandantes.
</p>

<p>
Existen distintos métodos para calcularla:
</p>
<ul class="org-ul">
<li>Método de loops anidados por bloque</li>
<li>Método de único loop</li>
<li>Método sort-merge</li>
<li>Método de junta hash (variante GRACE)</li>
</ul>

<p>
Observación: A continuación presentaremos los métodos, y sólo indicaremos el
costo de lectura de datos y cálculo del resultado. Para calcular el costo de
almacenamiento (que no siempre se realiza para las operaciones intermedias)
es necesario estimar la cardinalidad del resultado.
</p>
</div>

<div id="outline-container-orgef0d30b" class="outline-3">
<h3 id="orgef0d30b"><span class="section-number-3">3.3.1</span> Método de loops anidados por bloque [ELM16 18.4.1 J1 19.5 J1; GM09 15.3.4]</h3>
<div class="outline-text-3" id="text-3-3-1">
<p>
Dadas dos relaciones R y S, el método de <code>loops anidados por bloque</code>
consiste en tomar cada par de bloques de ambas relaciones, y comparar todas
sus tuplas entre sí.
</p>

<p>
Si por cada bloque de R se leen todos los bloques de S, el costo de procesar
dicho bloque es 1+B(S), y el total es de <code>B(R)·(1+B(S))</code>. Utilizando las
tuplas de S como pivotes, el costo total sería de B(S)·(1+B(R)).
</p>

<p>
El costo del método es entonces:
</p>

<p>
\[cost(R*S) = min(B(R) +B(R)·B(S),B(S) +B(R)·B(S))\]
</p>

<p>
Esta estimación es un peor caso, suponiendo que sólo podemos tener un bloque
de cada tabla simultáneamente en memoria (M<sub>i</sub>=2). Si pudiéramos cargar las
tablas completas en memoria, tendríamos el mejor caso:
</p>

<p>
\[cost(R*S)=B(R)+B(S)\]
</p>
</div>
</div>

<div id="outline-container-org47a7289" class="outline-3">
<h3 id="org47a7289"><span class="section-number-3">3.3.2</span> Método de único loop [ELM16 18.4.1 J2 19.5 J2; GM09 15.3.4]</h3>
<div class="outline-text-3" id="text-3-3-2">
<p>
Si el atributo de junta tiene un índice asociado en R, por ejemplo, podemos
recorrer las tuplas de S y para cada una de ellas buscar en el índice la/s
tupla/s de R en que el atributo coincide.
</p>

<p>
Si el <code>índice es primario</code>, el costo será:
</p>

<p>
\[cost(R*S) = B(S)+n(S).(Height(I(A,R))+1)\]
</p>

<p>
Si el <code>índice es de clustering</code>, puede haber más de una coincidencia:
</p>

<p>
\[cost(R*S) = B(S) + n(S) . \left( Height(I(A,R)) + \ceil{
    \frac{n(R)}{V(A,R).F(R)} } \right)\]
</p>

<p>
Si el <code>índice es secundario</code>:
</p>

<p>
\[cost(R*S) = B(S) + n(S) . \left( Height(I(A,R)) + \frac{n(R)}{V(A,R).F(R)}
    \right)\]
</p>
</div>
</div>

<div id="outline-container-org50322de" class="outline-3">
<h3 id="org50322de"><span class="section-number-3">3.3.3</span> Ejemplo</h3>
</div>

<div id="outline-container-org66969ba" class="outline-3">
<h3 id="org66969ba"><span class="section-number-3">3.3.4</span> Método sort-merge</h3>
<div class="outline-text-3" id="text-3-3-4">
<p>
Consiste en ordenar los archivos de cada tabla por el/los atributo/s de
junta.
</p>

<p>
Si entran en memoria, el ordenamiento puede hacerse con quicksort, y el
costo de acceso a disco es sólo B(R)+B(S).
</p>

<p>
Si los archivos no caben en memoria debe utilizarse un algoritmo de sort
externo. El costo de peor caso de ordenar R y volverlo aguardar en disco
ordenado es de aproximadamente 2·B(R)·log<sub>2</sub>(B(R))
</p>

<p>
Una vez ordenados, se hace un merge de ambos archivos que sólo selecciona
aquellos pares de tuplas en que coinciden los atributos de junta.
</p>

<p>
El merge recorre una única vez cada archivo, con un costo de B(R)+B(S).
</p>

<p>
El costo total es entonces: \[cost(R*S) = 2·B(R)·log_{2}(B(R)) +
    2·B(S)·log_{2}(B(S)) + B(R)+B(S) \]
</p>
</div>
</div>

<div id="outline-container-orgf4d3262" class="outline-3">
<h3 id="orgf4d3262"><span class="section-number-3">3.3.5</span> Método de junta hash (variante GRACE) [ELM16 18.4.1 J4 19.5 J4]</h3>
<div class="outline-text-3" id="text-3-3-5">
<p>
La idea de este método es particionar las tablas R y S en m grupos
utilizando una función de hash h(X) aplicada sobre los atributos de junta X.
</p>

<p>
Atención: Que dos tuplas r &isin; R y s &isin; S cumplan que h(r.X) = h(s.X) no
implica que r.X = s.X!
</p>

<p>
Costo del particionado: 2·(B(R) +B(S))
</p>
<ul class="org-ul">
<li>Porque es necesario leer todos los bloques y reescribir sus datos en otro
orden.</li>
</ul>

<p>
Luego, cada par de grupos R<sub>i</sub> y S<sub>i</sub> se combina verificando si se cumple
la condición de junta con un enfoque de fuerza bruta.
</p>
<ul class="org-ul">
<li>Observación: No es necesario combinar R<sub>i</sub> y S<sub>j</sub> para i &ne; j</li>
<li>¿Por qué? r.X = s.X &rarr; h(r.X) = h(s.X)</li>
</ul>

<p>
<code>Que es R_{i}?</code>
</p>

<p>
Hipótesis: m fue escogido de manera que dos grupos R<sub>i</sub> y S<sub>i</sub> puedan
entrar en memoria simultáneamente.
</p>

<p>
Costo de la combinación de R<sub>i</sub> y S<sub>i</sub>: \(B(R_{i}) +B(S_{i})\)
</p>

<p>
Observación 1: F(R<sub>i</sub>) = F(R) y F(S<sub>i</sub>) = F(S)
</p>

<p>
Observación 2: &sum;<sup>m</sup><sub>i=1</sub> n(R<sub>i</sub>) = n(R) y &sum;<sup>m</sup><sub>i=1</sub> n(S<sub>i</sub>) =
n(S)
</p>

<p>
El costo total es: \[cost(R*S) = 3(B(R) + B(S))\]
</p>
</div>
</div>
</div>

<div id="outline-container-org1ce0371" class="outline-2">
<h2 id="org1ce0371"><span class="section-number-2">3.4</span> Pipelining</h2>
<div class="outline-text-2" id="text-3-4">
<p>
En muchos casos, el resultado de un operador puede ser procesado por el
operador siguiente en forma parcial (es decir sin necesidad de que el
operador anterior haya terminado de generar todas las tuplas).
</p>

<p>
Esta estrategia se denomina <code>pipelining</code>, y los SGBD suelen utilizarla en los
planes de ejecución siempre que sea posible.
</p>

<p>
Al calcular el costo de dos operadores anidados O<sub>2</sub>(O<sub>1</sub>(R)) debemos
considerar que en caso de utilizar pipelining, si la complejidad de O<sub>2</sub> es
menor o igual que la de O<sub>1</sub>, entonces el operador 2 no agregará costo al
plan de ejecución.
</p>
</div>

<div id="outline-container-org33a6d2f" class="outline-3">
<h3 id="org33a6d2f"><span class="section-number-3">3.4.1</span> Ejemplo</h3>
</div>
</div>
</div>

<div id="outline-container-org251a04b" class="outline-1">
<h1 id="org251a04b"><span class="section-number-1">4</span> Estimación de cardinalidad</h1>
<div class="outline-text-1" id="text-4">
</div>
<div id="outline-container-orgfba00af" class="outline-2">
<h2 id="orgfba00af"><span class="section-number-2">4.1</span> Concepto</h2>
<div class="outline-text-2" id="text-4-1">
<p>
Como parte de la estimación del costo de una consulta, es necesario a veces
estimar el tamaño de las relaciones intermedias (la cardinalidad) antes de
calcularlas.
</p>

<p>
Se espera que una estimación de cardinalidad cumpla con los siguientes
requisitos:
</p>
<ul class="org-ul">
<li>Sea precisa.</li>
<li>Sea fácil de calcular.</li>
<li>No dependa de la forma en que esa relación intermedia se calculó.</li>
</ul>

<p>
Veremos reglas de estimación de la cardinalidad a través de ejemplos para los
siguientes operadores:
</p>
<ul class="org-ul">
<li>Proyección</li>
<li>Selección</li>
<li>Junta</li>
</ul>
</div>
</div>

<div id="outline-container-orgf233d97" class="outline-2">
<h2 id="orgf233d97"><span class="section-number-2">4.2</span> Proyección</h2>
<div class="outline-text-2" id="text-4-2">
<p>
Ejemplo: Persona(DNI, nombre, f<sub>nacimiento</sub>, gnero)
</p>
<ul class="org-ul">
<li>40 millones de tuplas</li>
<li>El DNI es un entero de 4 bytes</li>
<li>El nombre es un string variable de tamaño promedio 15 bytes</li>
<li>La fecha de nacimiento es un timestamp de 4 bytes</li>
<li>El género es un caracter</li>
</ul>

<p>
Supongamos que los bloques son de 1024 bytes con un header de 24 bytes.
</p>

<p>
La estimación de la cantidad de bloques que ocupa la relación es:
</p>

<p>
\[B(Persona) = \frac{40.10^{6}.(4+15+4+1)}{10^{3}} = 960000\]
</p>

<p>
Ahora queremos estimar B(&pi;<sub>DNI</sub>(Persona)). La cantidad de tuplas no se
modifica, por lo tanto:
</p>

<p>
\[B(\pi_{DNI}(Persona)) = \frac{40.10^{6}.4}{10^{3}} = 160000\]
</p>
</div>
</div>

<div id="outline-container-org423b99c" class="outline-2">
<h2 id="org423b99c"><span class="section-number-2">4.3</span> Selección</h2>
<div class="outline-text-2" id="text-4-3">
<p>
La selección reduce el número de tuplas en el resultado, aunque mantiene el
tamaño de cada tupla.
</p>

<p>
Para estimar el tamaño de una selección de la forma &sigma;<sub>A<sub>i</sub>=c</sub>(R),
utilizaremos la variabilidad de A<sub>i</sub> en R(V(A<sub>i</sub>,R)), que es la cantidad de
valores distintos que puede tomar el atributo A<sub>i</sub> en dicha relación.
</p>

<p>
Realizaremos la siguiente estimación:
</p>

<p>
\[n(\sigma_{A_{i}=c}(R)) = \frac{n(R)}{V(A_{i},R)}\]
</p>

<p>
La fracción \frac{1}{V(A<sub>i</sub>,R)} se denomina <code>selectividad de A_{i} en R</code>.
</p>
</div>

<div id="outline-container-orgdeaba33" class="outline-3">
<h3 id="orgdeaba33"><span class="section-number-3">4.3.1</span> Ejemplo</h3>
<div class="outline-text-3" id="text-4-3-1">
<p>
Ejemplo: Persona(DNI,nombre,f<sub>nacimiento,gnero</sub>).
</p>

<p>
Para estimar n(&sigma;<sub>genero=′F′</sub>(Persona)), consideremos que hay dos
géneros posibles. Luego:
</p>

<p>
asdkjsdlkjf
</p>

<p>
Dificultades:
</p>
<ul class="org-ul">
<li>No nos permite estimar selecciones con otros operadores (≤,≥,6=).</li>
<li>La estimación asume que el valor c se toma al azar. Si no es así,entonces es
sesgada.</li>
</ul>

<p>
Un método más avanzado consiste en utilizar un histograma para la
distribución de A<sub>i</sub>.
</p>
</div>
</div>

<div id="outline-container-orgc401965" class="outline-3">
<h3 id="orgc401965"><span class="section-number-3">4.3.2</span> Estimación con histograma</h3>
<div class="outline-text-3" id="text-4-3-2">
<p>
El histograma nos resume la distribución de los valores que toma un atributo
en una instancia de relación dada.
</p>

<p>
Es útil cuando un atributo toma valores discretos.
</p>

<p>
Ejemplo: Película(id, nombre, género)
</p>

<p>
n(Película) = 728 V(género, Película) = 9
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">drama</td>
<td class="org-right">comedia</td>
<td class="org-right">suspenso</td>
<td class="org-right">otros</td>
</tr>

<tr>
<td class="org-left">Película.género</td>
<td class="org-right">150</td>
<td class="org-right">140</td>
<td class="org-right">128</td>
<td class="org-right">310</td>
</tr>
</tbody>
</table>

<p>
El histograma nos dice que n(&sigma;<sub>genero='comedia'</sub>(Película)) = 140
</p>

<p>
Podemos estimar mejor n(&sigma;<sub>genero='terror'</sub>(Película)) utilizando el
histograma?
</p>

<p>
n(&sigma;<sub>genero='terror'</sub>(Película)) = \frac{n(Película)-318}
{V(genero,Película)-3} = \frac{310}{6} = 52
</p>

<p>
<code>Creo que el 318 está mal. deberia ser 418</code>
</p>
</div>
</div>
</div>

<div id="outline-container-orgd3f1238" class="outline-2">
<h2 id="orgd3f1238"><span class="section-number-2">4.4</span> Junta</h2>
<div class="outline-text-2" id="text-4-4">
<p>
Consideremos la junta de R(A,B) y S(B,C).
</p>

<p>
En principio, 0 &le; n(R*S) &le; n(R)·n(S), dependiendo de como estén
distribuídos los valores de B en una y otra relación.
</p>

<p>
Dadas las variabilidades V(B,R) y V(B,S), asumiremos que los valores de B en
la relación con menor variabilidad están incluídos dentro de los valores de B
en la otra relación.
</p>
<ul class="org-ul">
<li>En el caso en que el atributo de junta es clave primaria en una relación y
clave foránea en la otra, la asunción es verdadera.</li>
</ul>

<p>
Supongamos que V(B,R) &ge; V(B,S) y tomemos una tupla en t<sub>R</sub> &isin; R y una
tupla en t<sub>S</sub> &isin; S. Sabemos que t<sub>S.B</sub> está incluído dentro de los valores
que toma B en R. Luego, \mathbb{P}(t<sub>S.B</sub> = t<sub>R.B</sub>) = \frac{1}{V(B,R)}.
</p>

<p>
De manera análoga, si V(B,R) &le; V(B,S) entonces que t<sub>R.B</sub> está incluído
dentro de los valores que toma B en S. Luego, \mathbb{P}(t<sub>R.B</sub> = t<sub>S.B</sub>) =
\frac{1}{V(B,S)}.
</p>

<p>
En general, \mathbb{P} (t<sub>R.B</sub> = t<sub>S.B</sub>) = \frac{1}{max(V(B,R),V(B,S))},
que es la selectividad de la junta (js). Luego:
</p>

<p>
\[n(R*S) = js . n(R) . n(S) = \frac{n(R)n(S)}{max(V(B,R),V(B,S))}\]
</p>

<p>
ejemplo asjdalkjs
</p>

<p>
Para estimar el factor de bloque del resultado, asumiremos que si una tupla
de R ocupa \frac{1}{F(R)} bloques y una tupla de S ocupa \frac{1}{F(S)}
bloques, entonces una tupla del resultado ocupa menos de
\frac{1}{F(R)}+\frac{1}{F(S)}, y por lo tanto el factor de bloque es al
menos:
</p>

<p>
\[F(R*S) = \left( \frac{1}{F(R)}+\frac{1}{F(S)} \right)^{-1}\]
</p>

<p>
La fórmula subestima el factor de bloque, porque no tiene en cuenta que los
atributos de junta se repiten en ambas tablas.
</p>

<p>
La cantidad de bloques será (sobreestimación): \[B(R*S) = \frac{js . n(R)
   . n(S)}{F(R*S)} = js . B(R) . B(S) . (F(R) + F(S))\]
</p>
</div>

<div id="outline-container-orga9a6c16" class="outline-3">
<h3 id="orga9a6c16"><span class="section-number-3">4.4.1</span> Estimación con histograma</h3>
<div class="outline-text-3" id="text-4-4-1">
<p>
Ejemplo:
</p>
<ul class="org-ul">
<li>R(A,B), con V(B,R)=18</li>
<li>S(B,C), con V(B,S)=15</li>
</ul>

<p>
Supongamos que disponemos de un histograma que nos muestra los k valores más
frecuentes de B en cada una de la relaciones.  En este caso, k=5.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">4</td>
<td class="org-right">12</td>
<td class="org-right">14</td>
<td class="org-right">20</td>
<td class="org-right">22</td>
<td class="org-right">30</td>
<td class="org-right">otros</td>
</tr>

<tr>
<td class="org-left">R.B</td>
<td class="org-right">200</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">320</td>
<td class="org-right">120</td>
<td class="org-right">150</td>
<td class="org-right">65</td>
<td class="org-right">550</td>
</tr>

<tr>
<td class="org-left">S.B</td>
<td class="org-right">150</td>
<td class="org-right">100</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">180</td>
<td class="org-right">210</td>
<td class="org-right">85</td>
<td class="org-right">410</td>
</tr>
</tbody>
</table>

<p>
Para cada valor de x<sub>i</sub> del que conocemos f<sub>R</sub>(x<sub>i</sub>)<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> y
f<sub>S</sub>(x<sub>i</sub>), sabemos que la cantidad de tuplas en el resultado será :
f<sub>R</sub>(x<sub>i</sub>) . f<sub>S</sub>(x<sub>i</sub>)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">4</td>
<td class="org-right">12</td>
<td class="org-right">14</td>
<td class="org-right">20</td>
<td class="org-right">22</td>
<td class="org-right">30</td>
<td class="org-right">otros</td>
</tr>

<tr>
<td class="org-left">R.B</td>
<td class="org-right">200</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">320</td>
<td class="org-right">120</td>
<td class="org-right">150</td>
<td class="org-right">65</td>
<td class="org-right">550</td>
</tr>

<tr>
<td class="org-left">S.B</td>
<td class="org-right">150</td>
<td class="org-right">100</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">180</td>
<td class="org-right">210</td>
<td class="org-right">85</td>
<td class="org-right">410</td>
</tr>

<tr>
<td class="org-left">R*S</td>
<td class="org-right"><code>30000</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right"><code>21600</code></td>
<td class="org-right"><code>31500</code></td>
<td class="org-right"><code>5525</code></td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Para aquellos x<sub>i</sub> de los que sólo conocemos f<sub>R</sub>(x<sub>i</sub>) ó f<sub>S</sub>(x<sub>i</sub>),
estimaremos el faltante a partir de la columna "otros" y de la variabilidad.
</p>

<p>
Por ejemplo, si conocemos sólo f<sub>R</sub>(x<sub>i</sub>), entonces: \[f_{S}(x_{i}) =
    \frac{f_{S}(otros)}{V(B,S)-k}\]
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">4</td>
<td class="org-right">12</td>
<td class="org-right">14</td>
<td class="org-right">20</td>
<td class="org-right">22</td>
<td class="org-right">30</td>
<td class="org-left">otros</td>
</tr>

<tr>
<td class="org-left">R.B</td>
<td class="org-right">200</td>
<td class="org-right"><code>43</code></td>
<td class="org-right">320</td>
<td class="org-right">120</td>
<td class="org-right">150</td>
<td class="org-right">65</td>
<td class="org-left"><del>550</del> <code>507</code></td>
</tr>

<tr>
<td class="org-left">S.B</td>
<td class="org-right">150</td>
<td class="org-right">100</td>
<td class="org-right"><code>41</code></td>
<td class="org-right">180</td>
<td class="org-right">210</td>
<td class="org-right">85</td>
<td class="org-left"><del>410</del> <code>369</code></td>
</tr>

<tr>
<td class="org-left">R*S</td>
<td class="org-right"><code>30000</code></td>
<td class="org-right"><code>4300</code></td>
<td class="org-right"><code>13120</code></td>
<td class="org-right"><code>21600</code></td>
<td class="org-right"><code>31500</code></td>
<td class="org-right"><code>5525</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Actualizamos también las frecuencias de “otros”, y el valor de k,que se
convierte en k<sup>′</sup> = 6.
</p>

<p>
Finalmente estimamos las tuplas correspondientes a “otros” en el resultado
utilizando la estimación simple (equiprobable):
</p>

<p>
\[f_{R*S}(otros) = \frac{f_{R}(otros)f_{S}(otros)}
    {max(V(B,R)-k^{'},V(B,S)-k^{'})}\]
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">4</td>
<td class="org-right">12</td>
<td class="org-right">14</td>
<td class="org-right">20</td>
<td class="org-right">22</td>
<td class="org-right">30</td>
<td class="org-left">otros</td>
</tr>

<tr>
<td class="org-left">R.B</td>
<td class="org-right">200</td>
<td class="org-right"><code>43</code></td>
<td class="org-right">320</td>
<td class="org-right">120</td>
<td class="org-right">150</td>
<td class="org-right">65</td>
<td class="org-left"><del>550</del> <code>507</code></td>
</tr>

<tr>
<td class="org-left">S.B</td>
<td class="org-right">150</td>
<td class="org-right">100</td>
<td class="org-right"><code>41</code></td>
<td class="org-right">180</td>
<td class="org-right">210</td>
<td class="org-right">85</td>
<td class="org-left"><del>410</del> <code>369</code></td>
</tr>

<tr>
<td class="org-left">R*S</td>
<td class="org-right"><code>30000</code></td>
<td class="org-right"><code>4300</code></td>
<td class="org-right"><code>13120</code></td>
<td class="org-right"><code>21600</code></td>
<td class="org-right"><code>31500</code></td>
<td class="org-right"><code>5525</code></td>
<td class="org-left"><code>15590</code></td>
</tr>
</tbody>
</table>

<p>
La estimación final es: \[n(R*S) = \sum_{i} f_{R*S}(x_{i}) = 121635\]
</p>

<p>
La simple estimación (sin histograma) nos hubiera dado como resultado n(R*S)
= 88594.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org53bf807" class="outline-1">
<h1 id="org53bf807"><span class="section-number-1">5</span> Reglas de equivalencia [ELM16 19.1.2]</h1>
<div class="outline-text-1" id="text-5">
</div>
<div id="outline-container-org5024c23" class="outline-2">
<h2 id="org5024c23"><span class="section-number-2">5.1</span> Selección</h2>
<div class="outline-text-2" id="text-5-1">
<p>
Cascada : \(\sigma_{c_{1} \land c_{2} \land \dots \land c_{n}}(R) =
   \sigma_{c_{1}}(\sigma_{c_{2}} ( \dots (\sigma_{c_{n}}(R))\dots))\)
</p>

<p>
\(\sigma_{c_{1} \lor c_{2} \lor \dots \lor c_{n}}(R) = \sigma_{c_{1}}(R) \cup
   \sigma_{c_{2}}(R) \cup \dots \cup \sigma_{c_{n}}(R)\)
</p>

<p>
Conmutatividad: \(\sigma_{c_{1}}(\sigma_{c_{2}}(R)) =
   \sigma_{c_{2}}(\sigma_{c_{1}}(R))\)
</p>
</div>
</div>

<div id="outline-container-org3574084" class="outline-2">
<h2 id="org3574084"><span class="section-number-2">5.2</span> Proyección</h2>
<div class="outline-text-2" id="text-5-2">
<p>
Cascada: \(\pi_{X_{1}}(\pi_{X_{2}}(\dots(\pi_{X_{n}}(R)))) = \pi_{X_{1}}(R)\)
</p>

<p>
Conmutatividad con \(\sigma\): \(\pi_{X}(\sigma_{cond}(R)) =
   \sigma_{cond}(\pi_{X}(R))\)
</p>
</div>
</div>

<div id="outline-container-orgc64d15e" class="outline-2">
<h2 id="orgc64d15e"><span class="section-number-2">5.3</span> Producto cartesiano y junta</h2>
<div class="outline-text-2" id="text-5-3">
<p>
Conmutatividad: \(R \cross S = S \cross R\)
</p>

<p>
\[R * S = S * R\]
</p>

<p>
Asociatividad: \((R \cross S) \cross T = R \cross (S \cross T)\)
</p>

<p>
\[(R * S) * T = R * (S * T)\]
</p>
</div>
</div>

<div id="outline-container-orgea8df76" class="outline-2">
<h2 id="orgea8df76"><span class="section-number-2">5.4</span> Operaciones de conjuntos</h2>
<div class="outline-text-2" id="text-5-4">
<ul class="org-ul">
<li>R &cup; S = S &cup; R (Conmutatividad)</li>
<li>R &cap; S = S &cap; R</li>
<li>(R &cup; S) &cup; T = R &cup; (S &cup; T) (Asociatividad)</li>
<li>(R &cap; S) &cap; T = R &cap; (S &cap; T)</li>
</ul>
</div>
</div>

<div id="outline-container-org335bc95" class="outline-2">
<h2 id="org335bc95"><span class="section-number-2">5.5</span> Otras mixtas</h2>
<div class="outline-text-2" id="text-5-5">
<dl class="org-dl">
<dt>Distribución de la selección en la junta</dt><dd>Dado &sigma;<sub>c</sub>(R*S), si c puede
escribirse como c<sub>R</sub> ∧ c<sub>S</sub>, con c<sub>R</sub> y c<sub>S</sub> involucrando sólo
atributos de R y de S respectivamente, entonces:</dd>
</dl>

<p>
\[\sigma_{c}(R*S) = \sigma_{c_{R}}(R)*\sigma_{c_{S}}(S)\]
</p>


<dl class="org-dl">
<dt>Distribución de la proyección en la junta</dt><dd>Dado&pi;<sub>X</sub>(R*S), si todos los
atributos de junta están incluídos en X, entonces llamando X<sub>R</sub> y X<sub>S</sub>
a los atributos de R y S que están en X respectivamente:</dd>
</dl>

<p>
\[pi_{X}(R*S) =\pi_{X_{R}}(R)*\pi_{X_{S}}(S)\]
</p>
</div>
</div>
</div>

<div id="outline-container-org273a75b" class="outline-1">
<h1 id="org273a75b"><span class="section-number-1">6</span> Heurísticas de optimización</h1>
<div class="outline-text-1" id="text-6">
</div>
<div id="outline-container-orgdb58284" class="outline-2">
<h2 id="orgdb58284"><span class="section-number-2">6.1</span> Reglas generales</h2>
<div class="outline-text-2" id="text-6-1">
<p>
La aplicacion de las reglas de equivalencia a una expresion algebraica para
obtener otras de menor costo se conoce como <code>optimización algebraica</code>.
</p>

<p>
Las siguientes son algunas reglas generales utilizadas para optimizar
algebraicamente una consulta:
</p>
<ol class="org-ol">
<li>Realizar las selecciones lo mas temprano posible.</li>
<li>Reemplazar productos cartesianos por juntas siempre que se sea posible</li>
<li>Proyectar para descartar los atributos no utilizados lo antes posible.
<ol class="org-ol">
<li>Entre la selección y la proyección, priorizar la selección.</li>
</ol></li>
<li>En caso de que hayan varias juntas, realizar aquella mas restrictiva primero.
<ol class="org-ol">
<li>Optar por arboles left-deep o right-deep para acotar las posibilidades.</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgeff4ed1" class="outline-2">
<h2 id="orgeff4ed1"><span class="section-number-2">6.2</span> Ejemplo 2010 world cup</h2>
<div class="outline-text-2" id="text-6-2">
<p>
Esquema de base de datos relacional:
</p>
<ul class="org-ul">
<li>Continent(id, name)
<ul class="org-ul">
<li>(1, ’Africa’)</li>
</ul></li>
<li>NationalTeam(id, name, group, short<sub>name,continent</sub>)
<ul class="org-ul">
<li>(1, ’South Africa’, ’A’, ’RSA’, 0)</li>
</ul></li>
<li>Match(id,home,away, match<sub>datetime</sub><sub>gmt,stage</sub>)
<ul class="org-ul">
<li>(1, 1, 2, ’2010-06-11 14:00:00’, 1)</li>
</ul></li>
<li>Player(id, name, birth<sub>date</sub>, height, playing<sub>position</sub>,
local<sub>club,national</sub><sub>team</sub>, national<sub>team</sub><sub>tshirt</sub>)
<ul class="org-ul">
<li>(53, ’Edinson Cavani’, ’1987-02-14’, 188, ’FW’, ’Palermo [ITA]’, 3, 7)</li>
</ul></li>
<li>Score(id,match<sub>id,team</sub><sub>id,player</sub><sub>id</sub>, minute, score<sub>type</sub>)
<ul class="org-ul">
<li>(1, 1, 1, 8, ’55’, 1)</li>
</ul></li>
<li>Stage(id, name)
<ul class="org-ul">
<li>(3, ’Quarter-finals’)</li>
</ul></li>
</ul>

<p>
Asumiremos que “name” es siempre clave candidata.
</p>

<p>
Para calcular el listado de jugadores que convirtieron algun gol en la final
del mundial, un motor de bases de datos construye el siguiente plan de
consulta:
</p>

<p>
10-ejemplo-world-cup.png
</p>

<p>
Aplique las heurísticas estudiadas para optimizar el plan.
</p>

<p>
10-ejemplo-world-cup-soluc.png
</p>
</div>
</div>
</div>

<div id="outline-container-org0edadee" class="outline-1">
<h1 id="org0edadee"><span class="section-number-1">7</span> Ejemplo</h1>
<div class="outline-text-1" id="text-7">
</div>
<div id="outline-container-org9517b75" class="outline-2">
<h2 id="org9517b75"><span class="section-number-2">7.1</span> Biblioteca publica de Gral Lapehue</h2>
<div class="outline-text-2" id="text-7-1">
<p>
Consideremos las siguientes tablas que representan los préstamos de libros en
la biblioteca:
</p>

<ul class="org-ul">
<li>Socios(nro<sub>socio</sub>, nombre<sub>socio</sub>, f<sub>nac</sub>, f<sub>alta</sub>)</li>
<li>Préstamos(ISBN,nro<sub>orden,nro</sub><sub>socio</sub>)</li>
<li>Ejemplares(ISBN, nro<sub>orden</sub>)</li>
<li>Libros(ISBN, nombre<sub>libro</sub>, autor, idioma, año)</li>
</ul>

<p>
Se escribe la siguiente consulta SQL para listar los nombres de los socios
nacidos después de 1990 que tienen en préstamo un libro de Isaac Asimov:
</p>

<p>
   #+BEGIN<sub>SRC</sub> sql
SELECT S.name FROM Socios S, Préstamos P, Libros L WHERE S.nro<sub>socio</sub> =
P.nro<sub>socio</sub> AND P.ISBN = L.ISBN AND L.autor = “Isaac Asimov” AND S.f<sub>nac</sub> &gt;=
“1990−01−01”; #+END<sub>SRC</sub>
</p>
</div>

<div id="outline-container-orga9f6bca" class="outline-3">
<h3 id="orga9f6bca"><span class="section-number-3">7.1.1</span> 1</h3>
<div class="outline-text-3" id="text-7-1-1">
<p>
La consulta se traduce a la siguiente expresión del álgebra relacional:
</p>

<p>
&pi;<sub>nombre<sub>socio</sub></sub>(&sigma;<sub>autor="Isaac Asimov" &and; f<sub>nac</sub> &ge;
"1990-01-01"</sub>((Socios * Prestamos) * Libros))
</p>

<p>
A partir de la siguiente información de catálogo, calcule el costo de
procesamiento de la consulta. Suponga que no hay índices, y que se utiliza
pipelining y el método de bloques para las juntas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Socios (S)</td>
<td class="org-left">Préstamos (P)</td>
<td class="org-left">Libros (L)</td>
</tr>

<tr>
<td class="org-left">n(S) = 10000</td>
<td class="org-left">n(P)=300000</td>
<td class="org-left">n(L)=50000</td>
</tr>

<tr>
<td class="org-left">B(S) = 1000</td>
<td class="org-left">B(P)=15000</td>
<td class="org-left">B(L)=5000</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">V(autor, L) = 500</td>
</tr>

<tr>
<td class="org-left">min(f<sub>nac</sub>) =1972</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">max(f<sub>nac</sub>) =2012</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Suponga que los strings tienen tamaño medio de 20 bytes y que el resto de
los datos son de 4 bytes.
</p>
</div>

<div id="outline-container-orgdefeed9" class="outline-4">
<h4 id="orgdefeed9"><span class="section-number-4">7.1.1.1</span> Solucion 1</h4>
<div class="outline-text-4" id="text-7-1-1-1">
<p>
10-lib-soluc.png
</p>

<p>
cost(S*P) = B(S) + B(S) * B(P) = 15001000
</p>

<p>
n(S*P) = \frac{10000*300000}{10000} = 300000
</p>

<p>
Asumiremos que \frac{1}{F(S*P)} = \frac{1}{F(S)} + \frac{1}{F(P)}
</p>

<p>
Entonces F(S*P) = \frac{20}{3} y B(S*P) * B(L) = cost(S*P) + 225000000 =
cost(S*P) + 225000000
</p>

<p>
n((S*P)*L) = \frac{300000*50000}{50000} = 300000
</p>

<p>
cost &asymp; 240*10<sup>6</sup>
</p>
</div>
</div>
</div>

<div id="outline-container-org4c4dec3" class="outline-3">
<h3 id="org4c4dec3"><span class="section-number-3">7.1.2</span> 2</h3>
<div class="outline-text-3" id="text-7-1-2">
<p>
Optimice la consulta utilizando las reglas heurísticas estudiadas.
</p>
</div>

<div id="outline-container-orgf636322" class="outline-4">
<h4 id="orgf636322"><span class="section-number-4">7.1.2.1</span> Soluc</h4>
<div class="outline-text-4" id="text-7-1-2-1">
<p>
&pi;<sub>nombre<sub>socio</sub></sub>(&pi;<sub>ISBN</sub>(&sigma;<sub>autor="Isaac Asimov"</sub>(Libros))*
Prestamos * &pi;<sub>nro<sub>socio</sub>, nombre<sub>socio</sub></sub>(&sigma;<sub>f<sub>nac</sub> &ge;
"1990-01-01"</sub>(Socios)))
</p>
</div>
</div>
</div>

<div id="outline-container-org9e4d766" class="outline-3">
<h3 id="org9e4d766"><span class="section-number-3">7.1.3</span> 3</h3>
<div class="outline-text-3" id="text-7-1-3">
<p>
Proponga 2 indices utiles para la resolucion de la consulta y calcule el
costo del plan de ejecución final.
</p>
</div>

<div id="outline-container-orgd562078" class="outline-4">
<h4 id="orgd562078"><span class="section-number-4">7.1.3.1</span> 3</h4>
<div class="outline-text-4" id="text-7-1-3-1">
<p>
Utilizaremos un indice secundario para Libros(autor) y un indice de
clustering para Prestamos(ISBN).
</p>

<p>
El nuevo plan de ejecución es:
</p>

<p>
10-lib-ej3-soluc.png
</p>

<p>
T<sub>1</sub> = &pi;<sub>ISBN</sub>(&sigma;<sub>autor="Isaac Asimov"</sub>(Libros)) &rarr; El
acceso es con indice secundario
</p>

<p>
cost(&sigma;<sub>autor="Isaac Asimov"</sub>(Libros)) = Height(I(autor, Libros)) +
\frac{n(Libros)}{V(autor, Libros)} = 4 + \frac{50000}{500} = 104
</p>

<p>
// se asume una altura fija de 4 para el arbol
</p>

<p>
n(&sigma;<sub>autor="Isaac Asimov"</sub>(Libros)) = \frac{n(Libros)}{V(autor,
Libros)} = 100
</p>

<p>
B(&sigma;<sub>autor="Isaac Asimov"</sub>(Libros)) = \frac{100}{10} = 10
</p>

<p>
La proyeccion no tiene costo agregado porque se hace en pipeline.
</p>

<p>
n(T<sub>1</sub>) = 100
</p>

<p>
B(T<sub>1</sub>) = \ceil{10*\frac{4}{68}} = 1
</p>

<p>
T<sub>2</sub> = T<sub>1</sub> * Prestamos
</p>

<p>
cost(T<sub>2</sub>) = 104 + n(T<sub>1</sub>) * (Height(I(ISBN, Prestamos)) +
\frac{n(Prestamos)}{F(Prestamos)V(ISBN,Prestamos)}) = 104 + 100 (4+1) = 604
</p>

<p>
n(T<sub>2</sub>) = \frac{100*300000}{50000} = 600
</p>


<p>
\frac{1}{F(T<sub>1</sub> * Prestamos)} = \frac{1}{T<sub>1</sub>} + \frac{1}{F(Prestamos} =
\frac{1}{100} + \frac{1}{20}
</p>

<p>
T<sub>3</sub> = &pi;<sub>nro<sub>socio</sub></sub>(T<sub>2</sub>))
</p>

<p>
B(T<sub>3</sub>) = \ceil{B(T<sub>2</sub>) \frac{4}{12}} = \frac{38}{3} = 13 (no sabemos
estimarlo mejor)
</p>

<p>
cost(T<sub>3</sub>) = 604 + 2 * 13 * log<sub>2</sub> (13) = 97 (hacemos sort externo)
</p>


<p>
T<sub>4</sub> = &pi;(&sigma;(Socios))
</p>

<p>
cost(&pi;(&sigma;(Socios))) = B(Socios) = 1000 n(&pi;(&sigma;(Socios))) =
10000 * 22 / 40 = 5500 B(&pi;(&sigma;(Socios))) = 5500 / 10 * 24 / 32 = 413
</p>


<p>
Costo de almacenar en disco T<sub>3</sub> para dejar &pi;(&sigma;(Socios)) en
pipeline: 13
</p>

<p>
Integrando todos los costos y haciendo la última junta T<sub>3</sub>*T<sub>4</sub>:
</p>

<p>
cost = (604) + (97) + (1000) + (13) + (13*413) =7083
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orga158c12" class="outline-1">
<h1 id="orga158c12"><span class="section-number-1">8</span> Bibliografía</h1>
<div class="outline-text-1" id="text-8">
<ul class="org-ul">
<li>[ELM16] Fundamentals of Database Systems, 7th Edition.R. Elmasri, S. Navathe,
2016.Capítulo 17, Capítulo 18</li>

<li>[GM09] Database Systems, The Complete Book, 2nd Edition.H. García-Molina,
J. Ullman, J. Widom, 2009.Capítulo 15, 16</li>

<li>[CONN15] Database Systems, a Practical Approach to Design,Implementation and
Management, 6th Edition.T. Connolly, C. Begg, 2015.Capítulo 23</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
f<sub>R</sub>(x<sub>i</sub>) = n(&pi;<sub>B=x<sub>i</sub></sub>(R))
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
Last update: 2020-09-16 14:52
</div>
</body>
</html>
