<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-02-03 Mon 19:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>No SQL</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/res/org.css"/>
                   <script type="text/javascript" src="../res/org-info.js"></script>
                   <script type="text/javascript">
                    /* <![CDATA[ */
                       org_html_manager.setup ();
                    /* ]]> */
                   </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<p>
Page 1
</p>















<p>
NoSQL
75.15 / 75.28 / 95.05 - Base de Datos
NoSQL
</p>


<p>
10 de octubre de 2018
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 2
</p>


















<p>
NoSQL
Topics
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
</p>

<p>
Bases de datos wide column vs. por columnas
</p>

<p>
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 3
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
</p>

<p>
Bases de datos wide column vs. por columnas
</p>

<p>
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 4
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Introducción
Contexto histórico
tecnológicos.
de datos que tuvieran:
1
Mayor
escalabilidad
para trabajar con grandes volúmenes de datos
(Google Inc., 2005).
2
Mayor
performance en aplicaciones Web
Surgen XML (1998) y JSON (1999), entre otros.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 24.1.2]
</p>






<p>
Page 5
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Introducción
Contexto histórico
3
Mayor
flexibilidad
sobre las estructuras de datos
para organizar los datos en una forma semi-estructurada.
4
Mayor capacidad de
distribución
Se prioriza la capacidad de procesamiento distribuido.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 6
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Introducción
Limitaciones de las bases relacionales
trata de escalar los sistemas:
El manejo de transacciones en forma distribuida no escala.
<a href="http://www.enterpriseintegrationpatterns.com/ramblings/18">http://www.enterpriseintegrationpatterns.com/ramblings/18</a>_
starbucks.html
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 7
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Introducción
NoSQL
Contexto de los últimos 15 años:
2000
2010
2015
Almacenam. (vel.)
+50MB/s (HDD)
+50MB/s (HDD)
+500MB/s (SSD)
Almacenam. ($)
10US$/GB
0,10US$/GB
0,70US$/GB
Red
100Mbps
1Gbps
10 Gbps
CPU
≈1GHz
≈3GHz
≈3GHz
DRAM (vel.)
2 GB/s (DDR)
10 GB/s (DDR3)
20 GB/s (DDR4)
DRAM
800 US$/GB
30 US$/GB
6 US$/GB
Redes cada vez más rápidas
3
y almacenamiento más barato
3
,
pero velocidad de procesamiento estancada
7
.
Se gestó el concepto
“NoSQL”
como todo aquello en el mundo de
las BD’s que no estuviera basado en el modelo relacional ó SQL.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 8
</p>















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Introducción
El universo de los SGBD
Basado en:
<a href="https://blogs.the451group.com/information_management20121102updated-database-landscape-graphic/">https://blogs.the451group.com/information_management20121102updated-database-landscape-graphic/</a>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 9
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Introducción
Clasificación de SGBD’s No-SQL
Las bases de datos No-SQL se clasifican en distintos tipos:
Bases de datos basadas en grafos
híbrido de varios de estos tipos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 24.1.3]
</p>






<p>
Page 10
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos distribuidas
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
</p>

<p>
Bases de datos wide column vs. por columnas
</p>

<p>
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 11
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos distribuidas
Bases de datos distribuidas
Contexto
de ellas implementan la funcionalidad de un
sistema de gestión
de bases de datos distribuido (SGBD distribuido)
.
introduciremos algunos conceptos sobre SGBD’s distribuidos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 12
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos distribuidas
Bases de datos distribuidas
Temas
Hablaremos de:
Modelos de consistencia
Consistencia eventual
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 13
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos distribuidas
Bases de datos distribuidas
Fragmentación
La
fragmentación
es la tarea de dividir los datos de una tabla
Se realiza con dos objetivos:
una parte de las consultas para luego integrar los resultados.
Según la manera de fragmentar, podemos distinguir entre:
Fragmentación horizontal:
Las filas de cada tabla se reparten entre
las filas. Generalmente se divide a partir del valor de un atributo.
Fragmentación vertical:
Distintos nodos guardan un subconjunto de
relativas a la clave primaria.
En general se utiliza una combinación de ambas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 23.2.1; CONN15 24.4.2]
</p>






<p>
Page 14
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos distribuidas
Bases de datos distribuidas
Replicación
La
replicación
es el proceso por el cual se almacenan múltiples
Nos brinda varias ventajas:
Funciona como
mecanismo de backup
, que permite recuperar el
algunos nodos.
se denominan
réplicas secundarias
. Cuando también pueden
hacer procesamiento, se las conoce como
réplicas primarias
.
La replicación nos genera un nuevo problema a resolver: la
consistencia
de los datos.
menos, temporalmente) distintos valores para un mismo dato.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 23.2.1; CONN15 26.2]
</p>






<p>
Page 15
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
</p>

<p>
Bases de datos wide column vs. por columnas
</p>

<p>
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 16
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
Bases de datos clave-valor
Bases de datos wide column
Bases de datos wide column vs. por columnas
</p>

<p>
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 17
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Bases de datos clave-valor
Las
bases de datos clave-valor (key-value stores)
almacenan lo
valor).
Ejemplo: (“nombre”, “Luis Poretti”), (“saldo”, 5100)
Algunos ejemplos de key-value stores son:
Redis
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 24.4]
</p>






<p>
Page 18
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Bases de datos clave-valor
elementales:
Insertar un nuevo par
(put)
Eliminar un par existente
(delete)
Actualizar el valor de un par
(update)
Encontrar un par asociado a una clave particular
(get)
Las ventajas de los key-value stores son:
Simplicidad
no de interrelaciones entre los datos.
Velocidad
los datos.
Escalabilidad
distribuida) y permiten repartir las consultas entre los nodos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 19
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Dynamo
es el key-value store de Amazon.
Está diseñado siguiendo una
arquitectura orientada a servicio
(SoA)
</p>
<pre class="example">
la base de datos está distribuida en un

</pre>
<p>
server cluster
que
Utiliza un modelo de
hashing consistente
que reduce la cantidad
de nodos S.
con un impacto mínimo.
Utiliza un modelo de consistencia denominado
consistencia
eventual
, que tolera pequeñas inconsistencias en los valores
Es totalmente descentralizado. Los nodos son peers entre sí.
Carece de un punto único de falla.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 20
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Hashing consistente
Disponemos de una
función de hash
h() que, dada una clave k ,
representa la cantidad de nodos de procesamiento.
Esto es lo que se conoce como una
tabla de hash distribuida
(DHT)
.
ligeramente distinta, conocida como hashing consistente.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 24.4.2]
</p>






<p>
Page 21
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Hashing consistente
estructura de anillo por hash creciente.
Regla:
Un par (k , v ) se replicará en los N servidores siguientes a
h(k ), que conformarán el listado de preferencia para esa clave.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 22
</p>

























<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Modelos de consistencia
Consistencia secuencial
En el estudio de la
replicación
en las bases de datos distribuidas
se utilizan distintos
modelos de consistencia
.
datos centralizadas, es el de
consistencia secuencial
.
lectura, R
P
i
(
X ) y de escritura, W
P
i
(
X ), sobre una base de datos
distribuida.
→ ¡Los procesos están en distintas máquinas!
ejecutan una después de otra”.
→ Queremos ver si el conjunto de órdenes locales de las
instrucciones se corresponde con algún hipotético orden global.
Atención!
Esto no quiere decir que los procesos se ejecuten uno
otra no haya terminado de aplicarse en todas las réplicas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[TURU17]
</p>






<p>
Page 23
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Modelos de consistencia
Consistencia secuencial
Para indicar el valor leído/escrito utilizaremos esta notación:
W (X )b indica que el proceso escribió el valor b en el ítem X .
Ejemplo:
El valor inicial de a es 30, y el de b es 12.
P
1
R(b)12
R(a)3
W(a)20
P
2
R(a)30
R(b)12
W(a)3
W(b)8
P
3
R(a)20
Nota: Misma columna no implica mismo
tiempo físico. ¡Los procesadores pueden
no tener sus relojes sincronizados!
Tiempo local
−−−−−−−−−−−−→
de las instrucciones:
P
1
R(b)12
R(a)3
W(a)20
P
2
R(a)30
R(b)12
W(a)3
W(b)8
P
3
R(a)20
Tiempo universal
−−−−−−−−−−−−−−→
Por lo tanto, esta ejecución tiene consistencia secuencial.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 24
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Modelos de consistencia
Consistencia secuencial
Pero en la siguiente ejecución, en cambio:
P
1
R(b)8
R(a)30
W(a)20
P
2
R(a)30
R(b)12
W(a)3
W(b)8
P
3
R(a)20
Tiempo local
−−−−−−−−−−−−→
No existe una ejecución secuencial equivalente. Evidentemente, P
1
Esta ejecución no tiene consistencia secuencial.
de respuesta.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 25
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Modelos de consistencia
Consistencia causal
En el modelo de
consistencia causal
se busca capturar eventos
que puedan estar causalmente relacionados.
requiere que todos vean al evento a antes que al evento b.
Ejemplo: Supongamos que un proceso P
1
escribe un ítem X .
Simultáneamente, un proceso P
2
lee el ítem X y escribe el ítem
todos las vean en el mismo orden.
mismo orden.
todos en el mismo orden.”
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[TURU17]
</p>






<p>
Page 26
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Modelos de consistencia
Consistencia causal
a = 5, b = 7 y c = 9:
P
1
W(a)5
R(c)20
R(b)7
P
2
W(b)10
R(b)10
R(c)9
P
3
W(c)20
Tiempo local
−−−−−−−−−−−−→
lo tanto es consistente que sean vistas por P
1
y P
2
en órdenes
distintos.
tiene consistencia secuencial.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 27
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Modelos de consistencia
Consistencia causal
b = 7:
P
1
W(a)20
P
2
R(a)20
W(b)3
P
3
R(b)3
R(a)5
Tiempo local
−−−−−−−−−−−−→
deben ser vistas por todos en el mismo orden.
Sin embargo, P
3
las ve en el orden W (b)3 → W (a)20 mientras
que P
2
las ve en el orden W (a)20 → W (b)3.
Esta ejecución no tiene consistencia causal.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 28
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Modelos de consistencia
Consistencia eventual
El modelo de
consistencia eventual
está basado en la siguiente
observación:
escribe sean vistas por los procesos que leen.
valores).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[TURU17]
</p>






<p>
Page 29
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Modelo de consistencia eventual
Dynamo provee un modelo de
consistencia eventual
, que permite
asincrónica.
rápidamente.
propagarlo a las N − 1 réplicas antes de confirmar la escritura.
cualquier réplica, es posible leer un valor no actualizado.
para una operación de put o get.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 30
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Modelo de consistencia eventual
Se definen dos parámetros adicionales:
R ≤ N: Quorum de lectura
Quorum de escritura W
el valor almacenado tiene un nivel de replicación mínimo.
Quorum de lectura R
la lectura.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 31
</p>
















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Consistencia eventual
Algunos valores comunes de R y W son:
N
R
W
3
2
2
Buena durabilidad y latencia (paper).
3
3
1
Lectura más lenta, pero pobre durabilidad. Escritura rápida.
3
1
3
Escrituras más lentas. Muy buena durabilidad y lectura rápida.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 32
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Aplicaciones
distribuido para gestionar su sitio de comercio electrónico.
plataforma de cloud computing de Amazon.
las búsquedas sean siempre por clave.
estructura:
(“NombreEntidad:ValorAtributoClave:NombreAtributo”, ValorAtributo)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 33
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos clave-valor
Dynamo
Aplicaciones
haríamos:
put(“PreciosProductos:E34:Precio”, 499.00)
Y para consultar la cantidad disponible del producto F80:
cantidad = get(“PreciosProductos:F80:CantidadDisponible”)
Hadoop sobre Dynamo.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 34
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
Bases de datos clave-valor
Bases de datos wide column
Bases de datos wide column vs. por columnas
</p>

<p>
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 35
</p>























<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Bases de datos wide column
Pero estas bases de datos permiten
agregar columnas en forma
dinámica
a una fila, convirtiéndola en una fila ancha
(wide row)
1
.
de la entidad con otra entidad. (
Ejemplo:
Un Cliente que va
Las más conocidas son:
Apache HBase (basado en las ideas de BigTable)
[ELM16 24.5]
clave/valor)
1
Aunque por motivos históricos su nombre quedó como wide column.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 36
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Cassandra
es una base de datos NoSQL de tipo
wide
column
. Es un híbrido entre las bases de datos por
columnas y las clave/valor.
Arquitectura
share-nothing
.
→ ¡Muy alta escalabilidad!
Está optimizado para ofrecer una
alta tasa de escrituras
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 37
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Key spaces y column families
SGBD’s relacionales
Cassandra
Esquema
Keyspace
Tabla
Column family
Fila
Fila
</p>
<ul class="org-ul">
<li></li>
</ul>
<p>
Wide row
En Cassandra, el concepto análogo al de tabla es el de
column
family (familia de columnas)
.
Una
fila
está compuesta por:
Un conjunto de pares clave/valor ó
columnas
Para Cassandra, cada
columna
no es más que un par clave/valor
asociado a una fila.
Cada
keyspace (esquema)
puede estar distribuido en varios
nodos de nuestro
cluster
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 38
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Key spaces y column families
Creamos un nuevo key space con la siguiente instrucción en CQL:
CREATE KEYSPACE
empresa<sub>db</sub>
WITH
replication = {
’ class ’
</p>
<pre class="example">


</pre>
<p>
’ SimpleStrategy ’
,
’ replication<sub>factor</sub> ’
</p>
<pre class="example">
1 };

</pre>
<p>
Asignamos este key space como aquél por defecto:
USE
empresa<sub>db</sub> ;
Creación de un column family :
CREATE COLUMNFAMILY
clientes (
cuit
int
,
nombre
text
,
domicilio
text
,
primary key
( cuit ));
¡Es obligatorio definir una clave primaria!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 39
</p>















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Esquema lógico de una fila
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[CASS16 4]
</p>






<p>
Page 40
</p>
























<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Wide rows
dinámicamente en función de las necesidades.
Ejemplo:
Si un cliente nos compra Libros, quisiéramos agregar por
las columnas&#x2026;
7
En realidad, lo que definimos es un listado de columnas, del cual
las filas pueden tomar varias, y cada una más de una vez.
convirtió en una
wide row (fila ancha)
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 41
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Esquema lógico de una wide-row
Nuestra clave primaria queda ahora dividida en dos partes: una
clave de partición
y una
clave de clustering
.
Adicionalmente, podemos tener
columnas estáticas
, que sean
únicas por cada partition key (por ejemplo, el nombre del Cliente).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[CASS16 4]
</p>






<p>
Page 42
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Clave primaria: Definición en CQL
La definición de esta column family es:
CREATE COLUMNFAMILY
clientes (
nro<sub>cliente</sub>
int
,
nombre
text static
,
ISBN
bigint
,
nombre<sub>libro</sub>
text
,
primary key
(( nro<sub>cliente</sub> ), ISBN ));
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 43
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Clave primaria: Esquema lógico
La clave primaria en Cassandra se divide en dos partes:
La clave de particionado
(partition key)
La clave de clustering
(clustering key)
compuestas.
filas de una column family con igual valor en la clave primaria.
para identificar a la wide-row (en el ejemplo anterior, al Cliente).
Veremos que
no siempre vamos a pedir que la clave sea minimal
.
búsquedas que tengamos que hacer en esa column family.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 44
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Clave primaria: Esquema físico
La correcta definición de la
clave primaria
es fundamental para el
para responder consultas.
contigua en disco en un mismo nodo.
las columnas dentro de la wide-row.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 45
</p>























<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Clave primaria: restricciones
column family
2
</p>
<pre class="example">


</pre>
<p>
1
columnas que formen parte de la clave primaria.
2
Las columnas que forman parte de la partition key
deben
ser
comparadas por igual contra valores constantes en los predicados.
3
dicha columna en la definición de la clave primaria.
4
comparadas por igual, y las posteriores no deben ser utilizadas.
2
Ver: “A Big Data Modeling Methodology for Apache Cassandra”, A. Chebotko, A.
Kashlev, S. Lu, IEEE International Congress on Big Data, 2015.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 46
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Tipos de dato
Los tipos de dato básicos son similares a los de SQL:
int
, smallint, bigint, float, decimal
text
, varchar
timestamp
, date, time
uuid
(clave surrogada)
boolean
como tipos de dato:
set
(conjunto de elementos)
list
(lista ordenada de elementos)
map
(conjunto de pares clave/valor)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 47
</p>























<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Reglas de diseño
cuenta los siguientes puntos:
1
No existe el concepto de junta
. Si para alguna consulta típica
guardarla como una
tabla desnormalizada
más desde el comienzo.
2
No existe el concepto de integridad referencial
. Si la necesitamos,
debe ser manejada desde el nivel de aplicación.
3
Desnormalización de datos
. En las bases de datos NoSQL el uso
por un único motivo:
performance
.
4
Diseño orientado a las consultas
. ¿Cómo saber qué tablas crear si
no sabemos cuáles son las consultas a hacer?
diseñar las tablas.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[CASS16 5]
</p>






<p>
Page 48
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Objetivos de diseño. Diagramas Chebotko
Buscamos que:
clave primaria.
Nosotros utilizaremos uno de los más conocidos:
Chebotko
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 49
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo
A continuación desarrollaremos un ejemplo en Python:
1-Instalación del servidor de Cassandra
Descargar de <a href="http://cassandra.apache.org/download/">http://cassandra.apache.org/download/</a>.
2-Instalación de la API para Python 3.0
1,2
pip install cassandra-driver
3-Lanzamiento del servidor de Cassandra
bin/cassandra -f (requiere Java 7 JVM).
1
Para la instalación de Python 3.0 sugerimos utilizar Anaconda
(<a href="https://www.continuum.io/downloads">https://www.continuum.io/downloads</a>).
2
Alternativa: conectarnos al servidor directamente desde el shell (bin/cqlsh).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 50
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca
préstamos en una biblioteca. Partimos del siguiente diagrama:
Socio
Nro. Socio
Nombre
Domicilio
Tel´efono
Mail
tiene
1
Ejemplar
N
Nro.Orden
pertenece
N
Libro
1
ISBN
Nombre
Idioma
A˜
no
escrito por
N
Autor
N
Nombre
pertenece
N
G´enero
N
Nombre
1
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 51
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca. Workflow
responder.
consultas:
Q1
</p>
<pre class="example">
Buscar libro por género

</pre>
<p>
Q2
</p>
<pre class="example">
Buscar libro por nombre

</pre>
<p>
Q3
</p>
<pre class="example">
Buscar libro por ISBN

</pre>
<p>
Q4
</p>
<pre class="example">
Ver información de un libro

</pre>
<p>
Q5
</p>
<pre class="example">
Ver información de un socio

</pre>
<p>
Q6
</p>
<pre class="example">
Ver ejemplares disponibles de un libro

</pre>
<p>
Q7
</p>
<pre class="example">
Asignar ejemplar a un socio

</pre>
<p>
Q8
</p>
<pre class="example">
Consultar ejemplares que posee un socio

</pre>
<p>
Q9
</p>
<pre class="example">
Encontrar socios morosos (con préstamos vencidos)

</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 52
</p>
















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca. Workflow
El siguiente sería un posible workflow para nuestros datos:
Buscar libro
x género
Buscar libro
x nombre
Buscar libro
x ISBN
Ver info de
libro
Buscar
ejemplares
disponibles
libro
Ver info de
socio
Ver
ejemplares
socio
Asignar
ejemplar a
socio
Buscar
socios
morosos
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 53
</p>















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca. Diagrama Chebotko
Por cada consulta idearemos una column family que la resuelva:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 54
</p>
















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca. Column-families
CREATE COLUMNFAMILY
socios (
nro<sub>socio</sub>
int
,
nombre
text
,
domicilio
text
,
telefono
set
&amp;lt;
int
&amp;gt;,
mail
set
&amp;lt;
text
&amp;gt;,
primary key
( nro<sub>socio</sub> )
);
CREATE COLUMNFAMILY
prestamos<sub>por</sub><sub>socio</sub> (
nro<sub>socio</sub>
int
,
ISBN
bigint
,
nro<sub>orden</sub>
int
,
nombre
text
,
vencimiento
date
,
primary key
(( nro<sub>socio</sub> ), ISBN , nro<sub>orden</sub> )
);
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 55
</p>
















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca. Column-families
CREATE COLUMNFAMILY
ejemplares<sub>dispon</sub> (
ISBN
bigint
,
nro<sub>orden</sub>
int
,
primary key
(( ISBN ), nro<sub>orden</sub> )
);
CREATE COLUMNFAMILY
prestamos<sub>por</sub><sub>fecha</sub> (
vencimiento
date
,
nro<sub>socio</sub>
int
,
ISBN
bigint
,
nro<sub>orden</sub>
int
,
primary key
(( vencimiento ), nro<sub>socio</sub> , ISBN , nro<sub>orden</sub> )
);
&#x2026;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 56
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca. Ejercicios en CQL.
1
ejemplar y la fecha de vencimiento del préstamo.
SELECT
nombre , ISBN , nro<sub>orden</sub>
FROM
prestamos<sub>por</sub><sub>socio</sub>
WHERE
nro<sub>socio</sub> = 751;
2
del mismo.
SELECT
autor
FROM
libros
WHERE
ISBN = 14292859338291;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 57
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
Cassandra
Ejemplo: Base de datos de una biblioteca. Ejercicios en CQL.
3
de ejemplares disponibles y asígnelo en préstamo al socio.
DELETE FROM
prestamos<sub>por</sub><sub>socio</sub>
WHERE
nro<sub>socio</sub> = 751
AND
ISBN = 55102184963921
AND
nro<sub>orden</sub> = 2;
INSERT INTO
ejemplares<sub>dispon</sub> ( ISBN , nro<sub>orden</sub> )
VALUES
(55102184963921 , 2);
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 58
</p>
















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column vs. por columnas
Bases de datos por columnas
filas. Cada fila se convierte en un registro de un archivo físico.
El modelo de
base de datos por columnas (column-oriented
databases)
, en cambio, almacena cada columna de una tabla en
una estructura propia.
daremos aquí algunos detalles sobre ellas.
negocios y el data warehousing.
HANA y Infobright.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 59
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column vs. por columnas
Bases de datos por columnas
Manejo de columnas
Esto tiene varias ventajas:
También es más sencillo cambiar el tipo de dato de una columna.
datos de longitud variable en representaciones de longitud fija.
De esta forma no es costoso recuperar una fila!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 60
</p>























<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column vs. por columnas
Bases de datos por columnas
Manejo de columnas
Optimización de consultas
Ejemplo:
nos lleva a realizar la proyección antes de la selección.
Aplicación a Data warehouses
Los
cubos de datos OLAP
típicamente almacenan los resultados
agregados de la junta de múltiples tablas.
R(cliente, mes, dia, producto, cantidad )
mucho más eficiente.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 61
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column vs. por columnas
Bases de datos por columnas
Bases de datos basadas en columnas
recuperar los datos.
pocas columnas en el contexto de bases de datos grandes.
Aplicación a procesamiento OLAP (data warehouses).
Ejemplos:
SAP HANA
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 62
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos wide column vs. por columnas
Bases de datos por columnas
Ejemplo: SAP HANA
Es una base de datos
en memoria
, pensada para ofrecer alta
SAP certifica el hardware sobre el que corre HANA.
Ejemplo:
Según SAP, IBM tiene certificado un cluster que totaliza
factor de corrección de 2, esto totaliza
196 TB de capacidad de
almacenamiento de datos en memoria.
Fuente: “Implementing SAP
HANA”, SAP PRESS, 2014.
Ventajas/desventajas:
3
Velocidad de acceso
3
Big data
7
¡La contrapartida es el costo! La RAM cuesta ∼ 10 veces más
que el almacenamiento SSD.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 63
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
</p>

<p>
Bases de datos wide column vs. por columnas
Bases de datos orientadas a documentos
Bases de datos basadas en grafos
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 64
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
Bases de datos orientadas a documentos
En las
bases de datos orientadas a documentos
, un
documento
bajo una cierta estructura.
manejar estructuras un poco más complejas que un simple
clave:
valor
.
un conjunto de pares
clave: valor
que representan los atributos
La estructura de un documento típicamente se describe con un
lenguaje de intercambio de datos (data exchange language)
.
Ejemplos: HTML, XML, JSON, BSON, YAML&#x2026;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 65
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
Bases de datos orientadas a documentos
Algunos ejemplos son:
RavenDB
A continuación tomaremos
MongoDB
como
mayor detalle.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 66
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
Bases de datos orientadas a documentos
MongoDB
Basada en hashes para identificar a los objetos.
No utiliza esquemas (schema-free). No existe un DDL.
Los documentos tienen un formato
JSON
.
Almacena por clave/valor.
Java, C#, &#x2026;
Su implementación de la operación de junta es limitada.
Organiza los datos de una base de datos en
colecciones
que
contienen
documentos
.
Modelo relacional
MongoDB
Esquema
Base de datos
Relación
Colección
Tupla
Documento
Atributo
Campo
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 24.3]
</p>






<p>
Page 67
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
JSON
1
Hamburguesa =
{
2
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; BigBacon &amp;#34;
,
3
&amp;#34; ingredientes &amp;#34;
</p>
<pre class="example">


</pre>
<p>
[
&amp;#34; pan &amp;#34;
,
&amp;#34; carne &amp;#34;
,
&amp;#34; lechuga &amp;#34;
,
&amp;#34; salsa &amp;#34;
,
&amp;#34; pan &amp;#34;
4
&amp;#34; carne &amp;#34;
,
&amp;#34; tocino &amp;#34;
,
&amp;#34; queso &amp;#34;
,
&amp;#34; pepinillos &amp;#34;
,
&amp;#34; salsa &amp;#34;
,
&amp;#34; pan &amp;#34;
]
,
5
&amp;#34; precio &amp;#34;
</p>
<pre class="example">


</pre>
<p>
129
.
99
,
6
&amp;#34; calorías &amp;#34;
</p>
<pre class="example">


</pre>
<p>
930
7
}
datos.
una alternativa a XML.
Un objeto JSON se delimita con
{}
y posee un conjunto de
atributos que se identifican como clave
</p>
<pre class="example">


</pre>
<p>
valor.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 68
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
JSON
1
Hamburguesa =
{
2
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; BigBacon &amp;#34;
,
3
&amp;#34; ingredientes &amp;#34;
</p>
<pre class="example">


</pre>
<p>
[
&amp;#34; pan &amp;#34;
,
&amp;#34; carne &amp;#34;
,
&amp;#34; lechuga &amp;#34;
,
&amp;#34; salsa &amp;#34;
,
&amp;#34; pan &amp;#34;
4
&amp;#34; carne &amp;#34;
,
&amp;#34; tocino &amp;#34;
,
&amp;#34; queso &amp;#34;
,
&amp;#34; pepinillos &amp;#34;
,
&amp;#34; salsa &amp;#34;
,
&amp;#34; pan &amp;#34;
]
,
5
&amp;#34; precio &amp;#34;
</p>
<pre class="example">


</pre>
<p>
129
.
99
,
6
&amp;#34; calorías &amp;#34;
</p>
<pre class="example">


</pre>
<p>
930
7
}
Las claves en JSON son siempre strings.
ó NULL.
Por lo tanto, los atributos en MongoDB pueden ser multivaluados.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 69
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Ejemplo
de MongoDB para Linux y la API de MongoDB para Python 3.0.
1-Instalación del servidor de MongoDB
sudo apt-get install mongodb-server
2-Instalación de la API para Python 3.0
1
pip install pymongo
3-Lanzamiento del servidor de MongoDB
mongod
1
Para la instalación de Python 3.0 sugerimos utilizar Anaconda
(<a href="https://www.continuum.io/downloads">https://www.continuum.io/downloads</a>).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 70
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Creación de documentos
from
pymongo
import
MongoClient
conn = MongoClient ()
conn . database<sub>names</sub> ()
</p>

<p>
bd<sub>empresa</sub> = conn . base<sub>empresa</sub>
</p>

<p>
col<sub>clientes</sub> = bd<sub>empresa</sub> . clientes
</p>

<p>
cliente1 = {
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Mario &amp;#34;
,
&amp;#34; apellido &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Wilkerson &amp;#34;
,
&amp;#34; domicilio &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Av . Entre Ríos 1560 &amp;#34;
}
id<sub>cliente1</sub> = col<sub>clientes</sub> . insert<sub>one</sub> ( cliente1 ). inserted<sub>id</sub>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 71
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Creación de documentos
</p>

<p>
cliente2 = {
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Horacio &amp;#34;
,
&amp;#34; apellido &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Fonseca &amp;#34;
,
&amp;#34; localidad &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Morón &amp;#34;
}
id<sub>cliente2</sub> = col<sub>clientes</sub> . insert<sub>one</sub> ( cliente2 ). inserted<sub>id</sub>
cliente3 = {
&amp;#34; apellido &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Gandría &amp;#34;
,
&amp;#34; localidad &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Caballito &amp;#34;
}
id<sub>cliente3</sub> = col<sub>clientes</sub> . insert<sub>one</sub> ( cliente3 ). inserted<sub>id</sub>
cliente4 = {
&amp;#34; apellido &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Findo &amp;#34;
,
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Diego &amp;#34;
,
&amp;#34; localidad &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Morón &amp;#34;
}
id<sub>cliente4</sub> = col<sub>clientes</sub> . insert<sub>one</sub> ( cliente4 ). inserted<sub>id</sub>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 72
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Creación de documentos
#Y definimos algunos productos
col<sub>productos</sub> = bd<sub>empresa</sub> . productos
producto1 = {
&amp;#34; código &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; FD2910 &amp;#34;
,
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Amoladora &amp;#34;
,
&amp;#34; precio &amp;#34;
</p>
<pre class="example">
2200 }

</pre>
<p>
producto2 = {
&amp;#34; código &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; G49 &amp;#34;
,
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Cinta aisladora &amp;#34;
,
&amp;#34; precio &amp;#34;
</p>
<pre class="example">
40 }

</pre>
<p>
producto3 = {
&amp;#34; código &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; EA315 &amp;#34;
,
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Pinza &amp;#34;
}
id<sub>producto1</sub> = col<sub>productos</sub> . insert<sub>one</sub> ( producto1 ). inserted<sub>id</sub>
id<sub>producto2</sub> = col<sub>productos</sub> . insert<sub>one</sub> ( producto2 ). inserted<sub>id</sub>
id<sub>producto3</sub> = col<sub>productos</sub> . insert<sub>one</sub> ( producto3 ). inserted<sub>id</sub>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 73
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
ObjectId’s
de un campo _id.
al documento que dicho hash identifica.
mismo documento en una colección
los hashes de los documentos creados.
pprint . pprint ( id<sub>producto1</sub> )
1
ObjectId (‘
59209152975790214370
fcf
1
’)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 74
</p>























<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Consultas básicas
El resultado es un
cursor
que debe ser iterado.
</p>

<p>
respuesta<sub>query</sub> = col<sub>clientes</sub> . find ({
&amp;#34; localidad &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Morón &amp;#34;
})
for
c
in
respuesta<sub>query</sub> :
pprint . pprint (c)
1
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59208626975790214370
fc
98
’)
,
2
‘ apellido ’
</p>
<pre class="example">


</pre>
<p>
‘Fonseca ’
,
3
‘ localidad ’
</p>
<pre class="example">


</pre>
<p>
‘Morón ’
,
4
‘nombre ’
</p>
<pre class="example">


</pre>
<p>
‘Horacio ’
}
5
{
’<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59208626975790214370
fc
9
a ’)
,
6
‘ apellido ’
</p>
<pre class="example">


</pre>
<p>
‘Findo ’
,
7
‘ localidad ’
</p>
<pre class="example">


</pre>
<p>
‘Morón ’
,
8
‘nombre ’
</p>
<pre class="example">


</pre>
<p>
‘Diego ’
}
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 75
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Documentos embebidos vs. referenciados
Podemos utilizar los ObjectId
0
s para
referenciar
objetos:
pedido1 = {
&amp;#34; cod<sub>pedido</sub> &amp;#34;
</p>
<pre class="example">
78303 ,

</pre>
<p>
&amp;#34; cliente &amp;#34;
</p>
<pre class="example">
id_cliente2 ,

</pre>
<p>
&amp;#34; productos &amp;#34;
</p>
<pre class="example">
[ {

</pre>
<p>
&amp;#34; producto &amp;#34;
</p>
<pre class="example">
id_producto2 ,

</pre>
<p>
&amp;#34; cantidad &amp;#34;
</p>
<pre class="example">
3} ],

</pre>
<p>
&amp;#34; fecha<sub>entrega</sub><sub>limite</sub> &amp;#34;
</p>
<pre class="example">
datetime . datetime (2017 , 6, 18) ,

</pre>
<p>
&amp;#34; entregado &amp;#34;
</p>
<pre class="example">
False }

</pre>
<p>
pprint . pprint ( pedido1 )
1
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59209
fd
2975790214370
fcff ’)
,
2
‘cliente ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59209
fcd
975790214370
fcf
9
’)
,
3
‘ cod<sub>pedido</sub> ’
</p>
<pre class="example">


</pre>
<p>
78303
,
4
‘ entregado ’
</p>
<pre class="example">


</pre>
<p>
False
,
5
‘ fecha<sub>entrega</sub><sub>limite</sub> ’
</p>
<pre class="example">


</pre>
<p>
datetime . datetime (
2017
,
6
,
18
,
0
,
0
)
,
6
‘ productos ‘
</p>
<pre class="example">


</pre>
<p>
[{
‘ cantidad ’
</p>
<pre class="example">


</pre>
<p>
3
,
7
‘ producto ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59209
fcf
975790214370
fcfd ’)
}]}
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 76
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Documentos embebidos vs. referenciados
1
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59209
fd
2975790214370
fcff ’)
,
2
‘cliente ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59209
fcd
975790214370
fcf
9
’)
,
3
‘ cod<sub>pedido</sub> ’
</p>
<pre class="example">


</pre>
<p>
78303
,
4
‘ entregado ’
</p>
<pre class="example">


</pre>
<p>
False
,
5
‘ fecha<sub>entrega</sub><sub>limite</sub> ’
</p>
<pre class="example">


</pre>
<p>
datetime . datetime (
2017
,
6
,
18
,
0
,
0
)
,
6
‘ productos ’
</p>
<pre class="example">


</pre>
<p>
[{
‘ cantidad ’
</p>
<pre class="example">


</pre>
<p>
3
,
7
‘ producto ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
59209
fcf
975790214370
fcfd ’)
}]}
En este caso, el documento relativo al “cliente” queda
referenciado
dentro del pedido.
de documentos que se encuentran directamente
embebidos
(anidados)
dentro del pedido.
“producto”.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 77
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Consultas sobre documentos embebidos y referenciados
</p>

<p>
result = col<sub>pedidos</sub> . find ({
&amp;#34; productos . producto &amp;#34;
</p>
<pre class="example">
id_producto3 })

</pre>
<p>
for
cliente<sub>id</sub>
in
result . distinct (
&amp;#34; cliente &amp;#34;
):
result2 = col<sub>clientes</sub> . find ({
&amp;#34; _id &amp;#34;
</p>
<pre class="example">
cliente_id })

</pre>
<p>
for
cliente
in
result2 :
pprint . pprint ( cliente )
1
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
5920
a
5
ae
975790214370
fd
0
f ’)
,
2
‘ apellido ’
</p>
<pre class="example">


</pre>
<p>
‘Fonseca ’
,
3
‘ localidad ’
</p>
<pre class="example">


</pre>
<p>
‘Morón ’
,
4
‘nombre ’
</p>
<pre class="example">


</pre>
<p>
‘Horacio ’
}
5
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
ObjectId (‘
5920
a
5
ae
975790214370
fd
10
’)
,
6
‘ apellido ’
</p>
<pre class="example">


</pre>
<p>
‘Gandría ’
,
7
‘ localidad ’
</p>
<pre class="example">


</pre>
<p>
‘ Caballito ’
}
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 78
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Consultas sobre documentos embebidos y referenciados
</p>

<p>
result = col<sub>pedidos</sub> . find ({
&amp;#34; productos . producto &amp;#34;
</p>
<pre class="example">
id_producto3 })

</pre>
<p>
for
cliente<sub>id</sub>
in
result . distinct (
&amp;#34; cliente &amp;#34;
):
result2 = col<sub>clientes</sub> . find ({
&amp;#34; _id &amp;#34;
</p>
<pre class="example">
cliente_id })

</pre>
<p>
for
cliente
in
result2 :
pprint . pprint ( cliente )
Como “productos” está embebido, utilizamos
.
para indicar el
subatributo.
debemos hacer una subconsulta para ir a buscar sus datos.
A qué se parece este tipo de consulta? Junta en SQL!!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 79
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Juntas
forma eficiente.
a mano, como en el ejemplo anterior.
Pero, ¿y la
no redundancia
de datos? ¿y la
normalización
?
en el procesamiento de los datos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 80
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Juntas
entre colecciones completas.
concretos para una consulta en particular.
tiempo.
comando
lookup
, que permite realizar la junta entre dos
baja eficiencia.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 81
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Agregación
pipeline.
</p>

<p>
#y mostramos sólo aquellas en que vive a lo sumo un cliente :
result = col<sub>clientes</sub> . aggregate ( [
{
&amp;#34; $group &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; _id &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $localidad &amp;#34;
,
&amp;#34; cantidad &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $sum &amp;#34;
</p>
<pre class="example">
1 } } },

</pre>
<p>
{
&amp;#34; $match &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; cantidad &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $lte &amp;#34;
</p>
<pre class="example">


</pre>
<p>
1 } } } ])
for
cliente
in
result :
pprint . pprint ( cliente )
1
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘ Caballito ’
,
‘ cantidad ’
</p>
<pre class="example">


</pre>
<p>
1
}
2
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
None
,
‘ cantidad ’
</p>
<pre class="example">


</pre>
<p>
1
}
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 82
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Agregación
operaciones, entre otras:
match
</p>
<pre class="example">
Filtrado de resultados.

</pre>
<p>
group
</p>
<pre class="example">
Agrupamiento de los resultados por uno o más atributos,

</pre>
<p>
aplicando funciones de agregación.
sort
</p>
<pre class="example">
Ordenamiento de resultados.

</pre>
<p>
limit
</p>
<pre class="example">
Limitado de resultados.

</pre>
<p>
sample
</p>
<pre class="example">
Selección aleatoria de resultados.

</pre>
<p>
unwind
</p>
<pre class="example">
Deconstrucción de un atributo de tipo vector.

</pre>
<p>
utilizado como entrada por la siguiente operación del pipeline.
dentro del pipeline.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 83
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Agregación: Restaurantes
puntajes de restaurantes extraída de:
<a href="https://raw.githubusercontent.com/mongodb/docs-assets/primer-dataset/primer-dataset.json">https://raw.githubusercontent.com/mongodb/docs-assets/primer-dataset/primer-dataset.json</a>
.
con la siguiente instrucción:
Importación de documentos JSON
restaurants.json
“restaurants” en la base de datos “test”.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 84
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Agregación: Restaurantes
Cada documento de la colección tiene el siguiente aspecto:
1
Restaurant =
{
2
&amp;#34; address &amp;#34;
</p>
<pre class="example">


</pre>
<p>
{
3
&amp;#34; building &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34;
1007
&amp;#34;
,
4
&amp;#34; coord &amp;#34;
</p>
<pre class="example">


</pre>
<p>
[
−
73
.
856077
,
40
.
848447
]
,
5
&amp;#34; building &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Morris Park Ave &amp;#34;
,
6
&amp;#34; zipcode &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34;
10462
&amp;#34;
7
}
8
&amp;#34; borough &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Bronx &amp;#34;
,
9
&amp;#34; cuisine &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Bakery &amp;#34;
,
10
&amp;#34; grades &amp;#34;
</p>
<pre class="example">


</pre>
<p>
[
11
{
&amp;#34; date &amp;#34;
</p>
<pre class="example">


</pre>
<p>
{
&amp;#34; $date &amp;#34;
</p>
<pre class="example">


</pre>
<p>
1393804800
}
,
&amp;#34; grade &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34;A&amp;#34;
,
&amp;#34; score &amp;#34;
</p>
<pre class="example">


</pre>
<p>
2
}
,
12
{
&amp;#34; date &amp;#34;
</p>
<pre class="example">


</pre>
<p>
{
&amp;#34; $date &amp;#34;
</p>
<pre class="example">


</pre>
<p>
1358985600
}
,
&amp;#34; grade &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34;A&amp;#34;
,
&amp;#34; score &amp;#34;
</p>
<pre class="example">


</pre>
<p>
10
}
,
13
&#x2026;..
14
{
&amp;#34; date &amp;#34;
</p>
<pre class="example">


</pre>
<p>
{
&amp;#34; $date &amp;#34;
</p>
<pre class="example">


</pre>
<p>
1322006400
}
,
&amp;#34; grade &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34;A&amp;#34;
,
&amp;#34; score &amp;#34;
</p>
<pre class="example">


</pre>
<p>
9
}]
,
15
&amp;#34; name &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Morris Park Bake Shop &amp;#34;
,
16
&amp;#34; restaurant<sub>id</sub> &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34;
30075445
&amp;#34;
17
}
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 85
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Agregación: Restaurantes
</p>

<p>
result = col<sub>restaurants</sub> . aggregate ( [
{
&amp;#34; $match &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; cuisine &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $eq &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; Italian &amp;#34;
} } },
{
&amp;#34; $group &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; _id &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $borough &amp;#34;
,
&amp;#34; cantidad &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $sum &amp;#34;
</p>
<pre class="example">
1 } } },

</pre>
<p>
{
&amp;#34; $sort &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; cantidad &amp;#34;
</p>
<pre class="example">


</pre>
<p>
−
1 } },
{
&amp;#34; $limit &amp;#34;
</p>
<pre class="example">
3 }

</pre>
<p>
])
for
r
in
result :
pprint . pprint (r)
1
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘ Manhattan ’
,
‘ cantidad ’
</p>
<pre class="example">


</pre>
<p>
621
}
2
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘ Brooklyn ’
,
‘ cantidad ’
</p>
<pre class="example">


</pre>
<p>
192
}
3
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘Queens ’
,
‘ cantidad ’
</p>
<pre class="example">


</pre>
<p>
131
}
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 86
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
</p>

<p>
result = col<sub>restaurants</sub> . aggregate ( [
{
&amp;#34; $unwind &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $grades &amp;#34;
},
{
&amp;#34; $group &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; _id &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $restaurant<sub>id</sub> &amp;#34;
,
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $first &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $name &amp;#34;
},
&amp;#34; puntaje &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $avg &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $grades . score &amp;#34;
},
&amp;#34; cant<sub>calificaciones</sub> &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $sum &amp;#34;
</p>
<pre class="example">
1 } } },

</pre>
<p>
{
&amp;#34; $match &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; cant<sub>calificaciones</sub> &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; $gte &amp;#34;
</p>
<pre class="example">
5 } } },

</pre>
<p>
{
&amp;#34; $sort &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; puntaje &amp;#34;
</p>
<pre class="example">


</pre>
<p>
−
1 } },
{
&amp;#34; $limit &amp;#34;
</p>
<pre class="example">
4 },

</pre>
<p>
{
&amp;#34; $project &amp;#34;
</p>
<pre class="example">
{

</pre>
<p>
&amp;#34; nombre &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $nombre &amp;#34;
,
&amp;#34; puntaje &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; $puntaje &amp;#34;
} } ]) $
1
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘
403934
’
,
‘nombre ’
</p>
<pre class="example">


</pre>
<p>
‘ Bella Napoli ’
,
‘puntaje ’
</p>
<pre class="example">


</pre>
<p>
38
.
6
}
2
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘
412673
’
,
‘nombre ’
</p>
<pre class="example">


</pre>
<p>
‘ Tenda Asian Fusion ’
,
‘puntaje ’
</p>
<pre class="example">


</pre>
<p>
37
.
4
}
3
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘
416025
’
,
‘nombre ’
</p>
<pre class="example">


</pre>
<p>
‘Red Chopstick ’
,
‘puntaje ’
</p>
<pre class="example">


</pre>
<p>
36
.
3
}
4
{
‘<sub>id</sub> ’
</p>
<pre class="example">


</pre>
<p>
‘
415504
’
,
‘nombre ’
</p>
<pre class="example">


</pre>
<p>
‘El Mixteco ’
,
‘puntaje ’
</p>
<pre class="example">


</pre>
<p>
34
.
8
}
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 87
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Ejemplo
archivo
mongo.ipynb
.
Quedan en el tintero&#x2026;
Creación de índices
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 88
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Sharding
conocido como
sharding
.
chunks que se distribuyen en nodos denominados
shards
. Cada
Un
sharding cluster
de MongoDB está formado por distintos tipos
de nodos de ejecución:
Los
shards (fragmentos)
</p>
<pre class="example">
Son los nodos en los que se distribuyen

</pre>
<p>
Los
routers
</p>
<pre class="example">
Son los nodos servidores que reciben las consultas

</pre>
<p>
Los
servidores de configuración
</p>
<pre class="example">
Son los que almacenan la

</pre>
<p>
configuración de los routers y los shards.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 24.3.3]
</p>






<p>
Page 89
</p>














<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Sharding: Esquema
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 90
</p>



















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Sharding
El particionado de las colecciones se realiza a partir de una
shard
key
. La shard key debe ser un atributo ó conjunto de atributos
inmutable
de la colección, y se escoge en el momento de
construir el sharded cluster.
rangos los valores de la shard key
sh . shardCollection (
&amp;#34; db<sub>empresa</sub> . col<sub>clientes</sub> &amp;#34;
,
{
&amp;#34; localidad &amp;#34;
</p>
<pre class="example">


</pre>
<p>
&amp;#34; hashed &amp;#34;
}, unique = False )
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 91
</p>





















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Sharding
En un contexto de sharding es posible tener algunas colecciones
sharded (fragmentadas)
y otras
unsharded (no fragmentadas)
.
almacenarán en un shard particular del cluster, que será el
shard
primario
para esa base de datos.
siguientes restricciones:
1
ya existentes de la colección.
2
Si no lo tiene, MongoDB lo creará.
3
shard key, ni cambiar (update) su valor en ningún documento.
4
fue fragmentada (sharded) .
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 92
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Sharding: Objetivos
El sharding permite:
podrían caber en un único servidor.
El objetivo es que la base de datos sea
escalable
para proveer
soporte al procesamiento de Big Data.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 93
</p>
















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Replicación
MongoDB también brinda
tolerancia a fallas
a través de un
mecanismo de
replicación
de shards.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 94
</p>




















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos orientadas a documentos
MongoDB
Replicación
El esquema de réplicas es de
master-slave with automated
failover (maestro-esclavo con recuperación automática)
</p>
<pre class="example">


</pre>
<p>
réplicas de un shard se denomina
replica set
.
master.
replica sets.
el master. Los slaves sólo sirven de respaldo.
Los clientes pueden especificar una
read preference
para que las
lecturas sean enviadas a nodos secundarios de los shards.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 95
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos basadas en grafos
1
Introducción
2
Bases de datos distribuidas
3
Bases de datos NoSQL
</p>

<p>
Bases de datos wide column vs. por columnas
Bases de datos orientadas a documentos
Bases de datos basadas en grafos
4
El modelo MapReduce
5
Teorema CAP
6
Bibliografía
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 96
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos basadas en grafos
Bases de datos basadas en grafos
En las
bases de datos basadas en grafos
los elementos
principales son nodos y arcos (ejes).
entre entidades distintas utilizando claves foráneas.
Ejemplo:
HijoDe(dni, dni<sub>padre</sub>)
porque requiere de múltiples juntas.
nodo mantiene una referencia directa a sus nodos adyacentes.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 97
</p>


















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos basadas en grafos
Bases de datos basadas en grafos
Aplicaciones
ventajas para resolver problemas clásicos de grafos como:
Calcular medidas de centralidad asociadas a los nodos.
mismo tipo de entidad.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 98
</p>

















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos basadas en grafos
Neo4j
conocidas.
Está desarrollada en Java.
Es actualmente utilizada por empresas como Cisco, HP y Huawei.
distribuidas.
Posee APIs en distintos lenguajes: Python, Ruby, Java, &#x2026;
Utiliza un lenguaje de consulta declarativo denominado
Cypher
.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>

<p>
[ELM16 24.6]
</p>






<p>
Page 99
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos basadas en grafos
Neo4j
Neo4j para Linux y la API de Neo4j para Python.
3
1-Instalación del servidor de Neo4j
tar zxf neo4j-community-3.4.4-unix.tar.gz
2-Instalación de la API para Python
pip install neo4j-driver
3-Lanzamiento del servidor de Neo4j
./bin/neo4j start
3
Como alternativa se puede jugar con la consola online:
<a href="http://console.neo4j.org/">http://console.neo4j.org/</a>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
</p>







<p>
Page 100
</p>






















<p>
NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos NoSQL
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Bases de datos basadas en grafos
Neo4j
Estructura: Nodos, labels y propiedades.
CREATE
Una base de datos Neo4j está formada por
nodos
.
Un nodo puede tener distintos
labels
. Dentro de cada label, el
nodo tendrá un conjunto de
propiedades
con determinados
valores
.
1
( tom
</p>
<pre class="example">


</pre>
<p>
Persona
{
nombre
</p>
<pre class="example">


</pre>
<p>
’Tomás ’
,
color
</p>
<pre class="example">


</pre>
<p>
’Azul ’
,
prof
</p>
<pre class="example">


</pre>
<p>
’ Estudiante ’
}
)
tener los nodos con determinado label.
1
( edith
</p>
<pre class="example">


</pre>
<p>
Persona
{
nombre
</p>
<pre class="example">


</pre>
<p>
’Tomás ’
,
color
</p>
<pre class="example">


</pre>
<p>
’Verde ’
,
prof
</p>
<pre class="example">


</pre>
<p>
’Músico ’
}
)
2
( maria
</p>
<pre class="example">


</pre>
<p>
Persona
{
nombre
</p>
<pre class="example">


</pre>
<p>
’María ’
,
prof
</p>
<pre class="example">


</pre>
<p>
’ Estudiante ’
}
)
3
( gaby
</p>
<pre class="example">


</pre>
<p>
Persona
{
nombre
</p>
<pre class="example">


</pre>
<p>
’Gabriel ’
,
color
</p>
<pre class="example">


</pre>
<p>
’Verde ’
,
prof
</p>
<pre class="example">


</pre>
<p>
’Médico ’
}
)
En Cypher, los nodos se crean con el comando
CREATE
</p>
<pre class="example">


</pre>
<p>
1
CREATE ( pepe
</p>
<pre class="example">


</pre>
<p>
Persona
{
nombre
</p>
<pre class="example">


</pre>
<p>
’Pepe ’
,
color
</p>
<pre class="example">


</pre>
<p>
’Azul ’
}
)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
10 de octubre de 2018
1
</p>
</div>
<div id="postamble" class="status">
Last update: 2020-02-03 19:40
</div>
</body>
</html>
 
