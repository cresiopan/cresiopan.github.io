#+TITLE: Ventana deslizante y TCP
#+date: <2020-05-29 Fri>

* Pipelined reliable Data Transfer Protocols

Protocol rdt3.0 is a functionally correct protocol, but its performance problem
is the fact that it is a stop-and-wait protocol.

imagen 3.16

This stop-and-wait protocol limits the sender ~utilization~ of the channel (the
amount of time the sender actually sends bits into the channel).

image 3.17


The solution to this particular performance problem is simple: Rather than operate in a stop-and-wait
manner, the sender is allowed to send multiple packets without waiting for acknowledgments.

illustrated in Figure 3.17(b). Figure 3.18(b) shows that if the sender is allowed to transmit three packets
before having to wait for acknowledgments, the utilization of the sender is essentially tripled.

this technique is known as ~pipelining~. Pipelining has the following consequences
for reliable data transfer protocols:

- The range of sequence numbers must be increased, since each in-transit packet
  (not counting retransmissions) must have a unique sequence number and there
  may be multiple, in-transit, unacknowledged packets.
- The sender and receiver sides of the protocols may have to buffer more than
  one packet. Minimally, the sender will have to buffer packets that have been
  transmitted but not yet acknowledged. Buffering of correctly received packets
  may also be needed at the receiver, as discussed below.
- The range of sequence numbers needed and the buffering requirements will
  depend on the manner in which a data transfer protocol responds to lost,
  corrupted, and overly delayed packets. Two basic approaches toward pipelined
  error recovery can be identified: ~Go-Back-N~ and ~selective repeat~.

imagen 3.18

** Go-Back-N (GBN)

In a Go-Back-N (GBN) protocol, the sender is allowed to transmit multiple packets (when available)
without waiting for an acknowledgment, but is constrained to have no more than some maximum
allowable number, N, of unacknowledged packets in the pipeline.

imagen 3.19

Figure 3.19 shows the sender’s view of the range of sequence numbers in a GBN
protocol. If we define ~base~ to be the sequence number of the oldest
unacknowledged packet and ~nextseqnum~ to be the smallest unused sequence number
(that is, the sequence number of the next packet to be sent), then four
intervals in the range of sequence numbers can be identified.

Sequence numbers in the interval
- ~[ 0, base-1 ]~ correspond to packets that have already been transmitted and
  acknowledged.
- ~[base, nextseqnum-1]~ corresponds to packets that have been sent but not yet
  acknowledged. Sequence numbers in the interval
- ~[nextseqnum, base+N-1]~ can be used for packets that can be sent immediately,
  should data arrive from the upper layer.
- ~[base+N, ...]~ cannot be used until an unacknowledged packet currently in the
  pipeline (specifically, the packet with sequence number ~base~ ) has been
  acknowledged.

the range of permissible sequence numbers for transmitted but not yet
acknowledged packets can be viewed as a window of size ~N~ over the range of
sequence numbers.

As the protocol operates, this window slides forward over the sequence number
space. For this reason, ~N~ is often referred to as the ~window size~ and the
GBN protocol itself as a ~sliding-window protocol~.



You might be wondering *why we would even limit the number of outstanding,
unacknowledged packets to a value of N?**. *Why not allow an
unlimited number of such packets?*

flow control is one reason to impose a limit on the sender. We’ll examine
another reason to do so when we study TCP congestion control.



In practice, a packet’s sequence number is carried in a fixed-length field in the packet header. If k is the
number of bits in the packet sequence number field, the range of sequence numbers is thus

Figures 3.20 and 3.21 give an extended FSM description of the sender and receiver sides of an ACK-based, NAK-free, GBN protocol.

imagen 3.20

imagen 3.21

we have added variables (similar to programming-language variables) for base and
nextseqnum , and added operations on these variables and conditional actions
involving these variables.

The GBN sender must respond to three types of events:
- Invocation from above :: When rdt_send() is called from above, the sender
  first checks to see if the window is full, that is, whether there are N
  outstanding, unacknowledged packets.
  - If the window is not full, a packet is created and sent, and variables are
    appropriately updated.
  - If the window is full, the sender simply returns the data back to the upper
    layer, an implicit indication that the window is full.
  The upper layer would presumably then have to try again later. In a real
  implementation, the sender would more likely have either buffered (but not
  immediately sent) this data, or would have a synchronization mechanism (for
  example, a semaphore or a flag) that would allow the upper layer to call
  rdt_send() only when the window is not full.
- Receipt of an ACK :: In our GBN protocol, an acknowledgment for a packet with
  sequence number n will be taken to be a ~cumulative acknowledgment~,
  indicating that all packets with a sequence number up to and including n have
  been correctly received at the receiver.
- A timeout event :: The protocol’s name, “Go-Back-N,” is derived from the
  sender’s behavior in the presence of lost or overly delayed packets. As in the
  stop-and-wait protocol, a timer will again be used to recover from lost data
  or acknowledgment packets. If a timeout occurs, the sender resends all packets
  that have been previously sent but that have not yet been acknowledged. Our
  sender in Figure 3.20 uses only a single timer, which can be thought of as a
  timer for the oldest transmitted but not yet acknowledged packet. If an ACK is
  received but there are still additional transmitted but not yet acknowledged
  packets, the timer is restarted. If there are no outstanding, unacknowledged
  packets, the timer is stopped.


The receiver’s actions in GBN are :
- If a packet with sequence number n is received correctly and is in order (that
  is, the data last delivered to the upper layer came from a packet with
  sequence number ), the receiver sends an ACK for packet n and delivers the
  data portion of the packet to the upper layer.
- In all other cases, the receiver discards the packet and resends an ACK for
  the most recently received in-order packet. Note that since packets are
  delivered one at a time to the upper layer, if packet k has been received and
  delivered, then all packets with a sequence number lower than k have also been
  delivered. Thus, the use of ~cumulative acknowledgments~ is a natural choice for GBN.


*In our GBN protocol, the receiver discards out-of-order packets.*

Recall that the receiver must deliver data in order to the upper layer. Suppose
now that packet n is expected, but packet n+1 arrives. Because data must be
delivered in order, the receiver could buffer packet n+1 and then deliver
this packet to the upper layer after it had later received and delivered packet
n. However, if packet n is lost, both it and packet n+1 will eventually be
retransmitted as a result of the GBN retransmission rule at the sender.

Thus, the receiver can simply discard packet.

The advantage is the simplicity of receiver buffering—the receiver need not
buffer any out-of-order packets. Thus, while the sender must maintain the upper
and lower bounds of its window and the position of ~nextseqnum~ within this
window, the only piece of information the receiver need maintain is the sequence
number of the next in-order packet held in the variable ~expectedseqnum~.

the disadvantage of throwing away a correctly received packet is that the
subsequent retransmission of that packet might be lost or garbled and thus even
more retransmissions would be required.

imagen 3.22

Figure 3.22 shows the operation of the GBN protocol for the case of a window
size of four packets. Because of this window size limitation, the sender sends
packets 0 through 3 but then must wait for one or more of these packets to be
acknowledged before proceeding. As each successive ACK (for example, ACK0 and
ACK1 ) is received, the window slides forward and the sender can transmit one
new packet (pkt4 and pkt5, respectively). On the receiver side, packet 2 is lost
and thus packets 3, 4, and 5 are found to be out of order and are discarded.




** Selective Repeat (SR)
